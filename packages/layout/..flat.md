# Contents of . source tree

## File: package.json

```json
{
  "name": "@app/layout",
  "version": "0.8.8",
  "description": "A multi-tab docking layout manager",
  "type": "module",
  "main": "./src/index.ts",
  "module": "./src/index.ts",
  "types": "./src/index.ts",
  "exports": {
    ".": {
      "types": "./src/index.ts",
      "import": "./src/index.ts",
      "require": "./src/index.ts"
    },
    "./style.css": "./src/style.css"
  },
  "scripts": {
    "typecheck": "tsc --noEmit"
  },
  "peerDependencies": {
    "react": "^19.0.0",
    "react-dom": "^19.0.0"
  },
  "devDependencies": {
    "@app/typescript-config": "workspace:*",
    "@types/node": "^22.13.11",
    "@types/react": "^19.0.12",
    "@types/react-dom": "^19.0.4",
    "typescript": "^5.8.2"
  }
}

```

## File: tsconfig.json

```json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "@app/typescript-config/react-library.json",
  "compilerOptions": {
    "moduleResolution": "bundler",
    "module": "ESNext",
    "noEmit": true,
    "sourceMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "lib", "bundles", "examples"]
}

```

## File: biome.json

```json
{
	"extends": ["../../biome.json"]
}

```

## File: src/I18nLabel.ts

```typescript
export enum I18nLabel {
    Close_Tab = "Close",
    Close_Tabset = "Close tab set",
    Active_Tabset = "Active tab set",
    Move_Tabset = "Move tab set",
    Move_Tabs = "Move tabs(?)",
    Maximize = "Maximize tab set",
    Restore = "Restore tab set",
    Popout_Tab = "Popout selected tab",
    Overflow_Menu_Tooltip = "Hidden tabs",
    Error_rendering_component = "Error rendering component",
}

```

## File: src/DockLocation.ts

```typescript
import { Orientation } from "./Orientation";
import { Rect } from "./Rect";

export class DockLocation {
    static values = new Map<string, DockLocation>();
    static TOP = new DockLocation("top", Orientation.VERT, 0);
    static BOTTOM = new DockLocation("bottom", Orientation.VERT, 1);
    static LEFT = new DockLocation("left", Orientation.HORZ, 0);
    static RIGHT = new DockLocation("right", Orientation.HORZ, 1);
    static CENTER = new DockLocation("center", Orientation.VERT, 0);

    /** @internal */
    static getByName(name: string): DockLocation {
        return DockLocation.values.get(name)!;
    }

    /** @internal */
    static getLocation(rect: Rect, x: number, y: number) {
        x = (x - rect.x) / rect.width;
        y = (y - rect.y) / rect.height;

        if (x >= 0.25 && x < 0.75 && y >= 0.25 && y < 0.75) {
            return DockLocation.CENTER;
        }

        // Whether or not the point is in the bottom-left half of the rect
        // +-----+
        // |\    |
        // |x\   |
        // |xx\  |
        // |xxx\ |
        // |xxxx\|
        // +-----+
        const bl = y >= x;

        // Whether or not the point is in the bottom-right half of the rect
        // +-----+
        // |    /|
        // |   /x|
        // |  /xx|
        // | /xxx|
        // |/xxxx|
        // +-----+
        const br = y >= 1 - x;

        if (bl) {
            return br ? DockLocation.BOTTOM : DockLocation.LEFT;
        } else {
            return br ? DockLocation.RIGHT : DockLocation.TOP;
        }
    }

    /** @internal */
    name: string;
    /** @internal */
    orientation: Orientation;
    /** @internal */
    indexPlus: number;

    /** @internal */
    constructor(_name: string, _orientation: Orientation, _indexPlus: number) {
        this.name = _name;
        this.orientation = _orientation;
        this.indexPlus = _indexPlus;
        DockLocation.values.set(this.name, this);
    }

    getName() {
        return this.name;
    }

    getOrientation() {
        return this.orientation;
    }

    /** @internal */
    getDockRect(r: Rect) {
        if (this === DockLocation.TOP) {
            return new Rect(r.x, r.y, r.width, r.height / 2);
        } else if (this === DockLocation.BOTTOM) {
            return new Rect(r.x, r.getBottom() - r.height / 2, r.width, r.height / 2);
        }
        if (this === DockLocation.LEFT) {
            return new Rect(r.x, r.y, r.width / 2, r.height);
        } else if (this === DockLocation.RIGHT) {
            return new Rect(r.getRight() - r.width / 2, r.y, r.width / 2, r.height);
        } else {
            return r.clone();
        }
    }

    /** @internal */
    split(rect: Rect, size: number) {
        if (this === DockLocation.TOP) {
            const r1 = new Rect(rect.x, rect.y, rect.width, size);
            const r2 = new Rect(rect.x, rect.y + size, rect.width, rect.height - size);
            return { start: r1, end: r2 };
        } else if (this === DockLocation.LEFT) {
            const r1 = new Rect(rect.x, rect.y, size, rect.height);
            const r2 = new Rect(rect.x + size, rect.y, rect.width - size, rect.height);
            return { start: r1, end: r2 };
        }
        if (this === DockLocation.RIGHT) {
            const r1 = new Rect(rect.getRight() - size, rect.y, size, rect.height);
            const r2 = new Rect(rect.x, rect.y, rect.width - size, rect.height);
            return { start: r1, end: r2 };
        } else {
            // if (this === DockLocation.BOTTOM) {
            const r1 = new Rect(rect.x, rect.getBottom() - size, rect.width, size);
            const r2 = new Rect(rect.x, rect.y, rect.width, rect.height - size);
            return { start: r1, end: r2 };
        }
    }

    /** @internal */
    reflect() {
        if (this === DockLocation.TOP) {
            return DockLocation.BOTTOM;
        } else if (this === DockLocation.LEFT) {
            return DockLocation.RIGHT;
        }
        if (this === DockLocation.RIGHT) {
            return DockLocation.LEFT;
        } else {
            // if (this === DockLocation.BOTTOM) {
            return DockLocation.TOP;
        }
    }

    toString() {
        return "(DockLocation: name=" + this.name + ", orientation=" + this.orientation + ")";
    }
}

```

## File: src/Rect.ts

```typescript
import { IJsonRect } from "./model/IJsonModel";
import { Orientation } from "./Orientation";

export class Rect {
    static empty() {
        return new Rect(0, 0, 0, 0);
    }

    static fromJson(json: IJsonRect): Rect {
        return new Rect(json.x, json.y, json.width, json.height);
    }

    x: number;
    y: number;
    width: number;
    height: number;

    constructor(x: number, y: number, width: number, height: number) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    toJson() {
        return {x: this.x, y: this.y, width: this.width, height: this.height};
    }

    snap(round: number) {
        this.x = Math.round(this.x / round) * round;
        this.y = Math.round(this.y / round) * round;
        this.width = Math.round(this.width / round) * round;
        this.height= Math.round(this.height / round) * round;
    }

    static getBoundingClientRect(element: Element) {
        let { x, y, width, height } = element.getBoundingClientRect();
        return new Rect(x, y, width, height);
    }

    static getContentRect(element: HTMLElement) {
        const rect = element.getBoundingClientRect();
        const style = window.getComputedStyle(element);

        const paddingLeft = parseFloat(style.paddingLeft);
        const paddingRight = parseFloat(style.paddingRight);
        const paddingTop = parseFloat(style.paddingTop);
        const paddingBottom = parseFloat(style.paddingBottom);
        const borderLeftWidth = parseFloat(style.borderLeftWidth);
        const borderRightWidth = parseFloat(style.borderRightWidth);
        const borderTopWidth = parseFloat(style.borderTopWidth);
        const borderBottomWidth = parseFloat(style.borderBottomWidth);

        const contentWidth = rect.width - borderLeftWidth - paddingLeft - paddingRight - borderRightWidth;
        const contentHeight = rect.height - borderTopWidth - paddingTop - paddingBottom - borderBottomWidth;

        return new Rect(
            rect.left + borderLeftWidth + paddingLeft,
            rect.top + borderTopWidth + paddingTop,
            contentWidth,
            contentHeight,
        );
    }

    static fromDomRect(domRect: DOMRect) {
        return new Rect(domRect.x, domRect.y, domRect.width, domRect.height);
    }

    relativeTo(r: Rect | DOMRect) {
        return new Rect(this.x - r.x, this.y - r.y, this.width, this.height);
    }

    clone() {
        return new Rect(this.x, this.y, this.width, this.height);
    }

    equals(rect: Rect | null | undefined) {
        return this.x === rect?.x && this.y === rect?.y && this.width === rect?.width && this.height === rect?.height
    }

    equalSize(rect: Rect | null | undefined) {
        return this.width === rect?.width && this.height === rect?.height
    }

    getBottom() {
        return this.y + this.height;
    }

    getRight() {
        return this.x + this.width;
    }

    get bottom() {
        return this.y + this.height;
    }

    get right() {
        return this.x + this.width;
    }

    getCenter() {
        return { x: this.x + this.width / 2, y: this.y + this.height / 2 };
    }

    positionElement(element: HTMLElement, position?: string) {
        this.styleWithPosition(element.style, position);
    }

    styleWithPosition(style: Record<string, any>, position: string = "absolute") {
        style.left = this.x + "px";
        style.top = this.y + "px";
        style.width = Math.max(0, this.width) + "px"; // need Math.max to prevent -ve, cause error in IE
        style.height = Math.max(0, this.height) + "px";
        style.position = position;
        return style;
    }

    contains(x: number, y: number) {
        if (this.x <= x && x <= this.getRight() && this.y <= y && y <= this.getBottom()) {
            return true;
        } else {
            return false;
        }
    }

    removeInsets(insets: { top: number; left: number; bottom: number; right: number }) {
        return new Rect(this.x + insets.left, this.y + insets.top, Math.max(0, this.width - insets.left - insets.right), Math.max(0, this.height - insets.top - insets.bottom));
    }

    centerInRect(outerRect: Rect) {
        this.x = (outerRect.width - this.width) / 2;
        this.y = (outerRect.height - this.height) / 2;
    }

    /** @internal */
    _getSize(orientation: Orientation) {
        let prefSize = this.width;
        if (orientation === Orientation.VERT) {
            prefSize = this.height;
        }
        return prefSize;
    }

    toString() {
        return "(Rect: x=" + this.x + ", y=" + this.y + ", width=" + this.width + ", height=" + this.height + ")";
    }
}

```

## File: src/Types.ts

```typescript
export enum CLASSES {
    FLEXLAYOUT__BORDER = "flexlayout__border",
    FLEXLAYOUT__BORDER_ = "flexlayout__border_",

    FLEXLAYOUT__BORDER_TAB_CONTENTS = "flexlayout__border_tab_contents",
    FLEXLAYOUT__BORDER_BUTTON = "flexlayout__border_button",
    FLEXLAYOUT__BORDER_BUTTON_ = "flexlayout__border_button_",
    FLEXLAYOUT__BORDER_BUTTON_CONTENT = "flexlayout__border_button_content",
    FLEXLAYOUT__BORDER_BUTTON_LEADING = "flexlayout__border_button_leading",
    FLEXLAYOUT__BORDER_BUTTON_TRAILING = "flexlayout__border_button_trailing",
    FLEXLAYOUT__BORDER_BUTTON__SELECTED = "flexlayout__border_button--selected",
    FLEXLAYOUT__BORDER_BUTTON__UNSELECTED = "flexlayout__border_button--unselected",
    FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_OVERFLOW = "flexlayout__border_toolbar_button_overflow",
    FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_OVERFLOW_ = "flexlayout__border_toolbar_button_overflow_",

    FLEXLAYOUT__BORDER_INNER = "flexlayout__border_inner",
    FLEXLAYOUT__BORDER_INNER_ = "flexlayout__border_inner_",
    FLEXLAYOUT__BORDER_INNER_TAB_CONTAINER = "flexlayout__border_inner_tab_container",
    FLEXLAYOUT__BORDER_INNER_TAB_CONTAINER_ = "flexlayout__border_inner_tab_container_",
    FLEXLAYOUT__BORDER_TAB_DIVIDER = "flexlayout__border_tab_divider",

    FLEXLAYOUT__BORDER_SIZER = "flexlayout__border_sizer",

    FLEXLAYOUT__BORDER_TOOLBAR = "flexlayout__border_toolbar",
    FLEXLAYOUT__BORDER_TOOLBAR_ = "flexlayout__border_toolbar_",
    FLEXLAYOUT__BORDER_TOOLBAR_BUTTON = "flexlayout__border_toolbar_button",
    FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_FLOAT = "flexlayout__border_toolbar_button-float",

    FLEXLAYOUT__DRAG_RECT = "flexlayout__drag_rect",


    FLEXLAYOUT__ERROR_BOUNDARY_CONTAINER = "flexlayout__error_boundary_container",
    FLEXLAYOUT__ERROR_BOUNDARY_CONTENT = "flexlayout__error_boundary_content",

    FLEXLAYOUT__FLOATING_WINDOW_CONTENT = "flexlayout__floating_window_content",

    FLEXLAYOUT__LAYOUT = "flexlayout__layout",
    FLEXLAYOUT__LAYOUT_MOVEABLES = "flexlayout__layout_moveables",
    FLEXLAYOUT__LAYOUT_OVERLAY = "flexlayout__layout_overlay",
    FLEXLAYOUT__LAYOUT_TAB_STAMPS = "flexlayout__layout_tab_stamps",
    FLEXLAYOUT__LAYOUT_MAIN = "flexlayout__layout_main",
    FLEXLAYOUT__LAYOUT_BORDER_CONTAINER = "flexlayout__layout_border_container",
    FLEXLAYOUT__LAYOUT_BORDER_CONTAINER_INNER = "flexlayout__layout_border_container_inner",

    FLEXLAYOUT__OUTLINE_RECT = "flexlayout__outline_rect",
    FLEXLAYOUT__OUTLINE_RECT_EDGE = "flexlayout__outline_rect_edge",

    FLEXLAYOUT__SPLITTER = "flexlayout__splitter",
    FLEXLAYOUT__SPLITTER_EXTRA = "flexlayout__splitter_extra",
    FLEXLAYOUT__SPLITTER_ = "flexlayout__splitter_",
    FLEXLAYOUT__SPLITTER_BORDER = "flexlayout__splitter_border",
    FLEXLAYOUT__SPLITTER_DRAG = "flexlayout__splitter_drag",
    FLEXLAYOUT__SPLITTER_HANDLE = "flexlayout__splitter_handle",
    FLEXLAYOUT__SPLITTER_HANDLE_HORZ = "flexlayout__splitter_handle_horz",
    FLEXLAYOUT__SPLITTER_HANDLE_VERT = "flexlayout__splitter_handle_vert",

    FLEXLAYOUT__ROW = "flexlayout__row",
    FLEXLAYOUT__TAB = "flexlayout__tab",
    FLEXLAYOUT__TAB_POSITION = "flexlayout__tab_position",
    FLEXLAYOUT__TAB_MOVEABLE = "flexlayout__tab_moveable",
    FLEXLAYOUT__TAB_OVERLAY = "flexlayout__tab_overlay",

    FLEXLAYOUT__TABSET = "flexlayout__tabset",
    FLEXLAYOUT__TABSET_CONTAINER = "flexlayout__tabset_container",
    FLEXLAYOUT__TABSET_HEADER = "flexlayout__tabset_header",
    FLEXLAYOUT__TABSET_HEADER_CONTENT = "flexlayout__tabset_header_content",
    FLEXLAYOUT__TABSET_MAXIMIZED = "flexlayout__tabset-maximized",
    FLEXLAYOUT__TABSET_SELECTED = "flexlayout__tabset-selected",
    FLEXLAYOUT__TABSET_TAB_DIVIDER = "flexlayout__tabset_tab_divider",
    FLEXLAYOUT__TABSET_CONTENT = "flexlayout__tabset_content",
    FLEXLAYOUT__TABSET_TABBAR_INNER = "flexlayout__tabset_tabbar_inner",
    FLEXLAYOUT__TABSET_TABBAR_INNER_ = "flexlayout__tabset_tabbar_inner_",

    FLEXLAYOUT__TABSET_TABBAR_INNER_TAB_CONTAINER = "flexlayout__tabset_tabbar_inner_tab_container",
    FLEXLAYOUT__TABSET_TABBAR_INNER_TAB_CONTAINER_ = "flexlayout__tabset_tabbar_inner_tab_container_",

    FLEXLAYOUT__TABSET_TABBAR_OUTER = "flexlayout__tabset_tabbar_outer",
    FLEXLAYOUT__TABSET_TABBAR_OUTER_ = "flexlayout__tabset_tabbar_outer_",

    FLEXLAYOUT__TAB_BORDER = "flexlayout__tab_border",
    FLEXLAYOUT__TAB_BORDER_ = "flexlayout__tab_border_",
    FLEXLAYOUT__TAB_BUTTON = "flexlayout__tab_button",
    FLEXLAYOUT__TAB_BUTTON_STRETCH = "flexlayout__tab_button_stretch",
    FLEXLAYOUT__TAB_BUTTON_CONTENT = "flexlayout__tab_button_content",
    FLEXLAYOUT__TAB_BUTTON_LEADING = "flexlayout__tab_button_leading",
    FLEXLAYOUT__TAB_BUTTON_OVERFLOW = "flexlayout__tab_button_overflow",
    FLEXLAYOUT__TAB_BUTTON_OVERFLOW_COUNT = "flexlayout__tab_button_overflow_count",
    FLEXLAYOUT__TAB_BUTTON_TEXTBOX = "flexlayout__tab_button_textbox",
    FLEXLAYOUT__TAB_BUTTON_TRAILING = "flexlayout__tab_button_trailing",
    FLEXLAYOUT__TAB_BUTTON_STAMP = "flexlayout__tab_button_stamp",

    FLEXLAYOUT__TAB_TOOLBAR = "flexlayout__tab_toolbar",
    FLEXLAYOUT__TAB_TOOLBAR_BUTTON = "flexlayout__tab_toolbar_button",
    FLEXLAYOUT__TAB_TOOLBAR_ICON = "flexlayout__tab_toolbar_icon",
    FLEXLAYOUT__TAB_TOOLBAR_BUTTON_ = "flexlayout__tab_toolbar_button-",
    FLEXLAYOUT__TAB_TOOLBAR_BUTTON_FLOAT = "flexlayout__tab_toolbar_button-float",
    FLEXLAYOUT__TAB_TOOLBAR_STICKY_BUTTONS_CONTAINER = "flexlayout__tab_toolbar_sticky_buttons_container",
    FLEXLAYOUT__TAB_TOOLBAR_BUTTON_CLOSE = "flexlayout__tab_toolbar_button-close",

    FLEXLAYOUT__POPUP_MENU_CONTAINER = "flexlayout__popup_menu_container",
    FLEXLAYOUT__POPUP_MENU_ITEM = "flexlayout__popup_menu_item",
    FLEXLAYOUT__POPUP_MENU_ITEM__SELECTED = "flexlayout__popup_menu_item--selected",
    FLEXLAYOUT__POPUP_MENU = "flexlayout__popup_menu",

    FLEXLAYOUT__MINI_SCROLLBAR = "flexlayout__mini_scrollbar",
    FLEXLAYOUT__MINI_SCROLLBAR_CONTAINER = "flexlayout__mini_scrollbar_container",
}

```

## File: src/DropInfo.ts

```typescript
import { DockLocation } from "./DockLocation";
import { IDropTarget } from "./model/IDropTarget";
import { Node } from "./model/Node";
import { Rect } from "./Rect";

export class DropInfo {
    node: Node & IDropTarget;
    rect: Rect;
    location: DockLocation;
    index: number;
    className: string;

    constructor(node: Node & IDropTarget, rect: Rect, location: DockLocation, index: number, className: string) {
        this.node = node;
        this.rect = rect;
        this.location = location;
        this.index = index;
        this.className = className;
    }
}

```

## File: src/AttributeDefinitions.ts

```typescript
import { Attribute } from "./Attribute";

/** @internal */
export class AttributeDefinitions {
    attributes: Attribute[];
    nameToAttribute: Map<string, Attribute>;

    constructor() {
        this.attributes = [];
        this.nameToAttribute = new Map();
    }

    addWithAll(name: string, modelName: string | undefined, defaultValue: any, alwaysWriteJson?: boolean) {
        const attr = new Attribute(name, modelName, defaultValue, alwaysWriteJson);
        this.attributes.push(attr);
        this.nameToAttribute.set(name, attr);
        return attr;
    }

    addInherited(name: string, modelName: string) {
        return this.addWithAll(name, modelName, undefined, false);
    }

    add(name: string, defaultValue: any, alwaysWriteJson?: boolean) {
        return this.addWithAll(name, undefined, defaultValue, alwaysWriteJson);
    }

    getAttributes() {
        return this.attributes;
    }

    getModelName(name: string) {
        const conversion = this.nameToAttribute.get(name);
        if (conversion !== undefined) {
            return conversion.modelName;
        }
        return undefined;
    }

    toJson(jsonObj: any, obj: any) {
        for (const attr of this.attributes) {
            const fromValue = obj[attr.name];
            if (attr.alwaysWriteJson || fromValue !== attr.defaultValue) {
                jsonObj[attr.name] = fromValue;
            }
        }
    }

    fromJson(jsonObj: any, obj: any) {
        for (const attr of this.attributes) {
            let fromValue = jsonObj[attr.name];
            if (fromValue === undefined && attr.alias) {
                fromValue = jsonObj[attr.alias];
            }
            if (fromValue === undefined) {
                obj[attr.name] = attr.defaultValue;
            } else {
                obj[attr.name] = fromValue;
            }
        }
    }

    update(jsonObj: any, obj: any) {
        for (const attr of this.attributes) {
            if (jsonObj.hasOwnProperty(attr.name)) {
                const fromValue = jsonObj[attr.name];
                if (fromValue === undefined) {
                    delete obj[attr.name];
                } else {
                    obj[attr.name] = fromValue;
                }
            }
        }
    }

    setDefaults(obj: any) {
        for (const attr of this.attributes) {
            obj[attr.name] = attr.defaultValue;
        }
    }

    pairAttributes(type: string, childAttributes: AttributeDefinitions) {
        for (const attr of childAttributes.attributes) {
            if (attr.modelName && this.nameToAttribute.has(attr.modelName)) {
                const pairedAttr = this.nameToAttribute.get(attr.modelName)!;
                pairedAttr.setpairedAttr(attr);
                attr.setpairedAttr(pairedAttr);
                pairedAttr.setPairedType(type);
            }
        }
    }

    toTypescriptInterface(name: string, parentAttributes: AttributeDefinitions | undefined) {
        const lines = [];
        const sorted = this.attributes.sort((a, b) => a.name.localeCompare(b.name));
        // const sorted = this.attributes;
        lines.push("export interface I" + name + "Attributes {");
        for (let i = 0; i < sorted.length; i++) {
            const c = sorted[i]!;
            let type = c.type;
            let defaultValue = undefined;

            let attr = c;
            let inherited = undefined;
            if (attr.defaultValue !== undefined) {
                defaultValue = attr.defaultValue;
            } else if (attr.modelName !== undefined
                && parentAttributes !== undefined
                && parentAttributes.nameToAttribute.get(attr.modelName) !== undefined) {
                inherited = attr.modelName;
                attr = parentAttributes.nameToAttribute.get(inherited)!;
                defaultValue = attr.defaultValue;
                type = attr.type;
            }

            let defValue = JSON.stringify(defaultValue);

            const required = attr.required ? "" : "?";

            let sb = "\t/**\n\t  ";
            if (c.description) {
                sb += c.description;
            } else if (c.pairedType && c.pairedAttr?.description) {
                sb += `Value for ${c.pairedType} attribute ${c.pairedAttr.name} if not overridden`
                sb += "\n\n\t  ";
                sb += c.pairedAttr?.description;
            }
            sb += "\n\n\t  ";
            if (c.fixed) {
                sb += `Fixed value: ${defValue}`;
            } else if (inherited) {
                sb += `Default: inherited from Global attribute ${c.modelName} (default ${defValue})`;
            } else {
                sb += `Default: ${defValue}`;
            }
            sb += "\n\t */";
            lines.push(sb);
            lines.push("\t" + c.name + required + ": " + type + ";\n");
        }
        lines.push("}");

        return lines.join("\n");
    }
}

```

## File: src/style.css

```css
/* === Base FlexLayout Styles (Adapted from gray.css) === */

.flexlayout__layout {
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  position: absolute;
  display: flex;
  /* Define font defaults using global variables */
  font-size: var(
    --font-size,
    medium
  ); /* Fallback if --font-size isn't globally set */
  font-family: var(--font-sans);
  color: var(--foreground);
  background-color: var(--background);
}

.flexlayout__layout
  .flexlayout__tabset_container:first-child
  .flexlayout__tabset_tabbar_inner_tab_container {
  padding-left: 40px;
  gap: 1px;
}

.flexlayout__layout_overlay {
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  position: absolute;
  z-index: 1000;
  background-color: oklch(from var(--primary) l c h / 0.05);
}

.flexlayout__layout_tab_stamps {
  position: absolute;
  top: -10000px;
  z-index: 100;
  display: flex;
  flex-direction: column;
  align-items: start;
}

.flexlayout__layout_moveables {
  visibility: hidden;
  position: absolute;
  width: 100px;
  height: 100px;
  top: -20000px;
}

.flexlayout__layout_main {
  display: flex;
  flex-basis: 0px;
  min-width: 0;
  min-height: 0;
  flex-grow: 1;
  position: relative;
}

.flexlayout__layout_border_container {
  display: flex;
  flex-basis: 0px;
  min-width: 0;
  min-height: 0;
  flex-grow: 1;
}

.flexlayout__layout_border_container_inner {
  display: flex;
  flex-basis: 0px;
  min-width: 0;
  min-height: 0;
  flex-grow: 1;
}

/* Default splitter styles - overridden later by custom styles */
.flexlayout__splitter {
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: var(--border); /* Default to border color */
  touch-action: none;
  z-index: 10;
}

/* Default hover - overridden later */
.flexlayout__splitter:hover {
  transition: background-color ease-in 0.1s;
  background-color: var(--muted); /* Default hover */
}

.flexlayout__splitter_horz {
  height: 100%;
  width: 2px !important;
  min-width: 2px !important;
}

.flexlayout__splitter_vert {
  width: 100% !important;
  height: 2px !important;
  min-height: 2px !important;
}

/* CHANGE 1: Splitter Drag Style - Faded look */
.flexlayout__splitter_drag {
  position: absolute;
  z-index: 1000;
  /* Faded look using accent color with low alpha */
  background-color: oklch(from var(--border) l c h);
  /* Remove flex centering */
  /* display: flex; */
  /* align-items: center; */
  /* justify-content: center; */
}
.dark .flexlayout__splitter_drag {
  /* Slightly more visible in dark mode */
  background-color: oklch(from var(--accent) l c h / 0.25);
}

/* Splitter handle styling (optional, can be customized) */
.flexlayout__splitter_handle {
  background-color: var(--muted-foreground);
  border-radius: 3px;
}

.flexlayout__splitter_handle_horz {
  width: 3px;
  height: 30px;
}

.flexlayout__splitter_handle_vert {
  width: 100%;
  height: 3px;
}

.flexlayout__splitter_extra {
  touch-action: none;
  background-color: transparent;
}

/* Drag/drop outline styles */
.flexlayout__outline_rect {
  position: absolute;
  pointer-events: none;
  box-sizing: border-box;
  border: 2px solid var(--primary); /* Use primary color */
  background: oklch(
    from var(--primary) l c h / 0.1
  ); /* Use primary with low alpha */
  border-radius: var(--radius-sm); /* Use smaller radius */
  z-index: 1000;
}

.flexlayout__outline_rect_edge {
  pointer-events: none;
  border: 2px solid var(--secondary); /* Use secondary color */
  background: oklch(
    from var(--secondary) l c h / 0.1
  ); /* Use secondary with low alpha */
  border-radius: var(--radius-sm);
  z-index: 1000;
  box-sizing: border-box;
}

.flexlayout__drag_rect {
  color: var(--accent-foreground);
  background-color: var(--accent);
  border: 2px solid var(--border);
  border-radius: var(--radius-sm);
  box-sizing: border-box;
  display: flex;
  justify-content: center;
  flex-direction: column;
  overflow: hidden;
  padding: 0.3em 0.8em;
  word-wrap: break-word;
  /* Inherit font from layout */
  font-size: inherit;
  font-family: inherit;
}

/* Row styles - overridden by custom styles later */
.flexlayout__row {
  display: flex;
  flex-basis: 0px;
  min-width: 0;
  min-height: 0;
  position: relative;
  box-sizing: border-box;
  overflow: hidden;
  /* Default gap - overridden later */
  /* gap: 0.5rem; */
  background-color: var(--background); /* Default */
}

/* TabSet styles - Base structure, colors overridden later */
.flexlayout__tabset {
  display: flex;
  flex-direction: column;
  position: relative;
  background-color: var(--background); /* Default, overridden by custom */
  color: var(--foreground);
  box-sizing: border-box;
  font-family: inherit;
  overflow: hidden;
  flex-grow: 1;
}

.flexlayout__tabset_container {
  display: flex;
  flex-basis: 0px;
  min-width: 0;
  min-height: 0;
  flex-direction: column;
  overflow: hidden;
  flex-grow: 1;
  /* Default padding/background - overridden later */
  /* padding: 0; */
  background-color: var(--background); /* Default */
}

.flexlayout__tabset_tab_divider {
  width: 0px;
  padding: 0px;
}

/* Tab Content Area - Background overridden later */
.flexlayout__tabset_content {
  display: flex;
  flex-basis: 0px;
  min-width: 0;
  min-height: 0;
  flex-grow: 1;
  box-sizing: border-box;
  position: relative;
  /* Default background - overridden later */
  background-color: var(--background);
}

.flexlayout__tabset_header {
  display: flex;
  align-items: center;
  padding: 3px 3px 3px 5px; /* Default padding */
  box-sizing: border-box;
  border-bottom: 1px solid var(--border);
  color: var(--muted-foreground); /* Header text usually muted */
  background-color: var(--muted); /* Header background muted */
  font-size: inherit;
}

.flexlayout__tabset_header_content {
  flex-grow: 1;
}

/* Tab Bar - Structure, background/border overridden later */
.flexlayout__tabset_tabbar_outer {
  box-sizing: border-box;
  background-color: var(--background); /* Default, overridden later */
  overflow: hidden;
  display: flex;
  font-size: inherit;
}

/* CHANGE 3: Adjust Tab Bar Outer for Toolbar positioning */
.flexlayout__tabset_tabbar_outer_top {
  height: 38px; /* Match button height + border */
  border-bottom: 1px solid var(--border); /* Use standard border */
  background-color: var(--sidebar) !important; /* Use sidebar bg for tab bar */
}

.flexlayout__tabset_tabbar_outer_bottom {
  padding: 0px 2px 0px 2px;
  border-top: 1px solid var(--border);
}

/* CHANGE 3: Ensure Inner Tab Bar allows Toolbar at end */
.flexlayout__tabset_tabbar_inner {
  position: relative;
  box-sizing: border-box;
  display: flex;
  flex-grow: 1; /* Takes up available space before toolbar */
  overflow: hidden; /* Handles tab overflow */
}

/* Tab Container - Padding overridden later */
.flexlayout__tabset_tabbar_inner_tab_container {
  position: relative;
  display: flex;
  /* Default padding - overridden later */
  padding-left: 4px;
  padding-right: 4px;
  box-sizing: border-box;
  white-space: nowrap;
}

.flexlayout__tabset_tabbar_inner_tab_container_top {
  border-top: 2px solid transparent; /* Keep for structure */
}

.flexlayout__tabset_tabbar_inner_tab_container_bottom {
  border-bottom: 2px solid transparent; /* Keep for structure */
}

/* Tab Stamp (used for measuring) */
.flexlayout__tab_button_stamp {
  display: inline-flex;
  align-items: center;
  gap: 0.3em;
  white-space: nowrap;
  box-sizing: border-box;
}

/* Individual Tab Content Area - Background/color overridden later */
.flexlayout__tab {
  overflow: hidden;
  box-sizing: border-box;
  background-color: var(--background); /* Default */
  color: var(--foreground); /* Default */
  position: relative;
  flex-grow: 1; /* Ensure tab content fills space */
  display: flex; /* Needed for inner content */
  flex-direction: column; /* Needed for inner content */
}

.flexlayout__tab_moveable {
  position: relative;
  height: 100%;
  min-width: 1px;
  min-height: 1px;
  overflow: auto;
  box-sizing: border-box;
}

.flexlayout__tab_overlay {
  z-index: 20;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: oklch(0 0 0 / 0.25); /* Semi-transparent black */
}

/* Tab Button Base - Structure, appearance overridden later */
.flexlayout__tab_button {
  display: flex;
  gap: 0.3em;
  align-items: center;
  box-sizing: border-box;
  /* padding: 3px 0.5em; */ /* Default padding - overridden later */
  cursor: pointer;
}

/* Stretch button (used in borders) */
.flexlayout__tab_button_stretch {
  background-color: transparent;
  color: var(--foreground); /* Default */
  width: 100%;
  padding: 3px 0em;
  text-wrap: nowrap;
  display: flex;
  gap: 0.3em;
  align-items: center;
  box-sizing: border-box;
  cursor: pointer;
}
@media (hover: hover) {
  .flexlayout__tab_button_stretch:hover {
    color: var(--primary); /* Hover effect */
  }
}

.flexlayout__tab_button_leading {
  display: flex;
}

.flexlayout__tab_button_content {
  display: flex;
  text-wrap: nowrap;
  overflow: hidden; /* Prevent content overflow */
  text-overflow: ellipsis; /* Add ellipsis if content too long */
}

/* Tab Rename Textbox */
.flexlayout__tab_button_textbox {
  border: 1px solid var(--input);
  font-family: inherit;
  font-size: inherit;
  color: var(--foreground);
  background-color: var(--background);
  border-radius: var(--radius-sm);
  width: 10em;
  padding: 2px 4px;
}
.flexlayout__tab_button_textbox:focus {
  outline: 2px solid var(--ring);
  outline-offset: 1px;
  border-color: var(--primary); /* Indicate focus on border too */
}

/* Close Button / Trailing Icons Container */
.flexlayout__tab_button_trailing {
  display: flex;
  visibility: hidden; /* Hidden by default */
  border-radius: var(--radius-sm);
  margin-left: 0.5em; /* Space from content */
  color: var(--muted-foreground);
}
.flexlayout__tab_button_trailing:hover {
  background-color: oklch(from var(--muted) l c h / 0.5); /* Subtle hover */
  color: var(--foreground); /* Make icon clearer on hover */
}
/* Show on tab hover */
@media (hover: hover) {
  .flexlayout__tab_button:hover .flexlayout__tab_button_trailing {
    visibility: visible;
  }
}
/* Always show on selected tab */
.flexlayout__tab_button--selected .flexlayout__tab_button_trailing {
  visibility: visible;
}

/* Overflow Menu Button */
.flexlayout__tab_button_overflow {
  display: flex;
  align-items: center;
  border: none;
  color: var(--muted-foreground);
  font-size: inherit;
  background-color: transparent;
  padding: 2px;
  margin-left: 4px;
  border-radius: var(--radius-sm);
  flex-shrink: 0; /* Prevent shrinking */
}
.flexlayout__tab_button_overflow:hover {
  background-color: oklch(from var(--muted) l c h / 0.5);
  color: var(--foreground);
}

.flexlayout__tab_toolbar {
  display: flex;
  align-items: center;
  gap: 0.3em;
  padding-left: 0.5em;
  flex-shrink: 0;
}

/* Icons/Buttons within Toolbar */
.flexlayout__tab_toolbar_icon,
.flexlayout__tab_toolbar_button {
  border: none;
  outline: none;
  font-size: inherit;
  margin: 0px;
  background-color: transparent;
  border-radius: var(--radius-sm);
  padding: 2px;
  color: var(--muted-foreground);
  display: inline-flex; /* Helps alignment */
  align-items: center; /* Helps alignment */
  justify-content: center; /* Helps alignment */
}

@media (hover: hover) {
  .flexlayout__tab_toolbar_button:hover {
    background-color: oklch(from var(--muted) l c h / 0.5);
    color: var(--foreground);
  }
}

.flexlayout__tab_toolbar_sticky_buttons_container {
  display: flex;
  gap: 0.3em;
  padding-left: 5px;
  align-items: center;
}

/* Floating Tab Placeholder */
.flexlayout__tab_floating {
  overflow: auto;
  position: absolute;
  box-sizing: border-box;
  color: var(--foreground);
  background-color: var(--background);
  display: flex;
  justify-content: center;
  align-items: center;
  border: 1px dashed var(--border);
  border-radius: var(--radius);
}
.flexlayout__tab_floating_inner {
  overflow: auto;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  padding: 1em;
}
.flexlayout__tab_floating_inner div {
  margin-bottom: 5px;
  text-align: center;
}
.flexlayout__tab_floating_inner div a {
  color: var(--primary);
}

/* Border Styles (Base Structure) */
.flexlayout__border {
  box-sizing: border-box;
  overflow: hidden;
  display: flex;
  font-size: inherit;
  font-family: inherit;
  color: var(--sidebar-foreground); /* Use sidebar colors for borders */
  background-color: var(--sidebar);
}

/* Border Content Area */
.flexlayout__border_tab_contents {
  box-sizing: border-box;
  overflow: hidden;
  background-color: var(--background); /* Content area uses main background */
  flex-grow: 1; /* Allow content to fill space */
}

/* Border Layouts */
.flexlayout__border_top {
  border-bottom: 1px solid var(--sidebar-border);
  align-items: center;
}
.flexlayout__border_bottom {
  border-top: 1px solid var(--sidebar-border);
  align-items: center;
}
.flexlayout__border_left {
  border-right: 1px solid var(--sidebar-border);
  align-content: center;
  flex-direction: column;
}
.flexlayout__border_right {
  border-left: 1px solid var(--sidebar-border);
  align-content: center;
  flex-direction: column;
}

.flexlayout__border_inner {
  position: relative;
  box-sizing: border-box;
  display: flex;
  overflow: hidden;
  flex-grow: 1;
}

.flexlayout__border_inner_tab_container {
  white-space: nowrap;
  display: flex;
  padding-left: 2px;
  padding-right: 2px;
  box-sizing: border-box;
  position: absolute;
  width: 10000px; /* For rotation trick */
}
.flexlayout__border_inner_tab_container_right {
  transform-origin: top left;
  transform: rotate(90deg);
}
.flexlayout__border_inner_tab_container_left {
  flex-direction: row-reverse;
  transform-origin: top right;
  transform: rotate(-90deg);
}

.flexlayout__border_tab_divider {
  width: 4px;
}

/* Border Tab Button */
.flexlayout__border_button {
  display: flex;
  gap: 0.3em;
  align-items: center;
  cursor: pointer;
  padding: 3px 0.5em;
  margin: 2px 0px;
  box-sizing: border-box;
  white-space: nowrap;
  border-radius: var(--radius-sm);
  color: var(--sidebar-foreground);
  background-color: transparent; /* Default */
}

.flexlayout__border_button--selected {
  background-color: var(--sidebar-accent);
  color: var(--sidebar-accent-foreground);
}
@media (hover: hover) {
  .flexlayout__border_button:hover {
    background-color: var(--sidebar-accent);
    color: var(--sidebar-accent-foreground);
  }
}
/* .flexlayout__border_button--unselected - Default state is handled by base .flexlayout__border_button */

.flexlayout__border_button_leading {
  display: flex;
}
.flexlayout__border_button_content {
  display: flex;
}

.flexlayout__border_button_trailing {
  display: flex;
  border-radius: var(--radius-sm);
  visibility: hidden; /* Hide by default */
  margin-left: 0.5em;
}
.flexlayout__border_button_trailing:hover {
  background-color: oklch(
    from var(--sidebar-primary) l c h / 0.2
  ); /* Subtle hover */
}
@media (hover: hover) {
  .flexlayout__border_button:hover .flexlayout__border_button_trailing {
    visibility: visible;
  }
}
.flexlayout__border_button--selected .flexlayout__border_button_trailing {
  visibility: visible;
}

/* Border Toolbar */
.flexlayout__border_toolbar {
  display: flex;
  gap: 0.3em;
  align-items: center;
}
.flexlayout__border_toolbar_left,
.flexlayout__border_toolbar_right {
  flex-direction: column;
  padding-top: 0.5em;
  padding-bottom: 0.3em;
}
.flexlayout__border_toolbar_top,
.flexlayout__border_toolbar_bottom {
  padding-left: 0.5em;
  padding-right: 0.3em;
}

.flexlayout__border_toolbar_button {
  border: none;
  outline: none;
  font-size: inherit;
  background-color: transparent;
  border-radius: var(--radius-sm);
  padding: 1px;
  color: var(--sidebar-foreground);
}
@media (hover: hover) {
  .flexlayout__border_toolbar_button:hover {
    background-color: oklch(from var(--sidebar-primary) l c h / 0.2);
    color: var(
      --sidebar-primary-foreground
    ); /* Assuming primary button on sidebar */
  }
}

.flexlayout__border_toolbar_button_overflow {
  display: flex;
  align-items: center;
  border: none;
  color: var(--sidebar-foreground); /* Use sidebar color */
  font-size: inherit;
  background-color: transparent;
}

/* Popup Menu Styles */
.flexlayout__popup_menu {
  font-size: inherit;
  font-family: inherit;
}

.flexlayout__popup_menu_item {
  padding: 4px 0.75em; /* Slightly more padding */
  white-space: nowrap;
  cursor: pointer;
  border-radius: var(--radius-sm);
  color: var(--popover-foreground);
}
@media (hover: hover) {
  .flexlayout__popup_menu_item:hover {
    background-color: var(--accent);
    color: var(--accent-foreground);
  }
}

.flexlayout__popup_menu_container {
  box-shadow:
    0 4px 6px -1px rgb(0 0 0 / 0.1),
    0 2px 4px -2px rgb(0 0 0 / 0.1); /* Popover shadow */
  border: 1px solid var(--border);
  color: var(--popover-foreground);
  background: var(--popover);
  border-radius: var(--radius-md);
  position: absolute;
  z-index: 1000;
  max-height: 50%;
  min-width: 150px; /* Slightly wider */
  overflow: auto;
  padding: 4px; /* Small padding around items */
}

/* Floating Window Styles */
/* These might need body styles in the popped-out window's HTML */
.flexlayout__floating_window_content {
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  position: absolute;
}

/* Error Boundary Styles */
.flexlayout__error_boundary_container {
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  position: absolute;
  display: flex;
  justify-content: center;
  align-items: center; /* Center content */
  padding: 1em;
  background-color: var(--destructive);
  color: var(--destructive-foreground);
  border-radius: var(--radius);
}
.flexlayout__error_boundary_content {
  display: flex;
  align-items: center;
  text-align: center;
  flex-direction: column; /* Stack icon and text */
  gap: 0.5em;
}

/* Sizer elements (used for calculations, should be invisible) */
.flexlayout__tabset_sizer,
.flexlayout__tabset_header_sizer,
.flexlayout__border_sizer {
  position: absolute;
  top: -30000px; /* Position offscreen */
  visibility: hidden; /* Hide */
  pointer-events: none; /* Ignore clicks */
  font-size: inherit;
  font-family: inherit;
  padding: 0;
  margin: 0; /* Reset */
}

/* === Custom Overrides and Theming === */

/* Splitter styles */
.flexlayout__splitter {
  min-width: 2px !important;
  background-color: var(--sidebar-border); /* Match sidebar border */
  transition: background-color 0.1s ease-in;
}

.flexlayout__splitter:hover {
  background-color: var(--border); /* Use main border color on hover */
}

/* Tabset base styles */
.flexlayout__tabset {
  background-color: var(--background); /* Use main background */
  color: var(--foreground);
}

/* Reset padding for subsequent/nested tabsets */
.flexlayout__tabset_tabbar_inner_tab_container {
  padding-left: 4px; /* Minimal padding for others */
}

/* Tab Button base styles */
.flexlayout__tab_button {
  position: relative; /* Needed for z-index */
  z-index: 2; /* Below selected tab */
  min-width: 100px;
  max-width: 200px; /* Prevent tabs getting too wide */
  display: flex;
  justify-content: space-between; /* Pushes close button to the end */
  align-items: center;
  padding: 6px 10px; /* Vertical and horizontal padding */
  border: 1px solid transparent; /* Add transparent border for size consistency */
  border-bottom: none;
  /* Use medium radius for top corners of unselected tabs */
  border-top-left-radius: var(--radius-md);
  border-top-right-radius: var(--radius-md);
  transition:
    background-color 0.2s,
    color 0.2s,
    border-color 0.2s;
  color: var(--muted-foreground); /* Unselected tabs are muted */
  background-color: transparent; /* Unselected tabs are transparent */
}

/* Unselected Tab specific adjustments */
.flexlayout__tab_button--unselected {
  /* Ensure consistent padding with selected */
  padding-bottom: 6px;
}

/* Tab Button Hover */
.flexlayout__tab_button:hover {
  /* On hover, preview the accent state */
  background-color: var(--accent);
  color: var(--accent-foreground);
  border-color: var(--border); /* Show border on hover */
  z-index: 3; /* Bring hover slightly forward */
  margin-bottom: -1px; /* Ensure it aligns like selected */
  /* Match selected radius on hover */
  border-top-left-radius: var(--radius);
  border-top-right-radius: var(--radius);
}

/* CHANGE 2: Selected Tab with Borders and Radius */
.flexlayout__tab_button--selected {
  background-color: var(--background); /* Selected tab matches content bg */
  color: var(--foreground); /* Use standard text color */
  font-weight: 500; /* Make selected tab text slightly bolder */
  z-index: 4; /* Above hover and unselected tabs */
  padding-bottom: 6px; /* Match base padding, border adds height */
  /* Use main radius for top corners */
  border-top-left-radius: var(--radius);
  border-top-right-radius: var(--radius);
  /* Add borders */
  border: 1px solid var(--border);
  border-bottom: none; /* No bottom border, sits on tab bar */
  /* Ensure it sits correctly relative to the tab bar */
  margin-bottom: -1px; /* Overlap the tab bar's bottom border */
}

/* REMOVED: Curve pseudo-elements are replaced by borders */
/* .flexlayout__tab_button--selected::before, */
/* .flexlayout__tab_button--selected::after { ... } */

/* Tab Content Area */
.flexlayout__tab_content {
  background-color: var(
    --background
  ); /* Ensure content area uses main background */
  /* Bottom corners rounded, top corners are square to meet tab */
  border-radius: 0 0 var(--radius) var(--radius);
  overflow: hidden; /* Clip content */
  padding: 1rem; /* Example padding */
  border: 1px solid var(--border); /* Add border around content */
  border-top: none; /* Top border is visually provided by the selected tab */
  position: relative;
  z-index: 1; /* Below tabs */
  margin-top: 0; /* Align directly below tab bar bottom border */
}

/* Ensure tabset container uses sidebar background */
.flexlayout__tabset_container {
  background-color: var(--sidebar); /* Should match tab bar bg */
  padding: 0;
}

/* Style rows if they are direct children of layout */
.flexlayout__layout > .flexlayout__row {
  background-color: var(--sidebar); /* Rows use sidebar color */
  gap: 0.5rem; /* Gap between components in a row */
}

/* === Dark Mode Overrides === */

.dark .flexlayout__splitter {
  background-color: var(--sidebar-border); /* Use dark sidebar border */
}

.dark .flexlayout__splitter:hover {
  background-color: var(--border); /* Use dark main border */
}

.dark .flexlayout__tabset,
.dark .flexlayout__tab {
  background-color: var(--background); /* Use dark background */
  color: var(--foreground); /* Use dark foreground */
}

/* Ensure tab bar bg is correct */
.dark .flexlayout__tabset_tabbar_outer_top {
  background-color: var(--sidebar) !important; /* Dark sidebar bg */
  border-bottom-color: var(--border); /* Dark border */
}

/* Selected tab in dark mode */
.dark .flexlayout__tab_button--selected {
  background-color: var(--background); /* Dark background */
  color: var(--foreground); /* Dark foreground */
  border-color: var(--border); /* Use dark border */
}

/* Tab hover in dark mode */
.dark .flexlayout__tab_button:hover {
  background-color: var(--accent); /* Dark accent */
  color: var(--accent-foreground); /* Dark accent foreground */
  border-color: var(--border); /* Use dark border */
}

/* Unselected tab text color in dark mode */
.dark .flexlayout__tab_button {
  color: var(--muted-foreground); /* Dark muted foreground */
  border-color: transparent; /* Ensure transparent border */
}

/* REMOVED: Dark mode Curve pseudo-elements */
/* .dark .flexlayout__tab_button--selected::before { ... } */
/* .dark .flexlayout__tab_button--selected::after { ... } */

/* Content area in dark mode */
.dark .flexlayout__tab_content {
  background-color: var(--background); /* Dark background */
  border-color: var(--border); /* Dark border */
}

/* Tabset container dark mode */
.dark .flexlayout__tabset_container {
  background-color: var(--sidebar); /* Dark sidebar */
}

/* Rows dark mode */
.dark .flexlayout__layout > .flexlayout__row {
  background-color: var(--sidebar); /* Dark sidebar */
}

/* Border components dark mode */
.dark .flexlayout__border {
  color: var(--sidebar-foreground);
  background-color: var(--sidebar);
}
.dark .flexlayout__border_top {
  border-bottom-color: var(--sidebar-border);
}
.dark .flexlayout__border_bottom {
  border-top-color: var(--sidebar-border);
}
.dark .flexlayout__border_left {
  border-right-color: var(--sidebar-border);
}
.dark .flexlayout__border_right {
  border-left-color: var(--sidebar-border);
}

.dark .flexlayout__border_tab_contents {
  background-color: var(--background);
}

.dark .flexlayout__border_button {
  color: var(--sidebar-foreground);
}
.dark .flexlayout__border_button--selected {
  background-color: var(--sidebar-accent);
  color: var(--sidebar-accent-foreground);
}
.dark .flexlayout__border_button:hover {
  background-color: var(--sidebar-accent);
  color: var(--sidebar-accent-foreground);
}

.dark .flexlayout__border_toolbar_button {
  color: var(--sidebar-foreground);
}
.dark .flexlayout__border_toolbar_button:hover {
  background-color: oklch(from var(--sidebar-primary) l c h / 0.2);
  color: var(--sidebar-primary-foreground);
}
.dark .flexlayout__border_toolbar_button_overflow {
  color: var(--sidebar-foreground);
}

/* Popups dark mode */
.dark .flexlayout__popup_menu_item {
  color: var(--popover-foreground);
}
.dark .flexlayout__popup_menu_item:hover {
  background-color: var(--accent);
  color: var(--accent-foreground);
}
.dark .flexlayout__popup_menu_container {
  background: var(--popover);
  color: var(--popover-foreground);
  border-color: var(--border);
}

```

## File: src/index.ts

```typescript
export * from './view/Layout';

export * from './model/Action';
export * from './model/Actions';
export * from './model/BorderNode';
export * from './model/BorderSet';
export * from './model/ICloseType';
export * from './model/IDraggable';
export * from './model/IDropTarget';
export * from './model/IJsonModel';
export * from './model/Model';
export * from './model/Node';
export * from './model/RowNode';
export * from './model/TabNode';
export * from './model/TabSetNode';
export * from './model/LayoutWindow';

export * from './DockLocation';
export * from './DropInfo';
export * from './I18nLabel';
export * from './Orientation';
export * from './Rect';
export * from './Types';

```

## File: src/Orientation.ts

```typescript
export class Orientation {
    static HORZ = new Orientation("horz");
    static VERT = new Orientation("vert");

    static flip(from: Orientation) {
        if (from === Orientation.HORZ) {
            return Orientation.VERT;
        } else {
            return Orientation.HORZ;
        }
    }

    /** @internal */
    private _name: string;

    /** @internal */
    private constructor(name: string) {
        this._name = name;
    }

    getName() {
        return this._name;
    }

    toString() {
        return this._name;
    }
}

```

## File: src/Attribute.ts

```typescript
/** @internal */
export class Attribute {
    static NUMBER = "number";
    static STRING = "string";
    static BOOLEAN = "boolean";

    name: string;
    alias: string | undefined;
    modelName?: string;
    pairedAttr?: Attribute;
    pairedType?: string;
    defaultValue: any;
    alwaysWriteJson?: boolean;
    type?: string; 
    required: boolean;
    fixed: boolean;
    description?: string;

    constructor(name: string, modelName: string | undefined, defaultValue: any, alwaysWriteJson?: boolean) {
        this.name = name;
        this.alias = undefined;
        this.modelName = modelName;
        this.defaultValue = defaultValue;
        this.alwaysWriteJson = alwaysWriteJson;
        this.required = false;
        this.fixed = false;

        this.type = "any";
    }

    setType(value: string) {
        this.type = value;
        return this;
    }

    setAlias(value: string) {
        this.alias = value;
        return this;
    }

    setDescription(value: string) {
        this.description = value;
    }

    setRequired() {
        this.required = true;
        return this;
    }

    setFixed() {
        this.fixed = true;
        return this;
    }

    // sets modelAttr for nodes, and nodeAttr for model
    setpairedAttr(value: Attribute) {
        this.pairedAttr = value;
    }

    setPairedType(value: string) {
        this.pairedType = value;
    }

}

```

## File: src/model/TabNode.ts

```typescript
import { Attribute } from "../Attribute";
import { AttributeDefinitions } from "../AttributeDefinitions";
import { Rect } from "../Rect";
import { BorderNode } from "./BorderNode";
import { IDraggable } from "./IDraggable";
import { IJsonTabNode } from "./IJsonModel";
import { Model } from "./Model";
import { Node } from "./Node";
import { TabSetNode } from "./TabSetNode";

export class TabNode extends Node implements IDraggable {
    static readonly TYPE = "tab";

    /** @internal */
    static fromJson(json: any, model: Model, addToModel: boolean = true) {
        const newLayoutNode = new TabNode(model, json, addToModel);
        return newLayoutNode;
    }

    /** @internal */
    private tabRect: Rect = Rect.empty();
    /** @internal */
    private moveableElement: HTMLElement | null;
    /** @internal */
    private tabStamp: HTMLElement | null;
    /** @internal */
    private renderedName?: string;
    /** @internal */
    private extra: Record<string, any>;
    /** @internal */
    private visible: boolean;
    /** @internal */
    private rendered: boolean;
    /** @internal */
    private scrollTop?: number;
    /** @internal */
    private scrollLeft?: number;

    /** @internal */
    constructor(model: Model, json: any, addToModel: boolean = true) {
        super(model);

        this.extra = {}; // extra data added to node not saved in json
        this.moveableElement = null;
        this.tabStamp = null;
        this.rendered = false;
        this.visible = false;

        TabNode.attributeDefinitions.fromJson(json, this.attributes);
        if (addToModel === true) {
            model.addNode(this);
        }
    }

    getName() {
        return this.getAttr("name") as string;
    }

    getHelpText() {
        return this.getAttr("helpText") as string | undefined;
    }

    getComponent() {
        return this.getAttr("component") as string | undefined;
    }

    getWindowId() {
        if (this.parent instanceof TabSetNode) {
            return this.parent.getWindowId();
        }
        return Model.MAIN_WINDOW_ID;
    }

    getWindow() : Window | undefined {
        const layoutWindow = this.model.getwindowsMap().get(this.getWindowId());
        if (layoutWindow) {
            return layoutWindow.window;
        }
        return undefined;
    }

    /**
     * Returns the config attribute that can be used to store node specific data that
     * WILL be saved to the json. The config attribute should be changed via the action Actions.updateNodeAttributes rather
     * than directly, for example:
     * this.state.model.doAction(
     *   FlexLayout.Actions.updateNodeAttributes(node.getId(), {config:myConfigObject}));
     */
    getConfig() {
        return this.attributes.config;
    }

    /**
     * Returns an object that can be used to store transient node specific data that will
     * NOT be saved in the json.
     */
    getExtraData() {
        return this.extra;
    }

    isPoppedOut() {
        return this.getWindowId() !== Model.MAIN_WINDOW_ID;
    }

    isSelected() {
        return (this.getParent() as TabSetNode | BorderNode).getSelectedNode() === this;
    }

    getIcon() {
        return this.getAttr("icon") as string | undefined;
    }

    isEnableClose() {
        return this.getAttr("enableClose") as boolean;
    }

    getCloseType() {
        return this.getAttr("closeType") as number;
    }

    isEnablePopout() {
        return this.getAttr("enablePopout") as boolean;
    }

    isEnablePopoutIcon() {
        return this.getAttr("enablePopoutIcon") as boolean;
    }

    isEnablePopoutOverlay() {
        return this.getAttr("enablePopoutOverlay") as boolean;
    }

    isEnableDrag() {
        return this.getAttr("enableDrag") as boolean;
    }

    isEnableRename() {
        return this.getAttr("enableRename") as boolean;
    }

    isEnableWindowReMount() {
        return this.getAttr("enableWindowReMount") as boolean;
    }

    getClassName() {
        return this.getAttr("className") as string | undefined;
    }

    getContentClassName() {
        return this.getAttr("contentClassName") as string | undefined;
    }

    getTabSetClassName() {
        return this.getAttr("tabsetClassName") as string | undefined;
    }

    isEnableRenderOnDemand() {
        return this.getAttr("enableRenderOnDemand") as boolean;
    }

    getMinWidth() {
        return this.getAttr("minWidth") as number;
    }

    getMinHeight() {
        return this.getAttr("minHeight") as number;
    }

    getMaxWidth() {
        return this.getAttr("maxWidth") as number;
    }

    getMaxHeight() {
        return this.getAttr("maxHeight") as number;
    }

    toJson(): IJsonTabNode {
        const json = {};
        TabNode.attributeDefinitions.toJson(json, this.attributes);
        return json;
    }

    /** @internal */
    saveScrollPosition() {
        if (this.moveableElement) {
            this.scrollLeft = this.moveableElement.scrollLeft;
            this.scrollTop = this.moveableElement.scrollTop;
            // console.log("save", this.getName(), this.scrollTop);
        }
    }

    /** @internal */
    restoreScrollPosition() {
        if (this.scrollTop) {
            requestAnimationFrame(() => {
                if (this.moveableElement) {
                    if (this.scrollTop) {
                        // console.log("restore", this.getName(), this.scrollTop);
                        this.moveableElement.scrollTop = this.scrollTop;
                        this.moveableElement.scrollLeft = this.scrollLeft!;
                    }
                }
            });
        }
    }

    /** @internal */
    setRect(rect: Rect) {
        if (!rect.equals(this.rect)) {
            this.fireEvent("resize", {rect});
            this.rect = rect;
        }
    }

    /** @internal */
    setVisible(visible: boolean) {
        if (visible !== this.visible) {
            this.fireEvent("visibility", { visible });
            this.visible = visible;
        }
    }

    /** @internal */
    getScrollTop() {
        return this.scrollTop;
    }

    /** @internal */
    setScrollTop(scrollTop: number | undefined) {
        this.scrollTop = scrollTop;
    }
    /** @internal */
    getScrollLeft() {
        return this.scrollLeft;
    }

    /** @internal */
    setScrollLeft(scrollLeft: number | undefined) {
        this.scrollLeft = scrollLeft;
    }
    /** @internal */
    isRendered() {
        return this.rendered;
    }

    /** @internal */
    setRendered(rendered: boolean) {
        this.rendered = rendered;
    }

    /** @internal */
    getTabRect() {
        return this.tabRect;
    }

    /** @internal */
    setTabRect(rect: Rect) {
        this.tabRect = rect;
    }

    /** @internal */
    getTabStamp() {
        return this.tabStamp;
    }

    /** @internal */
    setTabStamp(stamp: HTMLElement | null) {
        this.tabStamp = stamp;
    }

    /** @internal */
    getMoveableElement() {
        return this.moveableElement;
    }

    /** @internal */
    setMoveableElement(element: HTMLElement | null) {
        this.moveableElement = element;
    }

    /** @internal */
    setRenderedName(name: string) {
        this.renderedName = name;
    }

    /** @internal */
    getNameForOverflowMenu() {
        const altName = this.getAttr("altName") as string;
        if (altName !== undefined) {
            return altName;
        }
        return this.renderedName;
    }

    /** @internal */
    setName(name: string) {
        this.attributes.name = name;
    }

    /** @internal */
    delete() {
        (this.parent as TabSetNode | BorderNode).remove(this);
        this.fireEvent("close", {});
    }

    /** @internal */
    updateAttrs(json: any) {
        TabNode.attributeDefinitions.update(json, this.attributes);
    }

    /** @internal */
    getAttributeDefinitions() {
        return TabNode.attributeDefinitions;
    }

    /** @internal */
    setBorderWidth(width: number) {
        this.attributes.borderWidth = width;
    }

    /** @internal */
    setBorderHeight(height: number) {
        this.attributes.borderHeight = height;
    }

    /** @internal */
    static getAttributeDefinitions() {
        return TabNode.attributeDefinitions;
    }

    /** @internal */
    private static attributeDefinitions: AttributeDefinitions = TabNode.createAttributeDefinitions();

    /** @internal */
    private static createAttributeDefinitions(): AttributeDefinitions {
        const attributeDefinitions = new AttributeDefinitions();
        attributeDefinitions.add("type", TabNode.TYPE, true).setType(Attribute.STRING).setFixed();
        attributeDefinitions.add("id", undefined).setType(Attribute.STRING).setDescription(
            `the unique id of the tab, if left undefined a uuid will be assigned`
        );

        attributeDefinitions.add("name", "[Unnamed Tab]").setType(Attribute.STRING).setDescription(
            `name of tab to be displayed in the tab button`
        );
        attributeDefinitions.add("altName", undefined).setType(Attribute.STRING).setDescription(
            `if there is no name specifed then this value will be used in the overflow menu`
        );
        attributeDefinitions.add("helpText", undefined).setType(Attribute.STRING).setDescription(
            `An optional help text for the tab to be displayed upon tab hover.`
        );
        attributeDefinitions.add("component", undefined).setType(Attribute.STRING).setDescription(
            `string identifying which component to run (for factory)`
        );
        attributeDefinitions.add("config", undefined).setType("any").setDescription(
            `a place to hold json config for the hosted component`
        );
        attributeDefinitions.add("tabsetClassName", undefined).setType(Attribute.STRING).setDescription(
            `class applied to parent tabset when this is the only tab and it is stretched to fill the tabset`
        );
        attributeDefinitions.add("enableWindowReMount", false).setType(Attribute.BOOLEAN).setDescription(
            `if enabled the tab will re-mount when popped out/in`
        );

        attributeDefinitions.addInherited("enableClose", "tabEnableClose").setType(Attribute.BOOLEAN).setDescription(
            `allow user to close tab via close button`
        );
        attributeDefinitions.addInherited("closeType", "tabCloseType").setType("ICloseType").setDescription(
            `see values in ICloseType`
        );
        attributeDefinitions.addInherited("enableDrag", "tabEnableDrag").setType(Attribute.BOOLEAN).setDescription(
            `allow user to drag tab to new location`
        );
        attributeDefinitions.addInherited("enableRename", "tabEnableRename").setType(Attribute.BOOLEAN).setDescription(
            `allow user to rename tabs by double clicking`
        );
        attributeDefinitions.addInherited("className", "tabClassName").setType(Attribute.STRING).setDescription(
            `class applied to tab button`
        );
        attributeDefinitions.addInherited("contentClassName", "tabContentClassName").setType(Attribute.STRING).setDescription(
            `class applied to tab content`
        );
        attributeDefinitions.addInherited("icon", "tabIcon").setType(Attribute.STRING).setDescription(
            `the tab icon`
        );
        attributeDefinitions.addInherited("enableRenderOnDemand", "tabEnableRenderOnDemand").setType(Attribute.BOOLEAN).setDescription(
            `whether to avoid rendering component until tab is visible`
        );
        attributeDefinitions.addInherited("enablePopout", "tabEnablePopout").setType(Attribute.BOOLEAN).setAlias("enableFloat").setDescription(
            `enable popout (in popout capable browser)`
        );
        attributeDefinitions.addInherited("enablePopoutIcon", "tabEnablePopoutIcon").setType(Attribute.BOOLEAN).setDescription(
            `whether to show the popout icon in the tabset header if this tab enables popouts`
        );
        attributeDefinitions.addInherited("enablePopoutOverlay", "tabEnablePopoutOverlay").setType(Attribute.BOOLEAN).setDescription(
            `if this tab will not work correctly in a popout window when the main window is backgrounded (inactive)
            then enabling this option will gray out this tab`
        );

        attributeDefinitions.addInherited("borderWidth", "tabBorderWidth").setType(Attribute.NUMBER).setDescription(
            `width when added to border, -1 will use border size`
        );
        attributeDefinitions.addInherited("borderHeight", "tabBorderHeight").setType(Attribute.NUMBER).setDescription(
            `height when added to border, -1 will use border size`
        );
        attributeDefinitions.addInherited("minWidth", "tabMinWidth").setType(Attribute.NUMBER).setDescription(
            `the min width of this tab`
        );
        attributeDefinitions.addInherited("minHeight", "tabMinHeight").setType(Attribute.NUMBER).setDescription(
            `the min height of this tab`
        );
        attributeDefinitions.addInherited("maxWidth", "tabMaxWidth").setType(Attribute.NUMBER).setDescription(
            `the max width of this tab`
        );
        attributeDefinitions.addInherited("maxHeight", "tabMaxHeight").setType(Attribute.NUMBER).setDescription(
            `the max height of this tab`
        );

        return attributeDefinitions;
    }
}

```

## File: src/model/LayoutWindow.ts

```typescript
import { Rect } from "../Rect";
import { IJsonPopout } from "./IJsonModel";
import { Model } from "./Model";
import { RowNode } from "./RowNode";
import { Node } from "./Node";
import { TabSetNode } from "./TabSetNode";
import { LayoutInternal } from "../view/Layout";

export class LayoutWindow {
    private _windowId: string;
    private _layout: LayoutInternal | undefined;
    private _rect: Rect;
    private _window?: Window | undefined;
    private _root?: RowNode | undefined;
    private _maximizedTabSet?: TabSetNode | undefined;
    private _activeTabSet?: TabSetNode | undefined;
    private _toScreenRectFunction: (rect: Rect) => Rect;

    constructor(windowId: string, rect: Rect) {
        this._windowId = windowId;
        this._rect = rect;
        this._toScreenRectFunction = (r) => r;
    }

    public visitNodes(fn: (node: Node, level: number) => void) {
        this.root!.forEachNode(fn, 0);
    }

    public get windowId(): string {
        return this._windowId;
    }

    public get rect(): Rect {
        return this._rect;
    }

    public get layout(): LayoutInternal | undefined {
        return this._layout;
    }

    public get window(): Window | undefined {
        return this._window;
    }

    public get root(): RowNode | undefined {
        return this._root;
    }

    public get maximizedTabSet(): TabSetNode | undefined {
        return this._maximizedTabSet;
    }

    public get activeTabSet(): TabSetNode | undefined {
        return this._activeTabSet;
    }

    /** @internal */
    public set rect(value: Rect) {
        this._rect = value;
    }

    /** @internal */
    public set layout(value: LayoutInternal) {
        this._layout = value;
    }

    /** @internal */
    public set window(value: Window | undefined) {
        this._window = value;
    }

    /** @internal */
    public set root(value: RowNode | undefined) {
        this._root = value;
    }

    /** @internal */
    public set maximizedTabSet(value: TabSetNode | undefined) {
        this._maximizedTabSet = value;
    }

    /** @internal */
    public set activeTabSet(value: TabSetNode | undefined) {
        this._activeTabSet = value;
    }

    /** @internal */
    public get toScreenRectFunction(): (rect: Rect) => Rect {
        return this._toScreenRectFunction!;
    }

    /** @internal */
    public set toScreenRectFunction(value: (rect: Rect) => Rect) {
        this._toScreenRectFunction = value;
    }

    public toJson(): IJsonPopout {
        // chrome sets top,left to large -ve values when minimized, dont save in this case
        if (this._window && this._window.screenTop > -10000) {
            this.rect = new Rect(
                this._window.screenLeft,
                this._window.screenTop,
                this._window.outerWidth,
                this._window.outerHeight
            );
        }

        return { layout: this.root!.toJson(), rect: this.rect.toJson() }
    }

    static fromJson(windowJson: IJsonPopout, model: Model, windowId: string): LayoutWindow {
        const count = model.getwindowsMap().size;
        let rect = windowJson.rect ? Rect.fromJson(windowJson.rect) : new Rect(50 + 50 * count, 50 + 50 * count, 600, 400);
        rect.snap(10); // snapping prevents issue where window moves 1 pixel per save/restore on Chrome
        const layoutWindow = new LayoutWindow(windowId, rect);
        layoutWindow.root = RowNode.fromJson(windowJson.layout, model, layoutWindow);
        return layoutWindow;
    }
}
```

## File: src/model/BorderNode.ts

```typescript
import { Attribute } from "../Attribute";
import { AttributeDefinitions } from "../AttributeDefinitions";
import { DockLocation } from "../DockLocation";
import { DropInfo } from "../DropInfo";
import { Orientation } from "../Orientation";
import { Rect } from "../Rect";
import { CLASSES } from "../Types";
import { IDraggable } from "./IDraggable";
import { IDropTarget } from "./IDropTarget";
import { IJsonBorderNode } from "./IJsonModel";
import { Model } from "./Model";
import { Node } from "./Node";
import { TabNode } from "./TabNode";
import { TabSetNode } from "./TabSetNode";
import { adjustSelectedIndex } from "./Utils";

export class BorderNode extends Node implements IDropTarget {
    static readonly TYPE = "border";

    /** @internal */
    static fromJson(json: any, model: Model) {
        const location = DockLocation.getByName(json.location);
        const border = new BorderNode(location, json, model);
        if (json.children) {
            border.children = json.children.map((jsonChild: any) => {
                const child = TabNode.fromJson(jsonChild, model);
                child.setParent(border);
                return child;
            });
        }

        return border;
    }
    /** @internal */
    private static attributeDefinitions: AttributeDefinitions = BorderNode.createAttributeDefinitions();

    /** @internal */
    private outerRect: Rect = Rect.empty();
    /** @internal */
    private contentRect: Rect = Rect.empty();
    /** @internal */
    private tabHeaderRect: Rect = Rect.empty();
    /** @internal */
    private location: DockLocation;

    /** @internal */
    constructor(location: DockLocation, json: any, model: Model) {
        super(model);

        this.location = location;
        this.attributes.id = `border_${location.getName()}`;
        BorderNode.attributeDefinitions.fromJson(json, this.attributes);
        model.addNode(this);
    }

    getLocation() {
        return this.location;
    }

    getClassName() {
        return this.getAttr("className") as string | undefined;
    }

    isHorizontal() {
        return this.location.orientation === Orientation.HORZ;
    }

    getSize() {
        const defaultSize = this.getAttr("size") as number;
        const selected = this.getSelected();
        if (selected === -1) {
            return defaultSize;
        } else {
            const tabNode = this.children[selected] as TabNode;
            const tabBorderSize = this.isHorizontal() ? tabNode.getAttr("borderWidth") : tabNode.getAttr("borderHeight");
            if (tabBorderSize === -1) {
                return defaultSize;
            } else {
                return tabBorderSize;
            }
        }
    }

    getMinSize() {
        const selectedNode = this.getSelectedNode();
        let min = this.getAttr("minSize") as number;
        if (selectedNode) {
            const nodeMin = this.isHorizontal() ? selectedNode.getMinWidth() : selectedNode.getMinHeight();
            min = Math.max(min, nodeMin);
        }
        return min;
    }

    getMaxSize() {
        const selectedNode = this.getSelectedNode();
        let max = this.getAttr("maxSize") as number;
        if (selectedNode) {
            const nodeMax = this.isHorizontal() ? selectedNode.getMaxWidth() : selectedNode.getMaxHeight();
            max = Math.min(max, nodeMax);
        }
        return max;
    }

    getSelected(): number {
        return this.attributes.selected as number;
    }

    isAutoHide() {
        return this.getAttr("enableAutoHide") as boolean;
    }

    getSelectedNode(): TabNode | undefined {
        if (this.getSelected() !== -1) {
            return this.children[this.getSelected()] as TabNode;
        }
        return undefined;
    }

    getOrientation() {
        return this.location.getOrientation();
    }

    /**
     * Returns the config attribute that can be used to store node specific data that
     * WILL be saved to the json. The config attribute should be changed via the action Actions.updateNodeAttributes rather
     * than directly, for example:
     * this.state.model.doAction(
     *   FlexLayout.Actions.updateNodeAttributes(node.getId(), {config:myConfigObject}));
     */
    getConfig() {
        return this.attributes.config;
    }

    isMaximized() {
        return false;
    }

    isShowing() {
        return this.attributes.show as boolean;
    }

    toJson(): IJsonBorderNode {
        const json: any = {};
        BorderNode.attributeDefinitions.toJson(json, this.attributes);
        json.location = this.location.getName();
        json.children = this.children.map((child) => (child as TabNode).toJson());
        return json;
    }

    /** @internal */
    isAutoSelectTab(whenOpen?: boolean) {
        if (whenOpen == null) {
            whenOpen = this.getSelected() !== -1;
        }
        if (whenOpen) {
            return this.getAttr("autoSelectTabWhenOpen") as boolean;
        } else {
            return this.getAttr("autoSelectTabWhenClosed") as boolean;
        }
    }

    isEnableTabScrollbar() {
        return this.getAttr("enableTabScrollbar") as boolean;
    }

    /** @internal */
    setSelected(index: number) {
        this.attributes.selected = index;
    }

    /** @internal */
    getTabHeaderRect() {
        return this.tabHeaderRect;
    }

    /** @internal */
    setTabHeaderRect(r: Rect) {
        this.tabHeaderRect = r;
    }

    /** @internal */
    getOuterRect() {
        return this.outerRect;
    }

    /** @internal */
    setOuterRect(r: Rect) {
        this.outerRect = r;
    }

    /** @internal */
    getRect() {
        return this.tabHeaderRect!;
    }

    /** @internal */
    getContentRect() {
        return this.contentRect;
    }

    /** @internal */
    setContentRect(r: Rect) {
        this.contentRect = r;
    }

    /** @internal */
    isEnableDrop() {
        return this.getAttr("enableDrop") as boolean;
    }

    /** @internal */
    setSize(pos: number) {
        const selected = this.getSelected();
        if (selected === -1) {
            this.attributes.size = pos;
        } else {
            const tabNode = this.children[selected] as TabNode;
            const tabBorderSize = this.isHorizontal() ? tabNode.getAttr("borderWidth") : tabNode.getAttr("borderHeight");
            if (tabBorderSize === -1) {
                this.attributes.size = pos;
            } else {
                if (this.isHorizontal()) {
                    tabNode.setBorderWidth(pos);
                } else {
                    tabNode.setBorderHeight(pos);
                }
            }
        }
    }

    /** @internal */
    updateAttrs(json: any) {
        BorderNode.attributeDefinitions.update(json, this.attributes);
    }

    /** @internal */
    remove(node: TabNode) {
        const removedIndex = this.removeChild(node);
        if (this.getSelected() !== -1) {
            adjustSelectedIndex(this, removedIndex);
        }
    }

    /** @internal */
    canDrop(dragNode: Node & IDraggable, x: number, y: number): DropInfo | undefined {
        if (!(dragNode instanceof TabNode)) {
            return undefined;
        }

        let dropInfo;
        const dockLocation = DockLocation.CENTER;

        if (this.tabHeaderRect!.contains(x, y)) {
            if (this.location.orientation === Orientation.VERT) {
                if (this.children.length > 0) {
                    let child = this.children[0];
                    let childRect = (child as TabNode).getTabRect()!;
                    const childY = childRect.y;

                    const childHeight = childRect.height;

                    let pos = this.tabHeaderRect!.x;
                    let childCenter = 0;
                    for (let i = 0; i < this.children.length; i++) {
                        child = this.children[i];
                        childRect = (child as TabNode).getTabRect()!;
                        childCenter = childRect.x + childRect.width / 2;
                        if (x >= pos && x < childCenter) {
                            const outlineRect = new Rect(childRect.x - 2, childY, 3, childHeight);
                            dropInfo = new DropInfo(this, outlineRect, dockLocation, i, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
                            break;
                        }
                        pos = childCenter;
                    }
                    if (dropInfo == null) {
                        const outlineRect = new Rect(childRect.getRight() - 2, childY, 3, childHeight);
                        dropInfo = new DropInfo(this, outlineRect, dockLocation, this.children.length, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
                    }
                } else {
                    const outlineRect = new Rect(this.tabHeaderRect!.x + 1, this.tabHeaderRect!.y + 2, 3, 18);
                    dropInfo = new DropInfo(this, outlineRect, dockLocation, 0, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
                }
            } else {
                if (this.children.length > 0) {
                    let child = this.children[0];
                    let childRect = (child as TabNode).getTabRect()!;
                    const childX = childRect.x;
                    const childWidth = childRect.width;

                    let pos = this.tabHeaderRect!.y;
                    let childCenter = 0;
                    for (let i = 0; i < this.children.length; i++) {
                        child = this.children[i];
                        childRect = (child as TabNode).getTabRect()!;
                        childCenter = childRect.y + childRect.height / 2;
                        if (y >= pos && y < childCenter) {
                            const outlineRect = new Rect(childX, childRect.y - 2, childWidth, 3);
                            dropInfo = new DropInfo(this, outlineRect, dockLocation, i, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
                            break;
                        }
                        pos = childCenter;
                    }
                    if (dropInfo == null) {
                        const outlineRect = new Rect(childX, childRect.getBottom() - 2, childWidth, 3);
                        dropInfo = new DropInfo(this, outlineRect, dockLocation, this.children.length, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
                    }
                } else {
                    const outlineRect = new Rect(this.tabHeaderRect!.x + 2, this.tabHeaderRect!.y + 1, 18, 3);
                    dropInfo = new DropInfo(this, outlineRect, dockLocation, 0, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
                }
            }
            if (!dragNode.canDockInto(dragNode, dropInfo)) {
                return undefined;
            }
        } else if (this.getSelected() !== -1 && this.outerRect!.contains(x, y)) {
            const outlineRect = this.outerRect;
            dropInfo = new DropInfo(this, outlineRect!, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
            if (!dragNode.canDockInto(dragNode, dropInfo)) {
                return undefined;
            }
        }

        return dropInfo;
    }

    /** @internal */
    drop(dragNode: Node & IDraggable, location: DockLocation, index: number, select?: boolean): void {
        let fromIndex = 0;
        const dragParent = dragNode.getParent() as BorderNode | TabSetNode;
        if (dragParent !== undefined) {
            fromIndex = dragParent.removeChild(dragNode);
            // if selected node in border is being docked into a different border then deselect border tabs
            if (dragParent !== this && dragParent instanceof BorderNode && dragParent.getSelected() === fromIndex) {
                dragParent.setSelected(-1);
            } else {
                adjustSelectedIndex(dragParent, fromIndex);
            }
        }

        // if dropping a tab back to same tabset and moving to forward position then reduce insertion index
        if (dragNode instanceof TabNode && dragParent === this && fromIndex < index && index > 0) {
            index--;
        }

        // simple_bundled dock to existing tabset
        let insertPos = index;
        if (insertPos === -1) {
            insertPos = this.children.length;
        }

        if (dragNode instanceof TabNode) {
            this.addChild(dragNode, insertPos);
        }

        if (select || (select !== false && this.isAutoSelectTab())) {
            this.setSelected(insertPos);
        }

        this.model.tidy();
    }

    /** @internal */
    getSplitterBounds(index: number, useMinSize: boolean = false) {
        const pBounds = [0, 0];
        const minSize = useMinSize ? this.getMinSize() : 0;
        const maxSize = useMinSize ? this.getMaxSize() : 99999;
        const rootRow = this.model.getRoot(Model.MAIN_WINDOW_ID);
        const innerRect = rootRow.getRect();
        const splitterSize = this.model.getSplitterSize()
        if (this.location === DockLocation.TOP) {
            pBounds[0] = this.tabHeaderRect!.getBottom() + minSize;
            const maxPos = this.tabHeaderRect!.getBottom() + maxSize;
            pBounds[1] = Math.max(pBounds[0], innerRect.getBottom() - rootRow.getMinHeight() - splitterSize);
            pBounds[1] = Math.min(pBounds[1], maxPos);
        } else if (this.location === DockLocation.LEFT) {
            pBounds[0] = this.tabHeaderRect!.getRight() + minSize;
            const maxPos = this.tabHeaderRect!.getRight() + maxSize;
            pBounds[1] = Math.max(pBounds[0], innerRect.getRight() - rootRow.getMinWidth() - splitterSize);
            pBounds[1] = Math.min(pBounds[1], maxPos);
        } else if (this.location === DockLocation.BOTTOM) {
            pBounds[1] = this.tabHeaderRect!.y - minSize - splitterSize;
            const maxPos = this.tabHeaderRect!.y - maxSize - splitterSize;
            pBounds[0] = Math.min(pBounds[1], innerRect.y + rootRow.getMinHeight());
            pBounds[0] = Math.max(pBounds[0], maxPos);
        } else if (this.location === DockLocation.RIGHT) {
            pBounds[1] = this.tabHeaderRect!.x - minSize - splitterSize;
            const maxPos = this.tabHeaderRect!.x - maxSize - splitterSize;
            pBounds[0] = Math.min(pBounds[1], innerRect.x + rootRow.getMinWidth());
            pBounds[0] = Math.max(pBounds[0], maxPos);
        }
        return pBounds;
    }

    /** @internal */
    calculateSplit(splitter: BorderNode, splitterPos: number) {
        const pBounds = this.getSplitterBounds(splitterPos);
        if (this.location === DockLocation.BOTTOM || this.location === DockLocation.RIGHT) {
            return Math.max(0, pBounds[1]! - splitterPos);
        } else {
            return Math.max(0, splitterPos - pBounds[0]!);
        }
    }

    /** @internal */
    getAttributeDefinitions() {
        return BorderNode.attributeDefinitions;
    }

    /** @internal */
    static getAttributeDefinitions() {
        return BorderNode.attributeDefinitions;
    }

    /** @internal */
    private static createAttributeDefinitions(): AttributeDefinitions {
        const attributeDefinitions = new AttributeDefinitions();
        attributeDefinitions.add("type", BorderNode.TYPE, true).setType(Attribute.STRING).setFixed();

        attributeDefinitions.add("selected", -1).setType(Attribute.NUMBER).setDescription(
            `index of selected/visible tab in border; -1 means no tab selected`
        );
        attributeDefinitions.add("show", true).setType(Attribute.BOOLEAN).setDescription(
            `show/hide this border`
        );
        attributeDefinitions.add("config", undefined).setType("any").setDescription(
            `a place to hold json config used in your own code`
        );

        attributeDefinitions.addInherited("enableDrop", "borderEnableDrop").setType(Attribute.BOOLEAN).setDescription(
            `whether tabs can be dropped into this border`
        );
        attributeDefinitions.addInherited("className", "borderClassName").setType(Attribute.STRING).setDescription(
            `class applied to tab button`
        );
        attributeDefinitions.addInherited("autoSelectTabWhenOpen", "borderAutoSelectTabWhenOpen").setType(Attribute.BOOLEAN).setDescription(
            `whether to select new/moved tabs in border when the border is already open`
        );
        attributeDefinitions.addInherited("autoSelectTabWhenClosed", "borderAutoSelectTabWhenClosed").setType(Attribute.BOOLEAN).setDescription(
            `whether to select new/moved tabs in border when the border is currently closed`
        );
        attributeDefinitions.addInherited("size", "borderSize").setType(Attribute.NUMBER).setDescription(
            `size of the tab area when selected`
        );
        attributeDefinitions.addInherited("minSize", "borderMinSize").setType(Attribute.NUMBER).setDescription(
            `the minimum size of the tab area`
        );
        attributeDefinitions.addInherited("maxSize", "borderMaxSize").setType(Attribute.NUMBER).setDescription(
            `the maximum size of the tab area`
        );
        attributeDefinitions.addInherited("enableAutoHide", "borderEnableAutoHide").setType(Attribute.BOOLEAN).setDescription(
            `hide border if it has zero tabs`
        );
        attributeDefinitions.addInherited("enableTabScrollbar", "borderEnableTabScrollbar").setType(Attribute.BOOLEAN).setDescription(
            `whether to show a mini scrollbar for the tabs`
        );
        return attributeDefinitions;
    }
}

```

## File: src/model/Node.ts

```typescript
import { AttributeDefinitions } from "../AttributeDefinitions";
import { DockLocation } from "../DockLocation";
import { DropInfo } from "../DropInfo";
import { Orientation } from "../Orientation";
import { Rect } from "../Rect";
import { IDraggable } from "./IDraggable";
import { IJsonBorderNode, IJsonRowNode, IJsonTabNode, IJsonTabSetNode } from "./IJsonModel";
import { Model } from "./Model";

export abstract class Node {
    /** @internal */
    protected model: Model;
    /** @internal */
    protected attributes: Record<string, any>;
    /** @internal */
    protected parent?: Node;
    /** @internal */
    protected children: Node[];
    /** @internal */
    protected rect: Rect;
    /** @internal */
    protected path: string;
    /** @internal */
    protected listeners: Map<string, (params: any) => void>;

    /** @internal */
    protected constructor(_model: Model) {
        this.model = _model;
        this.attributes = {};
        this.children = [];
        this.rect = Rect.empty();
        this.listeners = new Map();
        this.path = "";
    }

    getId() {
        let id = this.attributes.id;
        if (id !== undefined) {
            return id as string;
        }

        id = this.model.nextUniqueId();
        this.setId(id);

        return id as string;
    }

    getModel() {
        return this.model;
    }

    getType() {
        return this.attributes.type as string;
    }

    getParent() {
        return this.parent;
    }

    getChildren() {
        return this.children;
    }

    getRect() {
        return this.rect;
    }

    getPath() {
        return this.path;
    }

    getOrientation(): Orientation {
        if (this.parent === undefined) {
            return this.model.isRootOrientationVertical() ? Orientation.VERT : Orientation.HORZ;
        } else {
            return Orientation.flip(this.parent.getOrientation());
        }
    }

    // event can be: resize, visibility, maximize (on tabset), close
    setEventListener(event: string, callback: (params: any) => void) {
        this.listeners.set(event, callback);
    }

    removeEventListener(event: string) {
        this.listeners.delete(event);
    }

    abstract toJson(): IJsonRowNode | IJsonBorderNode | IJsonTabSetNode | IJsonTabNode | undefined;

    /** @internal */
    setId(id: string) {
        this.attributes.id = id;
    }

    /** @internal */
    fireEvent(event: string, params: any) {
        // console.log(this._type, " fireEvent " + event + " " + JSON.stringify(params));
        if (this.listeners.has(event)) {
            this.listeners.get(event)!(params);
        }
    }

    /** @internal */
    getAttr(name: string) {
        let val = this.attributes[name];

        if (val === undefined) {
            const modelName = this.getAttributeDefinitions().getModelName(name);
            if (modelName !== undefined) {
                val = this.model.getAttribute(modelName);
            }
        }

        // console.log(name + "=" + val);
        return val;
    }

    /** @internal */
    forEachNode(fn: (node: Node, level: number) => void, level: number) {
        fn(this, level);
        level++;
        for (const node of this.children) {
            node.forEachNode(fn, level);
        }
    }

    /** @internal */
    setPaths(path: string) {
        let i = 0;

        for (const node of this.children) {
            let newPath = path;
            if (node.getType() === "row") {
                if (node.getOrientation() === Orientation.VERT) {
                    newPath += "/c" + i;
                } else {
                    newPath += "/r" + i;
                }
            } else if (node.getType() === "tabset") {
                newPath += "/ts" + i;
            } else if (node.getType() === "tab") {
                newPath += "/t" + i;
            }

            node.path = newPath;

            node.setPaths(newPath);
            i++;
        }
    }

    /** @internal */
    setParent(parent: Node) {
        this.parent = parent;
    }

    /** @internal */
    setRect(rect: Rect) {
        this.rect = rect;
    }

    /** @internal */
    setPath(path: string) {
        this.path = path;
    }

    /** @internal */
    setWeight(weight: number) {
        this.attributes.weight = weight;
    }

    /** @internal */
    setSelected(index: number) {
        this.attributes.selected = index;
    }

    /** @internal */
    findDropTargetNode(windowId: string, dragNode: Node & IDraggable, x: number, y: number): DropInfo | undefined {
        let rtn: DropInfo | undefined;
        if (this.rect.contains(x, y)) {
            if (this.model.getMaximizedTabset(windowId) !== undefined) {
                rtn = this.model.getMaximizedTabset(windowId)!.canDrop(dragNode, x, y);
            } else {
                rtn = this.canDrop(dragNode, x, y);
                if (rtn === undefined) {
                    if (this.children.length !== 0) {
                        for (const child of this.children) {
                            rtn = child.findDropTargetNode(windowId, dragNode, x, y);
                            if (rtn !== undefined) {
                                break;
                            }
                        }
                    }
                }
            }
        }

        return rtn;
    }

    /** @internal */
    canDrop(dragNode: Node & IDraggable, x: number, y: number): DropInfo | undefined {
        return undefined;
    }

    /** @internal */
    canDockInto(dragNode: Node & IDraggable, dropInfo: DropInfo | undefined): boolean {
        if (dropInfo != null) {
            if (dropInfo.location === DockLocation.CENTER && dropInfo.node.isEnableDrop() === false) {
                return false;
            }

            // prevent named tabset docking into another tabset, since this would lose the header
            if (dropInfo.location === DockLocation.CENTER && dragNode.getType() === "tabset" && dragNode.getName() !== undefined) {
                return false;
            }

            if (dropInfo.location !== DockLocation.CENTER && dropInfo.node.isEnableDivide() === false) {
                return false;
            }

            // finally check model callback to check if drop allowed
            if (this.model.getOnAllowDrop()) {
                return (this.model.getOnAllowDrop() as (dragNode: Node, dropInfo: DropInfo) => boolean)(dragNode, dropInfo);
            }
        }
        return true;
    }

    /** @internal */
    removeChild(childNode: Node) {
        const pos = this.children.indexOf(childNode);
        if (pos !== -1) {
            this.children.splice(pos, 1);
        }
        return pos;
    }

    /** @internal */
    addChild(childNode: Node, pos?: number) {
        if (pos != null) {
            this.children.splice(pos, 0, childNode);
        } else {
            this.children.push(childNode);
            pos = this.children.length - 1;
        }
        childNode.parent = this;
        return pos;
    }

    /** @internal */
    removeAll() {
        this.children = [];
    }

    /** @internal */
    styleWithPosition(style?: Record<string, any>) {
        if (style == null) {
            style = {};
        }
        return this.rect.styleWithPosition(style);
    }

    /** @internal */
    isEnableDivide() {
        return true;
    }

    /** @internal */
    toAttributeString() {
        return JSON.stringify(this.attributes, undefined, "\t");
    }

    // implemented by subclasses
    /** @internal */
    abstract updateAttrs(json: any): void;
    /** @internal */
    abstract getAttributeDefinitions(): AttributeDefinitions;
}

```

## File: src/model/ICloseType.ts

```typescript
export enum ICloseType {
    Visible = 1, // close if selected or hovered, i.e. when x is visible (will only close selected on mobile, where css hover is not available)
    Always = 2, // close always (both selected and unselected when x rect tapped e.g where a custom image has been added for close)
    Selected = 3, // close only if selected
}

```

## File: src/model/IDraggable.ts

```typescript
export interface IDraggable {
    /** @internal */
    isEnableDrag(): boolean;
    /** @internal */
    getName(): string | undefined;
}


```

## File: src/model/Utils.ts

```typescript
import { TabSetNode } from "./TabSetNode";
import { BorderNode } from "./BorderNode";
import { RowNode } from "./RowNode";
import { TabNode } from "./TabNode";

/** @internal */
export function adjustSelectedIndexAfterDock(node: TabNode) {
    const parent = node.getParent();
    if (parent !== null && (parent instanceof TabSetNode || parent instanceof BorderNode)) {
        const children = parent.getChildren();
        for (let i = 0; i < children.length; i++) {
            const child = children[i] as TabNode;
            if (child === node) {
                parent.setSelected(i);
                return;
            }
        }
    }
}

/** @internal */
export function adjustSelectedIndex(parent: TabSetNode | BorderNode | RowNode, removedIndex: number) {
    // for the tabset/border being removed from set the selected index
    if (parent !== undefined && (parent instanceof TabSetNode || parent instanceof BorderNode)) {
        const selectedIndex = (parent as TabSetNode | BorderNode).getSelected();
        if (selectedIndex !== -1) {
            if (removedIndex === selectedIndex && parent.getChildren().length > 0) {
                if (removedIndex >= parent.getChildren().length) {
                    // removed last tab; select new last tab
                    parent.setSelected(parent.getChildren().length - 1);
                } else {
                    // leave selected index as is, selecting next tab after this one
                }
            } else if (removedIndex < selectedIndex) {
                parent.setSelected(selectedIndex - 1);
            } else if (removedIndex > selectedIndex) {
                // leave selected index as is
            } else {
                parent.setSelected(-1);
            }
        }
    }
}

export function randomUUID(): string {
    // @ts-ignore
    return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
      (c ^ crypto.getRandomValues(new Uint8Array(1))[0]! & 15 >> c / 4).toString(16)
    );
  }



```

## File: src/model/RowNode.ts

```typescript
import { TabNode } from "./TabNode";
import { Attribute } from "../Attribute";
import { AttributeDefinitions } from "../AttributeDefinitions";
import { DockLocation } from "../DockLocation";
import { DropInfo } from "../DropInfo";
import { Orientation } from "../Orientation";
import { CLASSES } from "../Types";
import { BorderNode } from "./BorderNode";
import { IDraggable } from "./IDraggable";
import { IDropTarget } from "./IDropTarget";
import { IJsonRowNode } from "./IJsonModel";
import { DefaultMax, DefaultMin, Model } from "./Model";
import { Node } from "./Node";
import { TabSetNode } from "./TabSetNode";
import { canDockToWindow } from "../view/Utils";
import { LayoutWindow } from "./LayoutWindow";

export class RowNode extends Node implements IDropTarget {
    static readonly TYPE = "row";

    /** @internal */
    static fromJson(json: any, model: Model, layoutWindow: LayoutWindow) {
        const newLayoutNode = new RowNode(model, layoutWindow.windowId, json);

        if (json.children != null) {
            for (const jsonChild of json.children) {
                if (jsonChild.type === TabSetNode.TYPE) {
                    const child = TabSetNode.fromJson(jsonChild, model, layoutWindow);
                    newLayoutNode.addChild(child);
                } else {
                    const child = RowNode.fromJson(jsonChild, model, layoutWindow);
                    newLayoutNode.addChild(child);
                }
            }
        }

        return newLayoutNode;
    }

    /** @internal */
    private static attributeDefinitions: AttributeDefinitions = RowNode.createAttributeDefinitions();

    /** @internal */
    private windowId: string;
    /** @internal */
    private minHeight: number;
    /** @internal */
    private minWidth: number;
    /** @internal */
    private maxHeight: number;
    /** @internal */
    private maxWidth: number;

    /** @internal */
    constructor(model: Model, windowId: string, json: any) {
        super(model);

        this.windowId = windowId;
        this.minHeight = DefaultMin;
        this.minWidth = DefaultMin;
        this.maxHeight = DefaultMax;
        this.maxWidth = DefaultMax;
        RowNode.attributeDefinitions.fromJson(json, this.attributes);
        this.normalizeWeights();
        model.addNode(this);
    }

    getWeight() {
        return this.attributes.weight as number;
    }

    toJson(): IJsonRowNode {
        const json: any = {};
        RowNode.attributeDefinitions.toJson(json, this.attributes);

        json.children = [];
        for (const child of this.children) {
            json.children.push(child.toJson());
        }

        return json;
    }

    /** @internal */
    getWindowId() {
        return this.windowId;
    }

    setWindowId(windowId: string) {
        this.windowId = windowId;
    }

    /** @internal */
    setWeight(weight: number) {
        this.attributes.weight = weight;
    }

    /** @internal */
    getSplitterBounds(index: number) {
        const h = this.getOrientation() === Orientation.HORZ;
        const c = this.getChildren();
        const ss = this.model.getSplitterSize();
        const fr = c[0]!.getRect();
        const lr = c[c.length - 1]!.getRect();
        let p = h ? [fr.x, lr.getRight()] : [fr.y, lr.getBottom()];
        const q = h ? [fr.x, lr.getRight()] : [fr.y, lr.getBottom()];

        for (let i = 0; i < index; i++) {
            const n = c[i] as TabSetNode | RowNode;
            p[0]! += h ? n.getMinWidth() : n.getMinHeight();
            q[0]! += h ? n.getMaxWidth() : n.getMaxHeight();
            if (i > 0) {
                p[0]! += ss;
                q[0]! += ss;
            }
        }

        for (let i = c.length - 1; i >= index; i--) {
            const n = c[i] as TabSetNode | RowNode;
            p[1]! -= (h ? n.getMinWidth() : n.getMinHeight()) + ss;
            q[1]! -= (h ? n.getMaxWidth() : n.getMaxHeight()) + ss;
        }

        p = [Math.max(q[1]!, p[0]!), Math.min(q[0]!, p[1]!)];

        return p;
    }

    /** @internal */
    getSplitterInitials(index: number) {
        const h = this.getOrientation() === Orientation.HORZ;
        const c = this.getChildren();
        const ss = this.model.getSplitterSize();
        const initialSizes = [];

        let sum = 0;

        for (let i = 0; i < c.length; i++) {
            const n = c[i] as TabSetNode | RowNode;
            const r = n.getRect();
            const s = h ? r.width : r.height;
            initialSizes.push(s);
            sum += s;
        }

        const startRect = c[index]!.getRect()
        const startPosition = (h ? startRect.x : startRect.y) - ss;

        return { initialSizes, sum, startPosition };
    }

    /** @internal */
    calculateSplit(index: number, splitterPos: number, initialSizes: number[], sum: number, startPosition: number) {
        const h = this.getOrientation() === Orientation.HORZ;
        const c = this.getChildren();
        const sn = c[index] as TabSetNode | RowNode;
        const smax = h ? sn.getMaxWidth() : sn.getMaxHeight();

        const sizes = [...initialSizes];

        if (splitterPos < startPosition) { // moved left
            let shift = startPosition - splitterPos;
            let altShift = 0;
            if (sizes[index]! + shift > smax) {
                altShift = sizes[index]! + shift - smax;
                sizes[index] = smax;
            } else {
                sizes[index]! += shift;
            }

            for (let i = index - 1; i >= 0; i--) {
                const n = c[i] as TabSetNode | RowNode;
                const m = h ? n.getMinWidth() : n.getMinHeight();
                if (sizes[i]! - shift > m) {
                    sizes[i]! -= shift;
                    break;
                } else {
                    shift -= sizes[i]! - m;
                    sizes[i] = m;
                }
            }

            for (let i = index+1; i < c.length; i++) {
                const n = c[i] as TabSetNode | RowNode;
                const m = h ? n.getMaxWidth() : n.getMaxHeight();
                if (sizes[i]! + altShift < m) {
                    sizes[i]! += altShift;
                    break;
                } else {
                    altShift -= m - sizes[i]!;
                    sizes[i] = m;
                }
            }


        } else {
            let shift = splitterPos - startPosition;
            let altShift = 0;
            if (sizes[index-1]! + shift > smax) {
                altShift = sizes[index-1]! + shift - smax;
                sizes[index-1] = smax;
            } else {
                sizes[index-1]! += shift;
            }

            for (let i = index; i < c.length; i++) {
                const n = c[i] as TabSetNode | RowNode;
                const m = h ? n.getMinWidth() : n.getMinHeight();
                if (sizes[i]! - shift > m) {
                    sizes[i]! -= shift;
                    break;
                } else {
                    shift -= sizes[i]! - m;
                    sizes[i] = m;
                }
            }

            for (let i = index - 1; i >= 0; i--) {
                const n = c[i] as TabSetNode | RowNode;
                const m = h ? n.getMaxWidth() : n.getMaxHeight();
                if (sizes[i]! + altShift < m) {
                    sizes[i]! += altShift;
                    break;
                } else {
                    altShift -= m - sizes[i]!;
                    sizes[i] = m;
                }
            }
        }

        // 0.1 is to prevent weight ever going to zero
        const weights = sizes.map(s => Math.max(0.1, s) * 100 / sum);

        // console.log(splitterPos, startPosition, "sizes", sizes);
        // console.log("weights",weights);
        return weights;
    }

    /** @internal */
    getMinSize(orientation: Orientation) {
        if (orientation === Orientation.HORZ) {
            return this.getMinWidth();
        } else {
            return this.getMinHeight();
        }
    }

    /** @internal */
    getMinWidth() {
        return this.minWidth;
    }

    /** @internal */
    getMinHeight() {
        return this.minHeight;
    }

    /** @internal */
    getMaxSize(orientation: Orientation) {
        if (orientation === Orientation.HORZ) {
            return this.getMaxWidth();
        } else {
            return this.getMaxHeight();
        }
    }

    /** @internal */
    getMaxWidth() {
        return this.maxWidth;
    }

    /** @internal */
    getMaxHeight() {
        return this.maxHeight;
    }

    /** @internal */
    calcMinMaxSize() {
        this.minHeight = DefaultMin;
        this.minWidth = DefaultMin;
        this.maxHeight = DefaultMax;
        this.maxWidth = DefaultMax;
        let first = true;
        for (const child of this.children) {
            const c = child as RowNode | TabSetNode;
            c.calcMinMaxSize();
            if (this.getOrientation() === Orientation.VERT) {
                this.minHeight += c.getMinHeight();
                this.maxHeight += c.getMaxHeight();
                if (!first) {
                    this.minHeight += this.model.getSplitterSize();
                    this.maxHeight += this.model.getSplitterSize();
                }
                this.minWidth = Math.max(this.minWidth, c.getMinWidth());
                this.maxWidth = Math.min(this.maxWidth, c.getMaxWidth());
            } else {
                this.minWidth += c.getMinWidth();
                this.maxWidth += c.getMaxWidth();
                if (!first) {
                    this.minWidth += this.model.getSplitterSize();
                    this.maxWidth += this.model.getSplitterSize();
                }
                this.minHeight = Math.max(this.minHeight, c.getMinHeight());
                this.maxHeight = Math.min(this.maxHeight, c.getMaxHeight());
            }
            first = false;
        }
    }

    /** @internal */
    tidy() {
        let i = 0;
        while (i < this.children.length) {
            const child = this.children[i];
            if (child instanceof RowNode) {
                child.tidy();

                const childChildren = child.getChildren();
                if (childChildren.length === 0) {
                    this.removeChild(child);
                } else if (childChildren.length === 1) {
                    // hoist child/children up to this level
                    const subchild = childChildren[0];
                    this.removeChild(child);
                    if (subchild instanceof RowNode) {
                        let subChildrenTotal = 0;
                        const subChildChildren = subchild.getChildren();
                        for (const ssc of subChildChildren) {
                            const subsubChild = ssc as RowNode | TabSetNode;
                            subChildrenTotal += subsubChild.getWeight();
                        }
                        for (let j = 0; j < subChildChildren.length; j++) {
                            const subsubChild = subChildChildren[j] as RowNode | TabSetNode;
                            subsubChild.setWeight((child.getWeight() * subsubChild.getWeight()) / subChildrenTotal);
                            this.addChild(subsubChild, i + j);
                        }
                    } else {
                        subchild!.setWeight(child.getWeight());
                        this.addChild(subchild!, i);
                    }
                } else {
                    i++;
                }
            } else if (child instanceof TabSetNode && child.getChildren().length === 0) {
                if (child.isEnableDeleteWhenEmpty()) {
                    this.removeChild(child);
                    if (child === this.model.getMaximizedTabset(this.windowId)) {
                        this.model.setMaximizedTabset(undefined, this.windowId);
                    }
                } else {
                    i++;
                }
            } else {
                i++;
            }
        }

        // add tabset into empty root
        if (this === this.model.getRoot(this.windowId) && this.children.length === 0) {
            const callback = this.model.getOnCreateTabSet();
            let attrs = callback ? callback() : {};
            attrs = { ...attrs, selected: -1 };
            const child = new TabSetNode(this.model, attrs);
            this.model.setActiveTabset(child, this.windowId);
            this.addChild(child);
        }

    }

    /** @internal */
    canDrop(dragNode: Node & IDraggable, x: number, y: number): DropInfo | undefined {
        const yy = y - this.rect.y;
        const xx = x - this.rect.x;
        const w = this.rect.width;
        const h = this.rect.height;
        const margin = 10; // height of edge rect
        const half = 50; // half width of edge rect
        let dropInfo;

        if (this.getWindowId() !== Model.MAIN_WINDOW_ID && !canDockToWindow(dragNode)) {
            return undefined;
        }

        if (this.model.isEnableEdgeDock() && this.parent === undefined) {
            if (x < this.rect.x + margin && yy > h / 2 - half && yy < h / 2 + half) {
                const dockLocation = DockLocation.LEFT;
                const outlineRect = dockLocation.getDockRect(this.rect);
                outlineRect.width = outlineRect.width / 2;
                dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);
            } else if (x > this.rect.getRight() - margin && yy > h / 2 - half && yy < h / 2 + half) {
                const dockLocation = DockLocation.RIGHT;
                const outlineRect = dockLocation.getDockRect(this.rect);
                outlineRect.width = outlineRect.width / 2;
                outlineRect.x += outlineRect.width;
                dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);
            } else if (y < this.rect.y + margin && xx > w / 2 - half && xx < w / 2 + half) {
                const dockLocation = DockLocation.TOP;
                const outlineRect = dockLocation.getDockRect(this.rect);
                outlineRect.height = outlineRect.height / 2;
                dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);
            } else if (y > this.rect.getBottom() - margin && xx > w / 2 - half && xx < w / 2 + half) {
                const dockLocation = DockLocation.BOTTOM;
                const outlineRect = dockLocation.getDockRect(this.rect);
                outlineRect.height = outlineRect.height / 2;
                outlineRect.y += outlineRect.height;
                dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT_EDGE);
            }

            if (dropInfo !== undefined) {
                if (!dragNode.canDockInto(dragNode, dropInfo)) {
                    return undefined;
                }
            }
        }

        return dropInfo;
    }

    /** @internal */
    drop(dragNode: Node, location: DockLocation, index: number): void {
        const dockLocation = location;

        const parent = dragNode.getParent();

        if (parent) {
            parent.removeChild(dragNode);
        }

        if (parent !== undefined && parent! instanceof TabSetNode) {
            parent.setSelected(0);
        }

        if (parent !== undefined && parent! instanceof BorderNode) {
            parent.setSelected(-1);
        }

        let node: TabSetNode | RowNode | undefined;
        if (dragNode instanceof TabSetNode || dragNode instanceof RowNode) {
            node = dragNode;
            // need to turn round if same orientation unless docking oposite direction
            if (node instanceof RowNode && node.getOrientation() === this.getOrientation() &&
                (location.getOrientation() === this.getOrientation() || location === DockLocation.CENTER)) {
                node = new RowNode(this.model, this.windowId, {});
                node.addChild(dragNode);
            }
        } else {
            const callback = this.model.getOnCreateTabSet();
            node = new TabSetNode(this.model, callback ? callback(dragNode as TabNode) : {});
            node.addChild(dragNode);
        }
        let size = this.children.reduce((sum, child) => {
            return sum + (child as RowNode | TabSetNode).getWeight();
        }, 0);

        if (size === 0) {
            size = 100;
        }

        node.setWeight(size / 3);

        const horz = !this.model.isRootOrientationVertical();
        if (dockLocation === DockLocation.CENTER) {
            if (index === -1) {
                this.addChild(node, this.children.length);
            } else {
                this.addChild(node, index);
            }
        } else if (horz && dockLocation === DockLocation.LEFT || !horz && dockLocation === DockLocation.TOP) {
            this.addChild(node, 0);
        } else if (horz && dockLocation === DockLocation.RIGHT || !horz && dockLocation === DockLocation.BOTTOM) {
            this.addChild(node);
        } else if (horz && dockLocation === DockLocation.TOP || !horz && dockLocation === DockLocation.LEFT) {
            const vrow = new RowNode(this.model, this.windowId, {});
            const hrow = new RowNode(this.model, this.windowId, {});
            hrow.setWeight(75);
            node.setWeight(25);
            for (const child of this.children) {
                hrow.addChild(child);
            }
            this.removeAll();
            vrow.addChild(node);
            vrow.addChild(hrow);
            this.addChild(vrow);
        } else if (horz && dockLocation === DockLocation.BOTTOM || !horz && dockLocation === DockLocation.RIGHT) {
            const vrow = new RowNode(this.model, this.windowId, {});
            const hrow = new RowNode(this.model, this.windowId, {});
            hrow.setWeight(75);
            node.setWeight(25);
            for (const child of this.children) {
                hrow.addChild(child);
            }
            this.removeAll();
            vrow.addChild(hrow);
            vrow.addChild(node);
            this.addChild(vrow);
        }

        if (node instanceof TabSetNode) {
            this.model.setActiveTabset(node, this.windowId);
        }

        this.model.tidy();
    }



    /** @internal */
    isEnableDrop() {
        return true;
    }

    /** @internal */
    getAttributeDefinitions() {
        return RowNode.attributeDefinitions;
    }

    /** @internal */
    updateAttrs(json: any) {
        RowNode.attributeDefinitions.update(json, this.attributes);
    }

    /** @internal */
    static getAttributeDefinitions() {
        return RowNode.attributeDefinitions;
    }


    // NOTE:  flex-grow cannot have values < 1 otherwise will not fill parent, need to normalize 
    normalizeWeights() {
        let sum = 0;
        for (const n of this.children) {
            const node = (n as TabSetNode | RowNode);
            sum += node.getWeight();
        }

        if (sum === 0) {
            sum = 1;
        }

        for (const n of this.children) {
            const node = (n as TabSetNode | RowNode);
            node.setWeight(Math.max(0.001, 100 * node.getWeight() / sum));
        }
    }

    /** @internal */
    private static createAttributeDefinitions(): AttributeDefinitions {
        const attributeDefinitions = new AttributeDefinitions();
        attributeDefinitions.add("type", RowNode.TYPE, true).setType(Attribute.STRING).setFixed();
        attributeDefinitions.add("id", undefined).setType(Attribute.STRING).setDescription(
            `the unique id of the row, if left undefined a uuid will be assigned`
        );
        attributeDefinitions.add("weight", 100).setType(Attribute.NUMBER).setDescription(
            `relative weight for sizing of this row in parent row`
        );

        return attributeDefinitions;
    }
}

```

## File: src/model/IDropTarget.ts

```typescript
import { DockLocation } from "../DockLocation";
import { DropInfo } from "../DropInfo";
import { IDraggable } from "./IDraggable";
import { Node } from "./Node";

export interface IDropTarget {
    /** @internal */
    canDrop(dragNode: Node & IDraggable, x: number, y: number): DropInfo | undefined;
    /** @internal */
    drop(dragNode: Node & IDraggable, location: DockLocation, index: number, select?: boolean): void;
    /** @internal */
    isEnableDrop(): boolean;
}


```

## File: src/model/Model.ts

```typescript
import { Attribute } from "../Attribute";
import { AttributeDefinitions } from "../AttributeDefinitions";
import { DockLocation } from "../DockLocation";
import { DropInfo } from "../DropInfo";
import { Rect } from "../Rect";
import { Action } from "./Action";
import { Actions } from "./Actions";
import { BorderNode } from "./BorderNode";
import { BorderSet } from "./BorderSet";
import { IDraggable } from "./IDraggable";
import { IDropTarget } from "./IDropTarget";
import { IJsonModel, IJsonPopout, ITabSetAttributes } from "./IJsonModel";
import { Node } from "./Node";
import { RowNode } from "./RowNode";
import { TabNode } from "./TabNode";
import { TabSetNode } from "./TabSetNode";
import { randomUUID } from "./Utils";
import { LayoutWindow } from "./LayoutWindow";

/** @internal */
export const DefaultMin = 0;
/** @internal */
export const DefaultMax = 99999;

/**
 * Class containing the Tree of Nodes used by the FlexLayout component
 */
export class Model {
    static MAIN_WINDOW_ID = "__main_window_id__";

    /** @internal */
    private static attributeDefinitions: AttributeDefinitions = Model.createAttributeDefinitions();

    /** @internal */
    private attributes: Record<string, any>;
    /** @internal */
    private idMap: Map<string, Node>;
    /** @internal */
    private changeListeners: ((action: Action) => void)[];
    /** @internal */
    private borders: BorderSet;
    /** @internal */
    private onAllowDrop?: (dragNode: Node, dropInfo: DropInfo) => boolean;
    /** @internal */
    private onCreateTabSet?: (tabNode?: TabNode) => ITabSetAttributes;
    /** @internal */
    private windows: Map<string, LayoutWindow>;
    /** @internal */
    private rootWindow: LayoutWindow;

    /**
     * 'private' constructor. Use the static method Model.fromJson(json) to create a model
     *  @internal
     */
    protected constructor() {
        this.attributes = {};
        this.idMap = new Map();
        this.borders = new BorderSet(this);
        this.windows = new Map<string, LayoutWindow>();
        this.rootWindow = new LayoutWindow(Model.MAIN_WINDOW_ID, Rect.empty());
        this.windows.set(Model.MAIN_WINDOW_ID, this.rootWindow);
        this.changeListeners = [];
    }

    /**
     * Update the node tree by performing the given action,
     * Actions should be generated via static methods on the Actions class
     * @param action the action to perform
     * @returns added Node for Actions.addNode, windowId for createWindow
     */
    doAction(action: Action): any {
        let returnVal = undefined;
        // console.log(action);
        switch (action.type) {
            case Actions.ADD_NODE: {
                const newNode = new TabNode(this, action.data.json, true);
                const toNode = this.idMap.get(action.data.toNode) as Node & IDraggable;
                if (toNode instanceof TabSetNode || toNode instanceof BorderNode || toNode instanceof RowNode) {
                    toNode.drop(newNode, DockLocation.getByName(action.data.location), action.data.index, action.data.select);
                    returnVal = newNode;
                }
                break;
            }
            case Actions.MOVE_NODE: {
                const fromNode = this.idMap.get(action.data.fromNode) as Node & IDraggable;

                if (fromNode instanceof TabNode || fromNode instanceof TabSetNode || fromNode instanceof RowNode) {
                    if (fromNode === this.getMaximizedTabset(fromNode.getWindowId())) {
                        const fromWindow = this.windows.get(fromNode.getWindowId())!;
                        fromWindow.maximizedTabSet = undefined;
                    }
                    const toNode = this.idMap.get(action.data.toNode) as Node & IDropTarget;
                    if (toNode instanceof TabSetNode || toNode instanceof BorderNode || toNode instanceof RowNode) {
                        toNode.drop(fromNode, DockLocation.getByName(action.data.location), action.data.index, action.data.select);
                    }
                }
                this.removeEmptyWindows();
                break;
            }
            case Actions.DELETE_TAB: {
                const node = this.idMap.get(action.data.node);
                if (node instanceof TabNode) {
                    node.delete();
                }
                this.removeEmptyWindows();
                break;
            }
            case Actions.DELETE_TABSET: {
                const node = this.idMap.get(action.data.node);

                if (node instanceof TabSetNode) {
                    // first delete all child tabs that are closeable
                    const children = [...node.getChildren()];
                    for (let i = 0; i < children.length; i++) {
                        const child = children[i];
                        if ((child as TabNode).isEnableClose()) {
                            (child as TabNode).delete();
                        }
                    }

                    if (node.getChildren().length === 0) {
                        node.delete();
                    }
                    this.tidy();
                }
                this.removeEmptyWindows();
                break;
            }
            case Actions.POPOUT_TABSET: {
                const node = this.idMap.get(action.data.node);
                if (node instanceof TabSetNode) {
                    const isMaximized = node.isMaximized();
                    const oldLayoutWindow = this.windows.get(node.getWindowId())!;
                    const windowId = randomUUID()
                    const layoutWindow = new LayoutWindow(windowId, oldLayoutWindow.toScreenRectFunction(node.getRect()));
                    const json = {
                        type: "row",
                        children: []
                    }
                    const row = RowNode.fromJson(json, this, layoutWindow);
                    layoutWindow.root = row;
                    this.windows.set(windowId, layoutWindow);
                    row.drop(node, DockLocation.CENTER, 0);

                    if (isMaximized) {
                        this.rootWindow.maximizedTabSet = undefined;
                    }
                }
                this.removeEmptyWindows();
                break;
            }
            case Actions.POPOUT_TAB: {
                const node = this.idMap.get(action.data.node);
                if (node instanceof TabNode) {
                    const windowId = randomUUID()
                    let r = Rect.empty();
                    if (node.getParent() instanceof TabSetNode) {
                        r = node.getParent()!.getRect();
                    } else  {
                        r = (node.getParent() as BorderNode).getContentRect();
                    }
                    const oldLayoutWindow = this.windows.get(node.getWindowId())!;
                    const layoutWindow = new LayoutWindow(windowId, oldLayoutWindow.toScreenRectFunction(r));
                    const tabsetId = randomUUID();
                    const json = {
                        type: "row",
                        children: [
                            { type: "tabset", id: tabsetId }
                        ]
                    }
                    const row = RowNode.fromJson(json, this, layoutWindow);
                    layoutWindow.root = row;
                    this.windows.set(windowId, layoutWindow);

                    const tabset = this.idMap.get(tabsetId) as TabSetNode & IDropTarget;
                    tabset.drop(node, DockLocation.CENTER, 0, true);
                }
                this.removeEmptyWindows();
                break;
            }
            case Actions.CLOSE_WINDOW: {
                const window = this.windows.get(action.data.windowId);
                if (window) {
                    this.rootWindow.root?.drop(window?.root!, DockLocation.CENTER, -1);
                    this.rootWindow.visitNodes((node, level) => {
                        if (node instanceof RowNode) {
                            node.setWindowId(Model.MAIN_WINDOW_ID);
                        }
                    })

                    // this.getFirstTabSet().drop(window?.root!,DockLocation.CENTER, -1);

                    this.windows.delete(action.data.windowId);
                }
                break;
            }
            case Actions.CREATE_WINDOW: {
                const windowId = randomUUID();
                const layoutWindow = new LayoutWindow(windowId, Rect.fromJson(action.data.rect));
                const row = RowNode.fromJson(action.data.layout, this, layoutWindow);
                layoutWindow.root = row;
                this.windows.set(windowId, layoutWindow);
                returnVal = windowId;
                break;
            }
            case Actions.RENAME_TAB: {
                const node = this.idMap.get(action.data.node);
                if (node instanceof TabNode) {
                    node.setName(action.data.text);
                }
                break;
            }
            case Actions.SELECT_TAB: {
                const tabNode = this.idMap.get(action.data.tabNode);
                const windowId = action.data.windowId ? action.data.windowId : Model.MAIN_WINDOW_ID;
                const window = this.windows.get(windowId)!;
                if (tabNode instanceof TabNode) {
                    const parent = tabNode.getParent() as Node;
                    const pos = parent.getChildren().indexOf(tabNode);

                    if (parent instanceof BorderNode) {
                        if (parent.getSelected() === pos) {
                            parent.setSelected(-1);
                        } else {
                            parent.setSelected(pos);
                        }
                    } else if (parent instanceof TabSetNode) {
                        if (parent.getSelected() !== pos) {
                            parent.setSelected(pos);
                        }
                        window.activeTabSet = parent;
                    }
                }
                break;
            }
            case Actions.SET_ACTIVE_TABSET: {
                const windowId = action.data.windowId ? action.data.windowId : Model.MAIN_WINDOW_ID;
                const window = this.windows.get(windowId)!;
                if (action.data.tabsetNode === undefined) {
                    window.activeTabSet = undefined;
                } else {
                    const tabsetNode = this.idMap.get(action.data.tabsetNode);
                    if (tabsetNode instanceof TabSetNode) {
                        window.activeTabSet = tabsetNode;
                    }
                }
                break;
            }
            case Actions.ADJUST_WEIGHTS: {
                const row = this.idMap.get(action.data.nodeId) as RowNode;
                const c = row.getChildren();
                for (let i = 0; i < c.length; i++) {
                    const n = c[i] as TabSetNode | RowNode;
                    n.setWeight(action.data.weights[i]);
                }
                break;
            }
            case Actions.ADJUST_BORDER_SPLIT: {
                const node = this.idMap.get(action.data.node);
                if (node instanceof BorderNode) {
                    node.setSize(action.data.pos);
                }
                break;
            }
            case Actions.MAXIMIZE_TOGGLE: {
                const windowId = action.data.windowId ? action.data.windowId : Model.MAIN_WINDOW_ID;
                const window = this.windows.get(windowId)!;
                const node = this.idMap.get(action.data.node);
                if (node instanceof TabSetNode) {
                    if (node === window.maximizedTabSet) {
                        window.maximizedTabSet = undefined;
                    } else {
                        window.maximizedTabSet = node;
                        window.activeTabSet = node;
                    }
                }

                break;
            }
            case Actions.UPDATE_MODEL_ATTRIBUTES: {
                this.updateAttrs(action.data.json);
                break;
            }

            case Actions.UPDATE_NODE_ATTRIBUTES: {
                const node = this.idMap.get(action.data.node)!;
                node.updateAttrs(action.data.json);
                break;
            }
            default:
                break;
        }

        this.updateIdMap();

        for (const listener of this.changeListeners) {
            listener(action);
        }

        return returnVal;
    }



    /**
     * Get the currently active tabset node
     */
    getActiveTabset(windowId: string = Model.MAIN_WINDOW_ID) {
        const window = this.windows.get(windowId);
        if (window && window.activeTabSet && this.getNodeById(window.activeTabSet.getId())) {
            return window.activeTabSet;
        } else {
            return undefined;
        }
    }

    /**
     * Get the currently maximized tabset node
     */
    getMaximizedTabset(windowId: string = Model.MAIN_WINDOW_ID) {
        return this.windows.get(windowId)!.maximizedTabSet;
    }

    /**
     * Gets the root RowNode of the model
     * @returns {RowNode}
     */
    getRoot(windowId: string = Model.MAIN_WINDOW_ID) {
        return this.windows.get(windowId)!.root!;
    }

    isRootOrientationVertical() {
        return this.attributes.rootOrientationVertical as boolean;
    }

    isEnableRotateBorderIcons() {
        return this.attributes.enableRotateBorderIcons as boolean;
    }

    /**
     * Gets the
     * @returns {BorderSet|*}
     */
    getBorderSet() {
        return this.borders;
    }

    getwindowsMap() {
        return this.windows;
    }

    /**
     * Visits all the nodes in the model and calls the given function for each
     * @param fn a function that takes visited node and a integer level as parameters
     */
    visitNodes(fn: (node: Node, level: number) => void) {
        this.borders.forEachNode(fn);
        for (const [_, w] of this.windows) {
            w.root!.forEachNode(fn, 0);
        }
    }

    visitWindowNodes(windowId: string, fn: (node: Node, level: number) => void) {
        if (this.windows.has(windowId)) {
            if (windowId === Model.MAIN_WINDOW_ID) {
                this.borders.forEachNode(fn);
            }
            this.windows.get(windowId)!.visitNodes(fn);
        }
    }

    /**
     * Gets a node by its id
     * @param id the id to find
     */
    getNodeById(id: string): Node | undefined {
        return this.idMap.get(id);
    }

    /**
     * Finds the first/top left tab set of the given node.
     * @param node The top node you want to begin searching from, deafults to the root node
     * @returns The first Tab Set
     */
    getFirstTabSet(node = this.windows.get(Model.MAIN_WINDOW_ID)!.root as Node): TabSetNode {
        const child = node.getChildren()[0];
        if (child instanceof TabSetNode) {
            return child;
        }
        else {
            return this.getFirstTabSet(child);
        }
    }

    /**
 * Loads the model from the given json object
 * @param json the json model to load
 * @returns {Model} a new Model object
 */
    static fromJson(json: IJsonModel) {
        const model = new Model();
        Model.attributeDefinitions.fromJson(json.global, model.attributes);

        if (json.borders) {
            model.borders = BorderSet.fromJson(json.borders, model);
        }
        if (json.popouts) {
            for (const windowId in json.popouts) {
                const windowJson = json.popouts[windowId];
                const layoutWindow = LayoutWindow.fromJson(windowJson!, model, windowId);
                model.windows.set(windowId, layoutWindow);
            }
        }

        model.rootWindow.root = RowNode.fromJson(json.layout, model, model.getwindowsMap().get(Model.MAIN_WINDOW_ID)!);
        model.tidy(); // initial tidy of node tree
        return model;
    }

    /**
     * Converts the model to a json object
     * @returns {IJsonModel} json object that represents this model
     */
    toJson(): IJsonModel {
        const global: any = {};
        Model.attributeDefinitions.toJson(global, this.attributes);

        // save state of nodes
        this.visitNodes((node) => {
            node.fireEvent("save", {});
        });

        const windows: Record<string, IJsonPopout> = {};
        for (const [id, window] of this.windows) {
            if (id !== Model.MAIN_WINDOW_ID) {
                windows[id] = window.toJson();
            }
        }

        return {
            global,
            borders: this.borders.toJson(),
            layout: this.rootWindow.root!.toJson(),
            popouts: windows
        };
    }

    getSplitterSize() {
        return this.attributes.splitterSize as number;
    }

    getSplitterExtra() {
        return this.attributes.splitterExtra as number;
    }

    isEnableEdgeDock() {
        return this.attributes.enableEdgeDock as boolean;
    }

    isSplitterEnableHandle() {
        return this.attributes.splitterEnableHandle as boolean;
    }

    /**
     * Sets a function to allow/deny dropping a node
     * @param onAllowDrop function that takes the drag node and DropInfo and returns true if the drop is allowed
     */
    setOnAllowDrop(onAllowDrop: (dragNode: Node, dropInfo: DropInfo) => boolean) {
        this.onAllowDrop = onAllowDrop;
    }

    /**
     * set callback called when a new TabSet is created.
     * The tabNode can be undefined if it's the auto created first tabset in the root row (when the last
     * tab is deleted, the root tabset can be recreated)
     * @param onCreateTabSet 
     */
    setOnCreateTabSet(onCreateTabSet: (tabNode?: TabNode) => ITabSetAttributes) {
        this.onCreateTabSet = onCreateTabSet;
    }
    
    addChangeListener(listener: ((action: Action) => void)) {
        this.changeListeners.push(listener);
    }

    removeChangeListener(listener: ((action: Action) => void)) {
        const pos = this.changeListeners.findIndex(l => l === listener);
        if (pos !== -1) {
            this.changeListeners.splice(pos, 1);
        }
    }

    toString() {
        return JSON.stringify(this.toJson());
    }

    /***********************internal ********************************/

    /** @internal */
    removeEmptyWindows() {
        const emptyWindows = new Set<string>();
        for (const [windowId] of this.windows) {
            if (windowId !== Model.MAIN_WINDOW_ID) {
                let count = 0;
                this.visitWindowNodes(windowId, (node) => {
                    if (node instanceof TabNode) {
                        count++;
                    }
                });
                if (count === 0) {
                    emptyWindows.add(windowId);
                }
            }
        }

        for (const windowId of emptyWindows) {
            this.windows.delete(windowId);
        }
    }
    /** @internal */
    setActiveTabset(tabsetNode: TabSetNode | undefined, windowId: string) {
        const window = this.windows.get(windowId);
        if (window) {
            if (tabsetNode) {
                window.activeTabSet = tabsetNode;
            } else {
                window.activeTabSet = undefined;
            }
        }
    }

    /** @internal */
    setMaximizedTabset(tabsetNode: (TabSetNode | undefined), windowId: string) {
        const window = this.windows.get(windowId);
        if (window) {
            if (tabsetNode) {
                window.maximizedTabSet = tabsetNode;
            } else {
                window.maximizedTabSet = undefined;
            }
        }
    }

    /** @internal */
    updateIdMap() {
        // regenerate idMap to stop it building up
        this.idMap.clear();
        this.visitNodes((node) => {
            this.idMap.set(node.getId(), node)
            // if (node instanceof RowNode) {
            //     node.normalizeWeights();
            // }
        });
        // console.log(JSON.stringify(Object.keys(this._idMap)));
    }

    /** @internal */
    addNode(node: Node) {
        const id = node.getId();
        if (this.idMap.has(id)) {
            throw new Error(`Error: each node must have a unique id, duplicate id:${node.getId()}`);
        }

        this.idMap.set(id, node);
    }

    /** @internal */
    findDropTargetNode(windowId: string, dragNode: Node & IDraggable, x: number, y: number) {
        let node = (this.windows.get(windowId)!.root as RowNode).findDropTargetNode(windowId, dragNode, x, y);
        if (node === undefined && windowId === Model.MAIN_WINDOW_ID) {
            node = this.borders.findDropTargetNode(dragNode, x, y);
        }
        return node;
    }

    /** @internal */
    tidy() {
        // console.log("before _tidy", this.toString());
        for (const [_, window] of this.windows) {
            window.root!.tidy();
        }
        // console.log("after _tidy", this.toString());
    }

    /** @internal */
    updateAttrs(json: any) {
        Model.attributeDefinitions.update(json, this.attributes);
    }

    /** @internal */
    nextUniqueId() {
        return '#' + randomUUID();
    }

    /** @internal */
    getAttribute(name: string): any {
        return this.attributes[name];
    }

    /** @internal */
    getOnAllowDrop() {
        return this.onAllowDrop;
    }

    /** @internal */
    getOnCreateTabSet() {
        return this.onCreateTabSet;
    }

    static toTypescriptInterfaces() {
        Model.attributeDefinitions.pairAttributes("RowNode", RowNode.getAttributeDefinitions());
        Model.attributeDefinitions.pairAttributes("TabSetNode", TabSetNode.getAttributeDefinitions());
        Model.attributeDefinitions.pairAttributes("TabNode", TabNode.getAttributeDefinitions());
        Model.attributeDefinitions.pairAttributes("BorderNode", BorderNode.getAttributeDefinitions());

        let sb = [];
        sb.push(Model.attributeDefinitions.toTypescriptInterface("Global", undefined));
        sb.push(RowNode.getAttributeDefinitions().toTypescriptInterface("Row", Model.attributeDefinitions));
        sb.push(TabSetNode.getAttributeDefinitions().toTypescriptInterface("TabSet", Model.attributeDefinitions));
        sb.push(TabNode.getAttributeDefinitions().toTypescriptInterface("Tab", Model.attributeDefinitions));
        sb.push(BorderNode.getAttributeDefinitions().toTypescriptInterface("Border", Model.attributeDefinitions));
        console.log(sb.join("\n"));
    }

    /** @internal */
    private static createAttributeDefinitions(): AttributeDefinitions {
        const attributeDefinitions = new AttributeDefinitions();

        attributeDefinitions.add("enableEdgeDock", true).setType(Attribute.BOOLEAN).setDescription(
            `enable docking to the edges of the layout, this will show the edge indicators`
        );
        attributeDefinitions.add("rootOrientationVertical", false).setType(Attribute.BOOLEAN).setDescription(
            `the top level 'row' will layout horizontally by default, set this option true to make it layout vertically`
        );
        attributeDefinitions.add("enableRotateBorderIcons", true).setType(Attribute.BOOLEAN).setDescription(
            `boolean indicating if tab icons should rotate with the text in the left and right borders`
        );

        // splitter
        attributeDefinitions.add("splitterSize", 8).setType(Attribute.NUMBER).setDescription(
            `width in pixels of all splitters between tabsets/borders`
        );
        attributeDefinitions.add("splitterExtra", 0).setType(Attribute.NUMBER).setDescription(
            `additional width in pixels of the splitter hit test area`
        );
        attributeDefinitions.add("splitterEnableHandle", false).setType(Attribute.BOOLEAN).setDescription(
            `enable a small centralized handle on all splitters`
        );

        // tab
        attributeDefinitions.add("tabEnableClose", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabCloseType", 1).setType("ICloseType");
        attributeDefinitions.add("tabEnablePopout", false).setType(Attribute.BOOLEAN).setAlias("tabEnableFloat");
        attributeDefinitions.add("tabEnablePopoutIcon", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabEnablePopoutOverlay", false).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabEnableDrag", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabEnableRename", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabContentClassName", undefined).setType(Attribute.STRING);
        attributeDefinitions.add("tabClassName", undefined).setType(Attribute.STRING);
        attributeDefinitions.add("tabIcon", undefined).setType(Attribute.STRING);
        attributeDefinitions.add("tabEnableRenderOnDemand", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabDragSpeed", 0.3).setType(Attribute.NUMBER);
        attributeDefinitions.add("tabBorderWidth", -1).setType(Attribute.NUMBER);
        attributeDefinitions.add("tabBorderHeight", -1).setType(Attribute.NUMBER);

        // tabset
        attributeDefinitions.add("tabSetEnableDeleteWhenEmpty", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabSetEnableDrop", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabSetEnableDrag", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabSetEnableDivide", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabSetEnableMaximize", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabSetEnableClose", false).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabSetEnableSingleTabStretch", false).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabSetAutoSelectTab", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabSetEnableActiveIcon", false).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabSetClassNameTabStrip", undefined).setType(Attribute.STRING);
        attributeDefinitions.add("tabSetEnableTabStrip", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabSetEnableTabWrap", false).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("tabSetTabLocation", "top").setType("ITabLocation");
        attributeDefinitions.add("tabMinWidth", DefaultMin).setType(Attribute.NUMBER);
        attributeDefinitions.add("tabMinHeight", DefaultMin).setType(Attribute.NUMBER);
        attributeDefinitions.add("tabSetMinWidth", DefaultMin).setType(Attribute.NUMBER);
        attributeDefinitions.add("tabSetMinHeight", DefaultMin).setType(Attribute.NUMBER);
        attributeDefinitions.add("tabMaxWidth", DefaultMax).setType(Attribute.NUMBER);
        attributeDefinitions.add("tabMaxHeight", DefaultMax).setType(Attribute.NUMBER);
        attributeDefinitions.add("tabSetMaxWidth", DefaultMax).setType(Attribute.NUMBER);
        attributeDefinitions.add("tabSetMaxHeight", DefaultMax).setType(Attribute.NUMBER);
        attributeDefinitions.add("tabSetEnableTabScrollbar", false).setType(Attribute.BOOLEAN);

        // border
        attributeDefinitions.add("borderSize", 200).setType(Attribute.NUMBER);
        attributeDefinitions.add("borderMinSize", DefaultMin).setType(Attribute.NUMBER);
        attributeDefinitions.add("borderMaxSize", DefaultMax).setType(Attribute.NUMBER);
        attributeDefinitions.add("borderEnableDrop", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("borderAutoSelectTabWhenOpen", true).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("borderAutoSelectTabWhenClosed", false).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("borderClassName", undefined).setType(Attribute.STRING);
        attributeDefinitions.add("borderEnableAutoHide", false).setType(Attribute.BOOLEAN);
        attributeDefinitions.add("borderEnableTabScrollbar", false).setType(Attribute.BOOLEAN);

        return attributeDefinitions;
    }
}


```

## File: src/model/Action.ts

```typescript
export class Action {
    type: string;
    data: Record<string, any>;

    constructor(type: string, data: Record<string, any>) {
        this.type = type;
        this.data = data;
    }
}

```

## File: src/model/BorderSet.ts

```typescript
import { DockLocation } from "../DockLocation";
import { DropInfo } from "../DropInfo";
import { BorderNode } from "./BorderNode";
import { IDraggable } from "./IDraggable";
import { Model } from "./Model";
import { Node } from "./Node";

export class BorderSet {
    /** @internal */
    static fromJson(json: any, model: Model) {
        const borderSet = new BorderSet(model);
        borderSet.borders = json.map((borderJson: any) => BorderNode.fromJson(borderJson, model));
        for (const border of borderSet.borders) {
            borderSet.borderMap.set(border.getLocation(), border);
        }
        return borderSet;
    }
    /** @internal */
    private borders: BorderNode[];
    /** @internal */
    private borderMap: Map<DockLocation, BorderNode>;
    /** @internal */
    private layoutHorizontal: boolean;

    /** @internal */
    constructor(_model: Model) {
        this.borders = [];
        this.borderMap = new Map<DockLocation, BorderNode>();
        this.layoutHorizontal = true;
    }

    toJson() {
        return this.borders.map((borderNode) => borderNode.toJson());
    }

    /** @internal */
    getLayoutHorizontal () {
        return this.layoutHorizontal;
    }

    /** @internal */
    getBorders() {
        return this.borders;
    }

    /** @internal */
    getBorderMap() {
        return this.borderMap;
    }

    /** @internal */
    forEachNode(fn: (node: Node, level: number) => void) {
        for (const borderNode of this.borders) {
            fn(borderNode, 0);
            for (const node of borderNode.getChildren()) {
                node.forEachNode(fn, 1);
            }
        }
    }

        /** @internal */
        setPaths() {
            for (const borderNode of this.borders) {
                const path = "/border/" + borderNode.getLocation().getName();
                borderNode.setPath(path);
                let i = 0;
                for (const node of borderNode.getChildren()) {
                    node.setPath( path + "/t" + i);
                    i++;
                }
            }
        }


    /** @internal */
    findDropTargetNode(dragNode: Node & IDraggable, x: number, y: number): DropInfo | undefined {
        for (const border of this.borders) {
            if (border.isShowing()) {
                const dropInfo = border.canDrop(dragNode, x, y);
                if (dropInfo !== undefined) {
                    return dropInfo;
                }
            }
        }
        return undefined;
    }
}

```

## File: src/model/Actions.ts

```typescript
import { DockLocation } from "../DockLocation";
import { Action } from "./Action";
import { IJsonRect, IJsonRowNode } from "./IJsonModel";

/**
 * The Action creator class for FlexLayout model actions
 */
export class Actions {
    static ADD_NODE = "FlexLayout_AddNode";
    static MOVE_NODE = "FlexLayout_MoveNode";
    static DELETE_TAB = "FlexLayout_DeleteTab";
    static DELETE_TABSET = "FlexLayout_DeleteTabset";
    static RENAME_TAB = "FlexLayout_RenameTab";
    static SELECT_TAB = "FlexLayout_SelectTab";
    static SET_ACTIVE_TABSET = "FlexLayout_SetActiveTabset";
    static ADJUST_WEIGHTS = "FlexLayout_AdjustWeights";
    static ADJUST_BORDER_SPLIT = "FlexLayout_AdjustBorderSplit";
    static MAXIMIZE_TOGGLE = "FlexLayout_MaximizeToggle";
    static UPDATE_MODEL_ATTRIBUTES = "FlexLayout_UpdateModelAttributes";
    static UPDATE_NODE_ATTRIBUTES = "FlexLayout_UpdateNodeAttributes";
    static POPOUT_TAB = "FlexLayout_PopoutTab";
    static POPOUT_TABSET = "FlexLayout_PopoutTabset";
    static CLOSE_WINDOW = "FlexLayout_CloseWindow";
    static CREATE_WINDOW = "FlexLayout_CreateWindow";

    /**
     * Adds a tab node to the given tabset node
     * @param json the json for the new tab node e.g {type:"tab", component:"table"}
     * @param toNodeId the new tab node will be added to the tabset with this node id
     * @param location the location where the new tab will be added, one of the DockLocation enum values.
     * @param index for docking to the center this value is the index of the tab, use -1 to add to the end.
     * @param select (optional) whether to select the new tab, overriding autoSelectTab
     * @returns {Action} the action
     */
    static addNode(json: any, toNodeId: string, location: DockLocation, index: number, select?: boolean): Action {
        return new Action(Actions.ADD_NODE, {
            json,
            toNode: toNodeId,
            location: location.getName(),
            index,
            select,
        });
    }

    /**
     * Moves a node (tab or tabset) from one location to another
     * @param fromNodeId the id of the node to move
     * @param toNodeId the id of the node to receive the moved node
     * @param location the location where the moved node will be added, one of the DockLocation enum values.
     * @param index for docking to the center this value is the index of the tab, use -1 to add to the end.
     * @param select (optional) whether to select the moved tab(s) in new tabset, overriding autoSelectTab
     * @returns {Action} the action
     */
    static moveNode(fromNodeId: string, toNodeId: string, location: DockLocation, index: number, select?: boolean): Action {
        return new Action(Actions.MOVE_NODE, {
            fromNode: fromNodeId,
            toNode: toNodeId,
            location: location.getName(),
            index,
            select,
        });
    }

    /**
     * Deletes a tab node from the layout
     * @param tabNodeId the id of the tab node to delete
     * @returns {Action} the action
     */
    static deleteTab(tabNodeId: string): Action {
        return new Action(Actions.DELETE_TAB, { node: tabNodeId });
    }

    /**
     * Deletes a tabset node and all it's child tab nodes from the layout
     * @param tabsetNodeId the id of the tabset node to delete
     * @returns {Action} the action
     */
    static deleteTabset(tabsetNodeId: string): Action {
        return new Action(Actions.DELETE_TABSET, { node: tabsetNodeId });
    }

    /**
     * Change the given nodes tab text
     * @param tabNodeId the id of the node to rename
     * @param text the test of the tab
     * @returns {Action} the action
     */
    static renameTab(tabNodeId: string, text: string): Action {
        return new Action(Actions.RENAME_TAB, { node: tabNodeId, text });
    }

    /**
     * Selects the given tab in its parent tabset
     * @param tabNodeId the id of the node to set selected
     * @returns {Action} the action
     */
    static selectTab(tabNodeId: string): Action {
        return new Action(Actions.SELECT_TAB, { tabNode: tabNodeId });
    }

    /**
     * Set the given tabset node as the active tabset
     * @param tabsetNodeId the id of the tabset node to set as active
     * @returns {Action} the action
     */
    static setActiveTabset(tabsetNodeId: string | undefined, windowId?: string | undefined): Action {
        return new Action(Actions.SET_ACTIVE_TABSET, { tabsetNode: tabsetNodeId, windowId: windowId });
    }

    /**
     * Adjust the weights of a row, used when the splitter is moved
     * @param nodeId the row node whose childrens weights are being adjusted
     * @param weights an array of weights to be applied to the children 
     * @returns {Action} the action
     */
    static adjustWeights(nodeId: string, weights: number[]): Action {
        return new Action(Actions.ADJUST_WEIGHTS, {nodeId, weights});
    }

    static adjustBorderSplit(nodeId: string, pos: number): Action {
        return new Action(Actions.ADJUST_BORDER_SPLIT, { node: nodeId, pos });
    }

    /**
     * Maximizes the given tabset
     * @param tabsetNodeId the id of the tabset to maximize
     * @returns {Action} the action
     */
    static maximizeToggle(tabsetNodeId: string, windowId?: string | undefined): Action {
        return new Action(Actions.MAXIMIZE_TOGGLE, { node: tabsetNodeId, windowId: windowId });
    }

    /**
     * Updates the global model jsone attributes
     * @param attributes the json for the model attributes to update (merge into the existing attributes)
     * @returns {Action} the action
     */
    static updateModelAttributes(attributes: any): Action {
        return new Action(Actions.UPDATE_MODEL_ATTRIBUTES, { json: attributes });
    }

    /**
     * Updates the given nodes json attributes
     * @param nodeId the id of the node to update
     * @param attributes the json attributes to update (merge with the existing attributes)
     * @returns {Action} the action
     */
    static updateNodeAttributes(nodeId: string, attributes: any): Action {
        return new Action(Actions.UPDATE_NODE_ATTRIBUTES, { node: nodeId, json: attributes });
    }

    /**
     * Pops out the given tab node into a new browser window
     * @param nodeId the tab node to popout
     * @returns 
     */
    static popoutTab(nodeId: string): Action {
        return new Action(Actions.POPOUT_TAB, { node: nodeId });
    }

    /**
     * Pops out the given tab set node into a new browser window
     * @param nodeId the tab set node to popout
     * @returns 
     */
    static popoutTabset(nodeId: string): Action {
        return new Action(Actions.POPOUT_TABSET, { node: nodeId });
    }

    /**
     * Closes the popout window
     * @param windowId the id of the popout window to close
     * @returns 
     */
    static closeWindow(windowId: string): Action {
        return new Action(Actions.CLOSE_WINDOW, { windowId });
    }

    /**
     * Creates a new empty popout window with the given layout
     * @param layout the json layout for the new window
     * @param rect the window rectangle in screen coordinates
     * @returns 
     */
    static createWindow(layout: IJsonRowNode, rect: IJsonRect): Action {
        return new Action(Actions.CREATE_WINDOW, { layout, rect});
    }
}

```

## File: src/model/IJsonModel.ts

```typescript
import { ICloseType } from "./ICloseType";
export type IBorderLocation = "top" | "bottom" | "left" | "right";
export type ITabLocation = "top" | "bottom";

export interface IJsonModel {
    global?: IGlobalAttributes;
    borders?: IJsonBorderNode[];
    layout: IJsonRowNode; // top level 'row' is horizontal, rows inside rows take opposite orientation to parent row (ie can act as columns)
	popouts?: Record<string, IJsonPopout>;
}

export interface IJsonRect {
	x: number;
	y: number;
	width: number;
	height: number;
}

export interface IJsonPopout {
    layout: IJsonRowNode;
	rect: IJsonRect ;
}

export interface IJsonBorderNode extends IBorderAttributes {
    location: IBorderLocation;
    children: IJsonTabNode[];
}

export interface IJsonRowNode extends IRowAttributes {
    children: (IJsonRowNode | IJsonTabSetNode)[];
}

export interface IJsonTabSetNode extends ITabSetAttributes {
	/** Marks this as the active tab set, read from initial json but 
	 * must subseqently be set on the model (only one tab set can be active)*/
    active?: boolean; 
	/** Marks this tab set as being maximized, read from initial json but 
	 * must subseqently be set on the model (only one tab set can be maximized) */
    maximized?: boolean; 
    children: IJsonTabNode[];
}

export interface IJsonTabNode extends ITabAttributes {
}

//----------------------------------------------------------------------------------------------------------
// below this line is autogenerated from attributes in code via Model static method toTypescriptInterfaces()
//----------------------------------------------------------------------------------------------------------
export interface IGlobalAttributes {
	/**
	  Value for BorderNode attribute autoSelectTabWhenClosed if not overridden

	  whether to select new/moved tabs in border when the border is currently closed

	  Default: false
	 */
	borderAutoSelectTabWhenClosed?: boolean;

	/**
	  Value for BorderNode attribute autoSelectTabWhenOpen if not overridden

	  whether to select new/moved tabs in border when the border is already open

	  Default: true
	 */
	borderAutoSelectTabWhenOpen?: boolean;

	/**
	  Value for BorderNode attribute className if not overridden

	  class applied to tab button

	  Default: undefined
	 */
	borderClassName?: string;

	/**
	  Value for BorderNode attribute enableAutoHide if not overridden

	  hide border if it has zero tabs

	  Default: false
	 */
	borderEnableAutoHide?: boolean;

	/**
	  Value for BorderNode attribute enableDrop if not overridden

	  whether tabs can be dropped into this border

	  Default: true
	 */
	borderEnableDrop?: boolean;

	/**
	  Value for BorderNode attribute enableTabScrollbar if not overridden

	  whether to show a mini scrollbar for the tabs

	  Default: false
	 */
	borderEnableTabScrollbar?: boolean;

	/**
	  Value for BorderNode attribute maxSize if not overridden

	  the maximum size of the tab area

	  Default: 99999
	 */
	borderMaxSize?: number;

	/**
	  Value for BorderNode attribute minSize if not overridden

	  the minimum size of the tab area

	  Default: 0
	 */
	borderMinSize?: number;

	/**
	  Value for BorderNode attribute size if not overridden

	  size of the tab area when selected

	  Default: 200
	 */
	borderSize?: number;

	/**
	  enable docking to the edges of the layout, this will show the edge indicators

	  Default: true
	 */
	enableEdgeDock?: boolean;

	/**
	  boolean indicating if tab icons should rotate with the text in the left and right borders

	  Default: true
	 */
	enableRotateBorderIcons?: boolean;

	/**
	  the top level 'row' will layout horizontally by default, set this option true to make it layout vertically

	  Default: false
	 */
	rootOrientationVertical?: boolean;

	/**
	  enable a small centralized handle on all splitters

	  Default: false
	 */
	splitterEnableHandle?: boolean;

	/**
	  additional width in pixels of the splitter hit test area

	  Default: 0
	 */
	splitterExtra?: number;

	/**
	  width in pixels of all splitters between tabsets/borders

	  Default: 8
	 */
	splitterSize?: number;

	/**
	  Value for TabNode attribute borderHeight if not overridden

	  height when added to border, -1 will use border size

	  Default: -1
	 */
	tabBorderHeight?: number;

	/**
	  Value for TabNode attribute borderWidth if not overridden

	  width when added to border, -1 will use border size

	  Default: -1
	 */
	tabBorderWidth?: number;

	/**
	  Value for TabNode attribute className if not overridden

	  class applied to tab button

	  Default: undefined
	 */
	tabClassName?: string;

	/**
	  Value for TabNode attribute closeType if not overridden

	  see values in ICloseType

	  Default: 1
	 */
	tabCloseType?: ICloseType;

	/**
	  Value for TabNode attribute contentClassName if not overridden

	  class applied to tab content

	  Default: undefined
	 */
	tabContentClassName?: string;

	/**
	  

	  Default: 0.3
	 */
	tabDragSpeed?: number;

	/**
	  Value for TabNode attribute enableClose if not overridden

	  allow user to close tab via close button

	  Default: true
	 */
	tabEnableClose?: boolean;

	/**
	  Value for TabNode attribute enableDrag if not overridden

	  allow user to drag tab to new location

	  Default: true
	 */
	tabEnableDrag?: boolean;

	/**
	  Value for TabNode attribute enablePopout if not overridden

	  enable popout (in popout capable browser)

	  Default: false
	 */
	tabEnablePopout?: boolean;

	/**
	  Value for TabNode attribute enablePopoutIcon if not overridden

	  whether to show the popout icon in the tabset header if this tab enables popouts

	  Default: true
	 */
	tabEnablePopoutIcon?: boolean;

	/**
	  Value for TabNode attribute enablePopoutOverlay if not overridden

	  if this tab will not work correctly in a popout window when the main window is backgrounded (inactive)
            then enabling this option will gray out this tab

	  Default: false
	 */
	tabEnablePopoutOverlay?: boolean;

	/**
	  Value for TabNode attribute enableRename if not overridden

	  allow user to rename tabs by double clicking

	  Default: true
	 */
	tabEnableRename?: boolean;

	/**
	  Value for TabNode attribute enableRenderOnDemand if not overridden

	  whether to avoid rendering component until tab is visible

	  Default: true
	 */
	tabEnableRenderOnDemand?: boolean;

	/**
	  Value for TabNode attribute icon if not overridden

	  the tab icon

	  Default: undefined
	 */
	tabIcon?: string;

	/**
	  Value for TabNode attribute maxHeight if not overridden

	  the max height of this tab

	  Default: 99999
	 */
	tabMaxHeight?: number;

	/**
	  Value for TabNode attribute maxWidth if not overridden

	  the max width of this tab

	  Default: 99999
	 */
	tabMaxWidth?: number;

	/**
	  Value for TabNode attribute minHeight if not overridden

	  the min height of this tab

	  Default: 0
	 */
	tabMinHeight?: number;

	/**
	  Value for TabNode attribute minWidth if not overridden

	  the min width of this tab

	  Default: 0
	 */
	tabMinWidth?: number;

	/**
	  Value for TabSetNode attribute autoSelectTab if not overridden

	  whether to select new/moved tabs in tabset

	  Default: true
	 */
	tabSetAutoSelectTab?: boolean;

	/**
	  Value for TabSetNode attribute classNameTabStrip if not overridden

	  a class name to apply to the tab strip

	  Default: undefined
	 */
	tabSetClassNameTabStrip?: string;

	/**
	  Value for TabSetNode attribute enableActiveIcon if not overridden

	  whether the active icon (*) should be displayed when the tabset is active

	  Default: false
	 */
	tabSetEnableActiveIcon?: boolean;

	/**
	  Value for TabSetNode attribute enableClose if not overridden

	  allow user to close tabset via a close button

	  Default: false
	 */
	tabSetEnableClose?: boolean;

	/**
	  Value for TabSetNode attribute enableDeleteWhenEmpty if not overridden

	  whether to delete this tabset when is has no tabs

	  Default: true
	 */
	tabSetEnableDeleteWhenEmpty?: boolean;

	/**
	  Value for TabSetNode attribute enableDivide if not overridden

	  allow user to drag tabs to region of this tabset, splitting into new tabset

	  Default: true
	 */
	tabSetEnableDivide?: boolean;

	/**
	  Value for TabSetNode attribute enableDrag if not overridden

	  allow user to drag tabs out this tabset

	  Default: true
	 */
	tabSetEnableDrag?: boolean;

	/**
	  Value for TabSetNode attribute enableDrop if not overridden

	  allow user to drag tabs into this tabset

	  Default: true
	 */
	tabSetEnableDrop?: boolean;

	/**
	  Value for TabSetNode attribute enableMaximize if not overridden

	  allow user to maximize tabset to fill view via maximize button

	  Default: true
	 */
	tabSetEnableMaximize?: boolean;

	/**
	  Value for TabSetNode attribute enableSingleTabStretch if not overridden

	  if the tabset has only a single tab then stretch the single tab to fill area and display in a header style

	  Default: false
	 */
	tabSetEnableSingleTabStretch?: boolean;

	/**
	  Value for TabSetNode attribute enableTabScrollbar if not overridden

	  whether to show a mini scrollbar for the tabs

	  Default: false
	 */
	tabSetEnableTabScrollbar?: boolean;

	/**
	  Value for TabSetNode attribute enableTabStrip if not overridden

	  enable tab strip and allow multiple tabs in this tabset

	  Default: true
	 */
	tabSetEnableTabStrip?: boolean;

	/**
	  Value for TabSetNode attribute enableTabWrap if not overridden

	  wrap tabs onto multiple lines

	  Default: false
	 */
	tabSetEnableTabWrap?: boolean;

	/**
	  Value for TabSetNode attribute maxHeight if not overridden

	  maximum height (in px) for this tabset

	  Default: 99999
	 */
	tabSetMaxHeight?: number;

	/**
	  Value for TabSetNode attribute maxWidth if not overridden

	  maximum width (in px) for this tabset

	  Default: 99999
	 */
	tabSetMaxWidth?: number;

	/**
	  Value for TabSetNode attribute minHeight if not overridden

	  minimum height (in px) for this tabset

	  Default: 0
	 */
	tabSetMinHeight?: number;

	/**
	  Value for TabSetNode attribute minWidth if not overridden

	  minimum width (in px) for this tabset

	  Default: 0
	 */
	tabSetMinWidth?: number;

	/**
	  Value for TabSetNode attribute tabLocation if not overridden

	  the location of the tabs either top or bottom

	  Default: "top"
	 */
	tabSetTabLocation?: ITabLocation;

}
export interface IRowAttributes {
	/**
	  the unique id of the row, if left undefined a uuid will be assigned

	  Default: undefined
	 */
	id?: string;

	/**
	  

	  Fixed value: "row"
	 */
	type?: string;

	/**
	  relative weight for sizing of this row in parent row

	  Default: 100
	 */
	weight?: number;

}
export interface ITabSetAttributes {
	/**
	  whether to select new/moved tabs in tabset

	  Default: inherited from Global attribute tabSetAutoSelectTab (default true)
	 */
	autoSelectTab?: boolean;

	/**
	  a class name to apply to the tab strip

	  Default: inherited from Global attribute tabSetClassNameTabStrip (default undefined)
	 */
	classNameTabStrip?: string;

	/**
	  a place to hold json config used in your own code

	  Default: undefined
	 */
	config?: any;

	/**
	  whether the active icon (*) should be displayed when the tabset is active

	  Default: inherited from Global attribute tabSetEnableActiveIcon (default false)
	 */
	enableActiveIcon?: boolean;

	/**
	  allow user to close tabset via a close button

	  Default: inherited from Global attribute tabSetEnableClose (default false)
	 */
	enableClose?: boolean;

	/**
	  whether to delete this tabset when is has no tabs

	  Default: inherited from Global attribute tabSetEnableDeleteWhenEmpty (default true)
	 */
	enableDeleteWhenEmpty?: boolean;

	/**
	  allow user to drag tabs to region of this tabset, splitting into new tabset

	  Default: inherited from Global attribute tabSetEnableDivide (default true)
	 */
	enableDivide?: boolean;

	/**
	  allow user to drag tabs out this tabset

	  Default: inherited from Global attribute tabSetEnableDrag (default true)
	 */
	enableDrag?: boolean;

	/**
	  allow user to drag tabs into this tabset

	  Default: inherited from Global attribute tabSetEnableDrop (default true)
	 */
	enableDrop?: boolean;

	/**
	  allow user to maximize tabset to fill view via maximize button

	  Default: inherited from Global attribute tabSetEnableMaximize (default true)
	 */
	enableMaximize?: boolean;

	/**
	  if the tabset has only a single tab then stretch the single tab to fill area and display in a header style

	  Default: inherited from Global attribute tabSetEnableSingleTabStretch (default false)
	 */
	enableSingleTabStretch?: boolean;

	/**
	  whether to show a mini scrollbar for the tabs

	  Default: inherited from Global attribute tabSetEnableTabScrollbar (default false)
	 */
	enableTabScrollbar?: boolean;

	/**
	  enable tab strip and allow multiple tabs in this tabset

	  Default: inherited from Global attribute tabSetEnableTabStrip (default true)
	 */
	enableTabStrip?: boolean;

	/**
	  wrap tabs onto multiple lines

	  Default: inherited from Global attribute tabSetEnableTabWrap (default false)
	 */
	enableTabWrap?: boolean;

	/**
	  the unique id of the tab set, if left undefined a uuid will be assigned

	  Default: undefined
	 */
	id?: string;

	/**
	  maximum height (in px) for this tabset

	  Default: inherited from Global attribute tabSetMaxHeight (default 99999)
	 */
	maxHeight?: number;

	/**
	  maximum width (in px) for this tabset

	  Default: inherited from Global attribute tabSetMaxWidth (default 99999)
	 */
	maxWidth?: number;

	/**
	  minimum height (in px) for this tabset

	  Default: inherited from Global attribute tabSetMinHeight (default 0)
	 */
	minHeight?: number;

	/**
	  minimum width (in px) for this tabset

	  Default: inherited from Global attribute tabSetMinWidth (default 0)
	 */
	minWidth?: number;

	/**
	  

	  Default: undefined
	 */
	name?: string;

	/**
	  index of selected/visible tab in tabset

	  Default: 0
	 */
	selected?: number;

	/**
	  the location of the tabs either top or bottom

	  Default: inherited from Global attribute tabSetTabLocation (default "top")
	 */
	tabLocation?: ITabLocation;

	/**
	  

	  Fixed value: "tabset"
	 */
	type?: string;

	/**
	  relative weight for sizing of this tabset in parent row

	  Default: 100
	 */
	weight?: number;

}
export interface ITabAttributes {
	/**
	  if there is no name specifed then this value will be used in the overflow menu

	  Default: undefined
	 */
	altName?: string;

	/**
	  height when added to border, -1 will use border size

	  Default: inherited from Global attribute tabBorderHeight (default -1)
	 */
	borderHeight?: number;

	/**
	  width when added to border, -1 will use border size

	  Default: inherited from Global attribute tabBorderWidth (default -1)
	 */
	borderWidth?: number;

	/**
	  class applied to tab button

	  Default: inherited from Global attribute tabClassName (default undefined)
	 */
	className?: string;

	/**
	  see values in ICloseType

	  Default: inherited from Global attribute tabCloseType (default 1)
	 */
	closeType?: ICloseType;

	/**
	  string identifying which component to run (for factory)

	  Default: undefined
	 */
	component?: string;

	/**
	  a place to hold json config for the hosted component

	  Default: undefined
	 */
	config?: any;

	/**
	  class applied to tab content

	  Default: inherited from Global attribute tabContentClassName (default undefined)
	 */
	contentClassName?: string;

	/**
	  allow user to close tab via close button

	  Default: inherited from Global attribute tabEnableClose (default true)
	 */
	enableClose?: boolean;

	/**
	  allow user to drag tab to new location

	  Default: inherited from Global attribute tabEnableDrag (default true)
	 */
	enableDrag?: boolean;

	/**
	  enable popout (in popout capable browser)

	  Default: inherited from Global attribute tabEnablePopout (default false)
	 */
	enablePopout?: boolean;

	/**
	  whether to show the popout icon in the tabset header if this tab enables popouts

	  Default: inherited from Global attribute tabEnablePopoutIcon (default true)
	 */
	enablePopoutIcon?: boolean;

	/**
	  if this tab will not work correctly in a popout window when the main window is backgrounded (inactive)
            then enabling this option will gray out this tab

	  Default: inherited from Global attribute tabEnablePopoutOverlay (default false)
	 */
	enablePopoutOverlay?: boolean;

	/**
	  allow user to rename tabs by double clicking

	  Default: inherited from Global attribute tabEnableRename (default true)
	 */
	enableRename?: boolean;

	/**
	  whether to avoid rendering component until tab is visible

	  Default: inherited from Global attribute tabEnableRenderOnDemand (default true)
	 */
	enableRenderOnDemand?: boolean;

	/**
	  if enabled the tab will re-mount when popped out/in

	  Default: false
	 */
	enableWindowReMount?: boolean;

	/**
	  An optional help text for the tab to be displayed upon tab hover.

	  Default: undefined
	 */
	helpText?: string;

	/**
	  the tab icon

	  Default: inherited from Global attribute tabIcon (default undefined)
	 */
	icon?: string;

	/**
	  the unique id of the tab, if left undefined a uuid will be assigned

	  Default: undefined
	 */
	id?: string;

	/**
	  the max height of this tab

	  Default: inherited from Global attribute tabMaxHeight (default 99999)
	 */
	maxHeight?: number;

	/**
	  the max width of this tab

	  Default: inherited from Global attribute tabMaxWidth (default 99999)
	 */
	maxWidth?: number;

	/**
	  the min height of this tab

	  Default: inherited from Global attribute tabMinHeight (default 0)
	 */
	minHeight?: number;

	/**
	  the min width of this tab

	  Default: inherited from Global attribute tabMinWidth (default 0)
	 */
	minWidth?: number;

	/**
	  name of tab to be displayed in the tab button

	  Default: "[Unnamed Tab]"
	 */
	name?: string;

	/**
	  class applied to parent tabset when this is the only tab and it is stretched to fill the tabset

	  Default: undefined
	 */
	tabsetClassName?: string;

	/**
	  

	  Fixed value: "tab"
	 */
	type?: string;

}
export interface IBorderAttributes {
	/**
	  whether to select new/moved tabs in border when the border is currently closed

	  Default: inherited from Global attribute borderAutoSelectTabWhenClosed (default false)
	 */
	autoSelectTabWhenClosed?: boolean;

	/**
	  whether to select new/moved tabs in border when the border is already open

	  Default: inherited from Global attribute borderAutoSelectTabWhenOpen (default true)
	 */
	autoSelectTabWhenOpen?: boolean;

	/**
	  class applied to tab button

	  Default: inherited from Global attribute borderClassName (default undefined)
	 */
	className?: string;

	/**
	  a place to hold json config used in your own code

	  Default: undefined
	 */
	config?: any;

	/**
	  hide border if it has zero tabs

	  Default: inherited from Global attribute borderEnableAutoHide (default false)
	 */
	enableAutoHide?: boolean;

	/**
	  whether tabs can be dropped into this border

	  Default: inherited from Global attribute borderEnableDrop (default true)
	 */
	enableDrop?: boolean;

	/**
	  whether to show a mini scrollbar for the tabs

	  Default: inherited from Global attribute borderEnableTabScrollbar (default false)
	 */
	enableTabScrollbar?: boolean;

	/**
	  the maximum size of the tab area

	  Default: inherited from Global attribute borderMaxSize (default 99999)
	 */
	maxSize?: number;

	/**
	  the minimum size of the tab area

	  Default: inherited from Global attribute borderMinSize (default 0)
	 */
	minSize?: number;

	/**
	  index of selected/visible tab in border; -1 means no tab selected

	  Default: -1
	 */
	selected?: number;

	/**
	  show/hide this border

	  Default: true
	 */
	show?: boolean;

	/**
	  size of the tab area when selected

	  Default: inherited from Global attribute borderSize (default 200)
	 */
	size?: number;

	/**
	  

	  Fixed value: "border"
	 */
	type?: string;

}
```

## File: src/model/TabSetNode.ts

```typescript
import { Attribute } from "../Attribute";
import { AttributeDefinitions } from "../AttributeDefinitions";
import { DockLocation } from "../DockLocation";
import { DropInfo } from "../DropInfo";
import { Orientation } from "../Orientation";
import { Rect } from "../Rect";
import { CLASSES } from "../Types";
import { canDockToWindow } from "../view/Utils";
import { BorderNode } from "./BorderNode";
import { IDraggable } from "./IDraggable";
import { IDropTarget } from "./IDropTarget";
import { IJsonTabSetNode } from "./IJsonModel";
import { LayoutWindow } from "./LayoutWindow";
import { Model } from "./Model";
import { Node } from "./Node";
import { RowNode } from "./RowNode";
import { TabNode } from "./TabNode";
import { adjustSelectedIndex } from "./Utils";

export class TabSetNode extends Node implements IDraggable, IDropTarget {
    static readonly TYPE = "tabset";

    /** @internal */
    static fromJson(json: any, model: Model, layoutWindow: LayoutWindow) {
        const newLayoutNode = new TabSetNode(model, json);

        if (json.children != null) {
            for (const jsonChild of json.children) {
                const child = TabNode.fromJson(jsonChild, model);
                newLayoutNode.addChild(child);
            }
        }
        if (newLayoutNode.children.length === 0) {
            newLayoutNode.setSelected(-1);
        }

        if (json.maximized && json.maximized === true) {
            layoutWindow.maximizedTabSet = newLayoutNode;
        }

        if (json.active && json.active === true) {
            layoutWindow.activeTabSet = newLayoutNode;
        }

        return newLayoutNode;
    }
    /** @internal */
    private static attributeDefinitions: AttributeDefinitions = TabSetNode.createAttributeDefinitions();

    /** @internal */
    private tabStripRect: Rect = Rect.empty();
    /** @internal */
    private contentRect: Rect = Rect.empty();
    /** @internal */
    private calculatedMinHeight: number;
    /** @internal */
    private calculatedMinWidth: number;
    /** @internal */
    private calculatedMaxHeight: number;
    /** @internal */
    private calculatedMaxWidth: number;

    /** @internal */
    constructor(model: Model, json: any) {
        super(model);
        this.calculatedMinHeight = 0;
        this.calculatedMinWidth = 0;
        this.calculatedMaxHeight = 0;
        this.calculatedMaxWidth = 0;

        TabSetNode.attributeDefinitions.fromJson(json, this.attributes);
        model.addNode(this);
    }

    getName() {
        return this.getAttr("name") as string | undefined;
    }

    isEnableActiveIcon() {
        return this.getAttr("enableActiveIcon") as boolean;
    }

    getSelected() {
        const selected = this.attributes.selected;
        if (selected !== undefined) {
            return selected as number;
        }
        return -1;
    }

    getSelectedNode() {
        const selected = this.getSelected();
        if (selected !== -1) {
            return this.children[selected];
        }
        return undefined;
    }

    getWeight(): number {
        return this.getAttr("weight") as number;
    }

    getAttrMinWidth() {
        return (this.getAttr("minWidth") as number);
    }

    getAttrMinHeight() {
        return this.getAttr("minHeight") as number;
    }

    getMinWidth() {
        return this.calculatedMinWidth;
    }

    getMinHeight() {
        return this.calculatedMinHeight;
    }

    /** @internal */
    getMinSize(orientation: Orientation) {
        if (orientation === Orientation.HORZ) {
            return this.getMinWidth();
        } else {
            return this.getMinHeight();
        }
    }
    getAttrMaxWidth() {
        return (this.getAttr("maxWidth") as number);
    }

    getAttrMaxHeight() {
        return this.getAttr("maxHeight") as number;
    }

    getMaxWidth() {
        return this.calculatedMaxWidth;
    }

    getMaxHeight() {
        return this.calculatedMaxHeight;
    }

    /** @internal */
    getMaxSize(orientation: Orientation) {
        if (orientation === Orientation.HORZ) {
            return this.getMaxWidth();
        } else {
            return this.getMaxHeight();
        }
    }


    /**
     * Returns the config attribute that can be used to store node specific data that
     * WILL be saved to the json. The config attribute should be changed via the action Actions.updateNodeAttributes rather
     * than directly, for example:
     * this.state.model.doAction(
     *   FlexLayout.Actions.updateNodeAttributes(node.getId(), {config:myConfigObject}));
     */
    getConfig() {
        return this.attributes.config;
    }

    isMaximized() {
        return this.model.getMaximizedTabset(this.getWindowId()) === this;
    }

    isActive() {
        return this.model.getActiveTabset(this.getWindowId()) === this;
    }

    isEnableDeleteWhenEmpty() {
        return this.getAttr("enableDeleteWhenEmpty") as boolean;
    }

    isEnableDrop() {
        return this.getAttr("enableDrop") as boolean;
    }

    isEnableTabWrap() {
        return this.getAttr("enableTabWrap") as boolean;
    }

    isEnableDrag() {
        return this.getAttr("enableDrag") as boolean;
    }

    isEnableDivide() {
        return this.getAttr("enableDivide") as boolean;
    }

    isEnableMaximize() {
        return this.getAttr("enableMaximize") as boolean;
    }

    isEnableClose() {
        return this.getAttr("enableClose") as boolean;
    }

    isEnableSingleTabStretch() {
        return this.getAttr("enableSingleTabStretch") as boolean;
    }

    isEnableTabStrip() {
        return this.getAttr("enableTabStrip") as boolean;
    }

    isAutoSelectTab() {
        return this.getAttr("autoSelectTab") as boolean;
    }

    isEnableTabScrollbar() {
        return this.getAttr("enableTabScrollbar") as boolean;
    }

    getClassNameTabStrip() {
        return this.getAttr("classNameTabStrip") as string | undefined;
    }

    getTabLocation() {
        return this.getAttr("tabLocation") as string;
    }



    toJson(): IJsonTabSetNode {
        const json: any = {};
        TabSetNode.attributeDefinitions.toJson(json, this.attributes);
        json.children = this.children.map((child) => child.toJson());

        if (this.isActive()) {
            json.active = true;
        }

        if (this.isMaximized()) {
            json.maximized = true;
        }

        return json;
    }

    /** @internal */
    calcMinMaxSize() {
        this.calculatedMinHeight = this.getAttrMinHeight();
        this.calculatedMinWidth = this.getAttrMinWidth();
        this.calculatedMaxHeight = this.getAttrMaxHeight();
        this.calculatedMaxWidth = this.getAttrMaxWidth();
        for (const child of this.children) {
            const c = child as TabNode;
            this.calculatedMinWidth = Math.max(this.calculatedMinWidth, c.getMinWidth());
            this.calculatedMinHeight = Math.max(this.calculatedMinHeight, c.getMinHeight());
            this.calculatedMaxWidth = Math.min(this.calculatedMaxWidth, c.getMaxWidth());
            this.calculatedMaxHeight = Math.min(this.calculatedMaxHeight, c.getMaxHeight());
        }

        this.calculatedMinHeight += this.tabStripRect.height;
        this.calculatedMaxHeight += this.tabStripRect.height;
    }

    /** @internal */
    canMaximize() {
        if (this.isEnableMaximize()) {
            // always allow maximize toggle if already maximized
            if (this.getModel().getMaximizedTabset(this.getWindowId()) === this) {
                return true;
            }
            // only one tabset, so disable
            if (this.getParent() === this.getModel().getRoot(this.getWindowId()) && this.getModel().getRoot(this.getWindowId()).getChildren().length === 1) {
                return false;
            }
            return true;
        }
        return false;
    }

    /** @internal */
    setContentRect(rect: Rect) {
        this.contentRect = rect;
    }

    /** @internal */
    getContentRect() {
        return this.contentRect;
    }

    /** @internal */
    setTabStripRect(rect: Rect) {
        this.tabStripRect = rect;
    }
    /** @internal */
    setWeight(weight: number) {
        this.attributes.weight = weight;
    }

    /** @internal */
    setSelected(index: number) {
        this.attributes.selected = index;
    }

    getWindowId() {
        return (this.parent as RowNode).getWindowId();
    }

    /** @internal */
    canDrop(dragNode: Node & IDraggable, x: number, y: number): DropInfo | undefined {
        let dropInfo;

        if (dragNode === this) {
            const dockLocation = DockLocation.CENTER;
            const outlineRect = this.tabStripRect;
            dropInfo = new DropInfo(this, outlineRect!, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
        } else if (this.getWindowId() !== Model.MAIN_WINDOW_ID && !canDockToWindow(dragNode)) {
            return undefined;
        } else if (this.contentRect!.contains(x, y)) {
            let dockLocation = DockLocation.CENTER;
            if (this.model.getMaximizedTabset((this.parent as RowNode).getWindowId()) === undefined) {
                dockLocation = DockLocation.getLocation(this.contentRect!, x, y);
            }
            const outlineRect = dockLocation.getDockRect(this.rect);
            dropInfo = new DropInfo(this, outlineRect, dockLocation, -1, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
        } else if (this.tabStripRect != null && this.tabStripRect.contains(x, y)) {
            let r: Rect;
            let yy: number;
            let h: number;
            if (this.children.length === 0) {
                r = this.tabStripRect.clone();
                yy = r.y + 3;
                h = r.height - 4;
                r.width = 2;
            } else {
                let child = this.children[0] as TabNode;
                r = child.getTabRect()!;
                yy = r.y;
                h = r.height;
                let p = this.tabStripRect.x;
                let childCenter = 0;
                for (let i = 0; i < this.children.length; i++) {
                    child = this.children[i] as TabNode;
                    r = child.getTabRect()!;
                    if (r.y !== yy) {
                        yy = r.y
                        p = this.tabStripRect.x;
                    }
                    childCenter = r.x + r.width / 2;
                    if (p <= x && x < childCenter && r.y < y && y < r.getBottom()) {
                        const dockLocation = DockLocation.CENTER;
                        const outlineRect = new Rect(r.x - 2, r.y, 3, r.height);
                        if (this.rect.x < r.x && r.x < this.rect.getRight()) {
                            dropInfo = new DropInfo(this, outlineRect, dockLocation, i, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
                            break;
                        } else {
                            return undefined;
                        }
                    }
                    p = childCenter;
                }
            }
            if (dropInfo == null && r.getRight() < this.rect!.getRight()) {
                const dockLocation = DockLocation.CENTER;
                const outlineRect = new Rect(r.getRight() - 2, yy, 3, h);
                dropInfo = new DropInfo(this, outlineRect, dockLocation, this.children.length, CLASSES.FLEXLAYOUT__OUTLINE_RECT);
            }
        }

        if (!dragNode.canDockInto(dragNode, dropInfo)) {
            return undefined;
        }

        return dropInfo;
    }

    /** @internal */
    delete() {
        (this.parent as RowNode).removeChild(this);
    }

    /** @internal */
    remove(node: TabNode) {
        const removedIndex = this.removeChild(node);
        this.model.tidy();

        adjustSelectedIndex(this, removedIndex);
    }

    /** @internal */
    drop(dragNode: Node, location: DockLocation, index: number, select?: boolean) {
        const dockLocation = location;

        if (this === dragNode) {
            // tabset drop into itself
            return; // dock back to itself
        }

        let dragParent = dragNode.getParent() as BorderNode | TabSetNode | RowNode;
        let fromIndex = 0;
        if (dragParent !== undefined) {
            fromIndex = dragParent.removeChild(dragNode);
            // if selected node in border is being docked into tabset then deselect border tabs
            if (dragParent instanceof BorderNode && dragParent.getSelected() === fromIndex) {
                dragParent.setSelected(-1);
            } else {
                adjustSelectedIndex(dragParent, fromIndex);
            }
        }

        // if dropping a tab back to same tabset and moving to forward position then reduce insertion index
        if (dragNode instanceof TabNode && dragParent === this && fromIndex < index && index > 0) {
            index--;
        }

        // simple_bundled dock to existing tabset
        if (dockLocation === DockLocation.CENTER) {
            let insertPos = index;
            if (insertPos === -1) {
                insertPos = this.children.length;
            }

            if (dragNode instanceof TabNode) {
                this.addChild(dragNode, insertPos);
                if (select || (select !== false && this.isAutoSelectTab())) {
                    this.setSelected(insertPos);
                }
                // console.log("added child at : " + insertPos);
            } else if (dragNode instanceof RowNode) {
                (dragNode as RowNode).forEachNode((child, level) => {
                    if (child instanceof TabNode) {
                        this.addChild(child, insertPos);
                        // console.log("added child at : " + insertPos);
                        insertPos++;
                    }
                }, 0);
            } else {
                for (let i = 0; i < dragNode.getChildren().length; i++) {
                    const child = dragNode.getChildren()[i];
                    this.addChild(child!, insertPos);
                    // console.log("added child at : " + insertPos);
                    insertPos++;
                }
                if (this.getSelected() === -1 && this.children.length > 0) {
                    this.setSelected(0);
                }
            }
            this.model.setActiveTabset(this, (this.parent as RowNode).getWindowId());
        } else {
            let moveNode = dragNode as TabSetNode | RowNode | TabNode;
            if (dragNode instanceof TabNode) {
                // create new tabset parent
                // console.log("create a new tabset");
                const callback = this.model.getOnCreateTabSet();
                moveNode = new TabSetNode(this.model, callback ? callback(dragNode as TabNode) : {});
                moveNode.addChild(dragNode);
                // console.log("added child at end");
                dragParent = moveNode;
            } else if (dragNode instanceof RowNode) {
                const parent = (this.getParent()! as RowNode);
                // need to turn round if same orientation unless docking oposite direction
                if (dragNode.getOrientation() === parent.getOrientation() &&
                    (location.getOrientation() === parent.getOrientation() || location === DockLocation.CENTER)) {
                    const node = new RowNode(this.model, this.getWindowId(), {});
                    node.addChild(dragNode);
                    moveNode = node;
                }
            } else {
                moveNode = dragNode as TabSetNode;
            }

            const parentRow = this.parent as Node;
            const pos = parentRow.getChildren().indexOf(this);

            if (parentRow.getOrientation() === dockLocation.orientation) {
                moveNode.setWeight(this.getWeight() / 2);
                this.setWeight(this.getWeight() / 2);
                // console.log("added child 50% size at: " +  pos + dockLocation.indexPlus);
                parentRow.addChild(moveNode, pos + dockLocation.indexPlus);
            } else {
                // create a new row to host the new tabset (it will go in the opposite direction)
                // console.log("create a new row");
                const newRow = new RowNode(this.model, this.getWindowId(), {});
                newRow.setWeight(this.getWeight());
                newRow.addChild(this);
                this.setWeight(50);
                moveNode.setWeight(50);
                // console.log("added child 50% size at: " +  dockLocation.indexPlus);
                newRow.addChild(moveNode, dockLocation.indexPlus);

                parentRow.removeChild(this);
                parentRow.addChild(newRow, pos);
            }
            if (moveNode instanceof TabSetNode) {
                this.model.setActiveTabset(moveNode, this.getWindowId());
            }
        }
        this.model.tidy();
    }

    /** @internal */
    updateAttrs(json: any) {
        TabSetNode.attributeDefinitions.update(json, this.attributes);
    }

    /** @internal */
    getAttributeDefinitions() {
        return TabSetNode.attributeDefinitions;
    }

    /** @internal */
    static getAttributeDefinitions() {
        return TabSetNode.attributeDefinitions;
    }

    /** @internal */
    private static createAttributeDefinitions(): AttributeDefinitions {
        const attributeDefinitions = new AttributeDefinitions();
        attributeDefinitions.add("type", TabSetNode.TYPE, true).setType(Attribute.STRING).setFixed();
        attributeDefinitions.add("id", undefined).setType(Attribute.STRING).setDescription(
            `the unique id of the tab set, if left undefined a uuid will be assigned`
        );
        attributeDefinitions.add("weight", 100).setType(Attribute.NUMBER).setDescription(
            `relative weight for sizing of this tabset in parent row`
        );
        attributeDefinitions.add("selected", 0).setType(Attribute.NUMBER).setDescription(
            `index of selected/visible tab in tabset`
        );
        attributeDefinitions.add("name", undefined).setType(Attribute.STRING);
        attributeDefinitions.add("config", undefined).setType("any").setDescription(
            `a place to hold json config used in your own code`
        );

        attributeDefinitions.addInherited("enableDeleteWhenEmpty", "tabSetEnableDeleteWhenEmpty").setDescription(
            `whether to delete this tabset when is has no tabs`
        );
        attributeDefinitions.addInherited("enableDrop", "tabSetEnableDrop").setDescription(
            `allow user to drag tabs into this tabset`
        );
        attributeDefinitions.addInherited("enableDrag", "tabSetEnableDrag").setDescription(
            `allow user to drag tabs out this tabset`
        );
        attributeDefinitions.addInherited("enableDivide", "tabSetEnableDivide").setDescription(
            `allow user to drag tabs to region of this tabset, splitting into new tabset`
        );
        attributeDefinitions.addInherited("enableMaximize", "tabSetEnableMaximize").setDescription(
            `allow user to maximize tabset to fill view via maximize button`
        );
        attributeDefinitions.addInherited("enableClose", "tabSetEnableClose").setDescription(
            `allow user to close tabset via a close button`
        );
        attributeDefinitions.addInherited("enableSingleTabStretch", "tabSetEnableSingleTabStretch").setDescription(
            `if the tabset has only a single tab then stretch the single tab to fill area and display in a header style`
        );

        attributeDefinitions.addInherited("classNameTabStrip", "tabSetClassNameTabStrip").setDescription(
            `a class name to apply to the tab strip`
        );
        attributeDefinitions.addInherited("enableTabStrip", "tabSetEnableTabStrip").setDescription(
            `enable tab strip and allow multiple tabs in this tabset`
        );
        attributeDefinitions.addInherited("minWidth", "tabSetMinWidth").setDescription(
            `minimum width (in px) for this tabset`
        );
        attributeDefinitions.addInherited("minHeight", "tabSetMinHeight").setDescription(
            `minimum height (in px) for this tabset`
        );
        attributeDefinitions.addInherited("maxWidth", "tabSetMaxWidth").setDescription(
            `maximum width (in px) for this tabset`
        );
        attributeDefinitions.addInherited("maxHeight", "tabSetMaxHeight").setDescription(
            `maximum height (in px) for this tabset`
        );

        attributeDefinitions.addInherited("enableTabWrap", "tabSetEnableTabWrap").setDescription(
            `wrap tabs onto multiple lines`
        );
        attributeDefinitions.addInherited("tabLocation", "tabSetTabLocation").setDescription(
            `the location of the tabs either top or bottom`
        );
        attributeDefinitions.addInherited("autoSelectTab", "tabSetAutoSelectTab").setType(Attribute.BOOLEAN).setDescription(
            `whether to select new/moved tabs in tabset`
        );
        attributeDefinitions.addInherited("enableActiveIcon", "tabSetEnableActiveIcon").setType(Attribute.BOOLEAN).setDescription(
            `whether the active icon (*) should be displayed when the tabset is active`
        );

        attributeDefinitions.addInherited("enableTabScrollbar", "tabSetEnableTabScrollbar").setType(Attribute.BOOLEAN).setDescription(
            `whether to show a mini scrollbar for the tabs`
        );

        return attributeDefinitions;
    }

}



```

## File: src/view/BorderButton.tsx

```tsx
import * as React from "react";
import { I18nLabel } from "../I18nLabel";
import { Actions } from "../model/Actions";
import { TabNode } from "../model/TabNode";
import { IIcons, LayoutInternal } from "./Layout";
import { ICloseType } from "../model/ICloseType";
import { CLASSES } from "../Types";
import { getRenderStateEx, isAuxMouseEvent } from "./Utils";

/** @internal */
export interface IBorderButtonProps {
    layout: LayoutInternal;
    node: TabNode;
    selected: boolean;
    border: string;
    icons: IIcons;
    path: string;
}

/** @internal */
export const BorderButton = (props: IBorderButtonProps) => {
    const { layout, node, selected, border, icons, path } = props;
    const selfRef = React.useRef<HTMLDivElement | null>(null);
    const contentRef = React.useRef<HTMLInputElement | null>(null);

    const onDragStart = (event: React.DragEvent<HTMLElement>) => {
        if (node.isEnableDrag()) {
            event.stopPropagation();
            layout.setDragNode(event.nativeEvent, node as TabNode);
        } else {
            event.preventDefault();
        }
    };

    const onDragEnd = (event: React.DragEvent<HTMLElement>) => {
        event.stopPropagation();
        layout.clearDragMain();
    };

    const onAuxMouseClick = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        if (isAuxMouseEvent(event)) {
            layout.auxMouseClick(node, event);
        } 
    };

    const onContextMenu = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        layout.showContextMenu(node, event);
    };

    const onClick = () => {
        layout.doAction(Actions.selectTab(node.getId()));
    };

    // const onDoubleClick = (event: Event) => {
    //     // if (node.isEnableRename()) {
    //     //     onRename();
    //     // }
    // };

    // const onRename = () => {
    //     layout.setEditingTab(node);
    //     layout.getCurrentDocument()!.body.addEventListener("pointerdown", onEndEdit);
    // };

    const onEndEdit = (event: Event) => {
        if (event.target !== contentRef.current!) {
            layout.getCurrentDocument()!.body.removeEventListener("pointerdown", onEndEdit);
            layout.setEditingTab(undefined);
        }
    };

    const isClosable = () => {
        const closeType = node.getCloseType();
        if (selected || closeType === ICloseType.Always) {
            return true;
        }
        if (closeType === ICloseType.Visible) {
            // not selected but x should be visible due to hover
            if (window.matchMedia && window.matchMedia("(hover: hover) and (pointer: fine)").matches) {
                return true;
            }
        }
        return false;
    };

    const onClose = (event: React.MouseEvent<HTMLElement>) => {
        if (isClosable()) {
            layout.doAction(Actions.deleteTab(node.getId()));
        } else {
            onClick();
        }
    };

    const onClosePointerDown = (event: React.PointerEvent<HTMLElement>) => {
        event.stopPropagation();
    };

    React.useLayoutEffect(() => {
        node.setTabRect(layout.getBoundingClientRect(selfRef.current!));
        if (layout.getEditingTab() === node) {
            (contentRef.current! as HTMLInputElement).select();
        }
    });

    const onTextBoxPointerDown = (event: React.PointerEvent<HTMLInputElement>) => {
        event.stopPropagation();
    };

    const onTextBoxKeyPress = (event: React.KeyboardEvent<HTMLInputElement>) => {
        if (event.code === 'Escape') {
            // esc
            layout.setEditingTab(undefined);
        } else if (event.code === 'Enter') {
            // enter
            layout.setEditingTab(undefined);
            layout.doAction(Actions.renameTab(node.getId(), (event.target as HTMLInputElement).value));
        }
    };

    const cm = layout.getClassName;
    let classNames = cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON) + " " + cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON_ + border);

    if (selected) {
        classNames += " " + cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON__SELECTED);
    } else {
        classNames += " " + cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON__UNSELECTED);
    }

    if (node.getClassName() !== undefined) {
        classNames += " " + node.getClassName();
    }

    let iconAngle = 0;
    if (node.getModel().isEnableRotateBorderIcons() === false) {
        if (border === "left") {
            iconAngle = 90;
        } else if (border === "right") {
            iconAngle = -90;
        }
    }

    const renderState = getRenderStateEx(layout, node, iconAngle);

    let content = renderState.content ? (
        <div className={cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON_CONTENT)}>
            {renderState.content}
        </div>) : null;

    const leading = renderState.leading ? (
        <div className={cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON_LEADING)}>
            {renderState.leading}
        </div>) : null;

    if (layout.getEditingTab() === node) {
        content = (
            <input
                ref={contentRef}
                className={cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_TEXTBOX)}
                data-layout-path={path + "/textbox"}
                type="text"
                autoFocus={true}
                defaultValue={node.getName()}
                onKeyDown={onTextBoxKeyPress}
                onPointerDown={onTextBoxPointerDown}
            />
        );
    }

    if (node.isEnableClose()) {
        const closeTitle = layout.i18nName(I18nLabel.Close_Tab);
        renderState.buttons.push(
            <div
                key="close"
                data-layout-path={path + "/button/close"}
                title={closeTitle}
                className={cm(CLASSES.FLEXLAYOUT__BORDER_BUTTON_TRAILING)}
                onPointerDown={onClosePointerDown}
                onClick={onClose}>
                {(typeof icons.close === "function") ? icons.close(node) : icons.close}
            </div>
        );
    }

    return (
        <div
            ref={selfRef}
            data-layout-path={path}
            className={classNames}
            onClick={onClick}
            onAuxClick={onAuxMouseClick}
            onContextMenu={onContextMenu}
            title={node.getHelpText()}
            draggable={true}
            onDragStart={onDragStart}
            onDragEnd={onDragEnd}
        >
            {leading}
            {content}
            {renderState.buttons}
        </div>
    );
};

```

## File: src/view/Splitter.tsx

```tsx
import * as React from "react";
import { Actions } from "../model/Actions";
import { BorderNode } from "../model/BorderNode";
import { RowNode } from "../model/RowNode";
import { Orientation } from "../Orientation";
import { CLASSES } from "../Types";
import { LayoutInternal } from "./Layout";
import { enablePointerOnIFrames, isDesktop, startDrag } from "./Utils";
import { Rect } from "../Rect";

/** @internal */
export interface ISplitterProps {
    layout: LayoutInternal;
    node: RowNode | BorderNode;
    index: number;
    horizontal: boolean;
}

/** @internal */
export const Splitter = (props: ISplitterProps) => {
    const { layout, node, index, horizontal } = props;

    const [dragging, setDragging] = React.useState<boolean>(false);
    const selfRef = React.useRef<HTMLDivElement | null>(null);
    const extendedRef = React.useRef<HTMLDivElement | null>(null);
    const pBounds = React.useRef<number[]>([]);
    const outlineDiv = React.useRef<HTMLDivElement | undefined>(undefined);
    const handleDiv = React.useRef<HTMLDivElement | undefined>(undefined);
    const dragStartX = React.useRef<number>(0);
    const dragStartY = React.useRef<number>(0);
    const initalSizes = React.useRef<{ initialSizes: number[], sum: number, startPosition: number }>({ initialSizes: [], sum: 0, startPosition: 0 })
    // const throttleTimer = React.useRef<NodeJS.Timeout | undefined>(undefined);

    const size = node.getModel().getSplitterSize();
    let extra = node.getModel().getSplitterExtra();

    if (!isDesktop()) {
        // make hit test area on mobile at least 20px
        extra = Math.max(20, extra + size) - size;
    }

    React.useEffect(() => {
        // Android fix: must have passive touchstart handler to prevent default handling
        selfRef.current?.addEventListener("touchstart", onTouchStart, { passive: false });
        extendedRef.current?.addEventListener("touchstart", onTouchStart, { passive: false });
        return () => {
            selfRef.current?.removeEventListener("touchstart", onTouchStart);
            extendedRef.current?.removeEventListener("touchstart", onTouchStart);
        }
    }, []);

    const onTouchStart = (event: TouchEvent) => {
        event.preventDefault();
        event.stopImmediatePropagation();
    }

    const onPointerDown = (event: React.PointerEvent<HTMLElement>) => {
        event.stopPropagation();
        if (node instanceof RowNode) {
            initalSizes.current = node.getSplitterInitials(index);
        }

        enablePointerOnIFrames(false, layout.getCurrentDocument()!);
        startDrag(event.currentTarget.ownerDocument, event, onDragMove, onDragEnd, onDragCancel);

        pBounds.current = node.getSplitterBounds(index, true);
        const rootdiv = layout.getRootDiv();
        outlineDiv.current = layout.getCurrentDocument()!.createElement("div");
        outlineDiv.current.style.flexDirection = horizontal ? "row" : "column";
        outlineDiv.current.className = layout.getClassName(CLASSES.FLEXLAYOUT__SPLITTER_DRAG);
        outlineDiv.current.style.cursor = node.getOrientation() === Orientation.VERT ? "ns-resize" : "ew-resize";

        if (node.getModel().isSplitterEnableHandle()) {
            handleDiv.current = layout.getCurrentDocument()!.createElement("div");
            handleDiv.current.className = cm(CLASSES.FLEXLAYOUT__SPLITTER_HANDLE) + " " +
                (horizontal ? cm(CLASSES.FLEXLAYOUT__SPLITTER_HANDLE_HORZ) : cm(CLASSES.FLEXLAYOUT__SPLITTER_HANDLE_VERT));
            outlineDiv.current.appendChild(handleDiv.current);
        }

        const r = selfRef.current?.getBoundingClientRect()!;
        const rect = new Rect(
            r.x - layout.getDomRect()!.x,
            r.y - layout.getDomRect()!.y,
            r.width,
            r.height
        );

        dragStartX.current = event.clientX - r.x;
        dragStartY.current = event.clientY - r.y;

        rect.positionElement(outlineDiv.current);
        if (rootdiv) {
            rootdiv.appendChild(outlineDiv.current);
        }

        setDragging(true);
    };

    const onDragCancel = () => {
        const rootdiv = layout.getRootDiv();
        if (rootdiv && outlineDiv.current) {
            rootdiv.removeChild(outlineDiv.current as Element);
        }
        outlineDiv.current = undefined;
        setDragging(false);
    };

    const onDragMove = (x: number, y: number) => {

        if (outlineDiv.current) {
            const clientRect = layout.getDomRect();
            if (!clientRect) {
                return;
            }
            if (node.getOrientation() === Orientation.VERT) {
                outlineDiv.current!.style.top = getBoundPosition(y - clientRect.y - dragStartY.current) + "px";
            } else {
                outlineDiv.current!.style.left = getBoundPosition(x - clientRect.x - dragStartX.current) + "px";
            }

            if (layout.isRealtimeResize()) {
                updateLayout(true);
            }
        }
    };

    const onDragEnd = () => {
        if (outlineDiv.current) {
            updateLayout(false);

            const rootdiv = layout.getRootDiv();
            if (rootdiv && outlineDiv.current) {
                rootdiv.removeChild(outlineDiv.current as HTMLElement);
            }
            outlineDiv.current = undefined;
        }
        enablePointerOnIFrames(true, layout.getCurrentDocument()!);
        setDragging(false);
    };

    const updateLayout = (realtime: boolean) => {

        const redraw = () => {
            if (outlineDiv.current) {
                let value = 0;
                if (node.getOrientation() === Orientation.VERT) {
                    value = outlineDiv.current!.offsetTop;
                } else {
                    value = outlineDiv.current!.offsetLeft;
                }


                if (node instanceof BorderNode) {
                    const pos = (node as BorderNode).calculateSplit(node, value);
                    layout.doAction(Actions.adjustBorderSplit(node.getId(), pos));
                } else {
                    const init = initalSizes.current;
                    const weights = node.calculateSplit(index, value, init.initialSizes, init.sum, init.startPosition);
                    layout.doAction(Actions.adjustWeights(node.getId(), weights));
                }
            }
        };

        redraw();
    };

    const getBoundPosition = (p: number) => {
        const bounds = pBounds.current as number[];
        let rtn = p;
        if (p < bounds[0]!) {
            rtn = bounds[0]!;
        }
        if (p > bounds[1]!) {
            rtn = bounds[1]!;
        }

        return rtn;
    };

    const cm = layout.getClassName;
    const style: Record<string, any> = {
        cursor: horizontal ? "ew-resize" : "ns-resize",
        flexDirection: horizontal ? "column" : "row"
    };
    let className = cm(CLASSES.FLEXLAYOUT__SPLITTER) + " " + cm(CLASSES.FLEXLAYOUT__SPLITTER_ + node.getOrientation().getName());

    if (node instanceof BorderNode) {
        className += " " + cm(CLASSES.FLEXLAYOUT__SPLITTER_BORDER);
    } else {
        if (node.getModel().getMaximizedTabset(layout.getWindowId()) !== undefined) {
            style.display = "none";
        }
    }

    if (horizontal) {
        style.width = size + "px";
        style.minWidth = size + "px";
    } else {
        style.height = size + "px";
        style.minHeight = size + "px";
    }

    let handle;
    if (!dragging && node.getModel().isSplitterEnableHandle()) {
        handle = (
            <div
                className={cm(CLASSES.FLEXLAYOUT__SPLITTER_HANDLE) + " " +
                    (horizontal ? cm(CLASSES.FLEXLAYOUT__SPLITTER_HANDLE_HORZ) : cm(CLASSES.FLEXLAYOUT__SPLITTER_HANDLE_VERT))
                }>
            </div>
        );
    }

    if (extra === 0) {
        return (<div
            className={className}
            style={style}
            ref={selfRef}
            data-layout-path={node.getPath() + "/s" + (index - 1)}
            onPointerDown={onPointerDown}>
            {handle}
        </div>);
    } else {
        // add extended transparent div for hit testing

        const style2: Record<string, any> = {};
        if (node.getOrientation() === Orientation.HORZ) {
            style2.height = "100%";
            style2.width = size + extra + "px";
            style2.cursor = "ew-resize";
        } else {
            style2.height = size + extra + "px";
            style2.width = "100%";
            style2.cursor = "ns-resize";
        }

        const className2 = cm(CLASSES.FLEXLAYOUT__SPLITTER_EXTRA);

        return (
            <div
                className={className}
                style={style}
                ref={selfRef}
                data-layout-path={node.getPath() + "/s" + (index - 1)}
                onPointerDown={onPointerDown}
            >
                <div
                    style={style2}
                    ref={extendedRef}
                    className={className2}
                    onPointerDown={onPointerDown}>
                </div>
            </div>);
    }
};


```

## File: src/view/BorderTab.tsx

```tsx
import * as React from "react";
import { Orientation } from "../Orientation";
import { LayoutInternal } from "./Layout";
import { BorderNode } from "../model/BorderNode";
import { Rect } from "../Rect";
import { Splitter } from "./Splitter";
import { DockLocation } from "../DockLocation";
import { CLASSES } from "../Types";

/** @internal */
export interface IBorderTabProps {
    layout: LayoutInternal;
    border: BorderNode;
    show: boolean;
}

export function BorderTab(props: IBorderTabProps) {
    const { layout, border, show } = props;
    const selfRef = React.useRef<HTMLDivElement | null>(null);

    React.useLayoutEffect(() => {
        const outerRect = layout.getBoundingClientRect(selfRef.current!);
        const contentRect = Rect.getContentRect(selfRef.current!).relativeTo(layout.getDomRect()!);
        if (outerRect.width > 0) {
            border.setOuterRect(outerRect);
            if (!border.getContentRect().equals(contentRect)) {
                border.setContentRect(contentRect);
                layout.redrawInternal("border content rect");
            }
        }

    });

    let horizontal = true;
    const style: Record<string, any> = {};

    if (border.getOrientation() === Orientation.HORZ) {
        style.width = border.getSize();
        style.minWidth = border.getMinSize();
        style.maxWidth = border.getMaxSize();
    } else {
        style.height = border.getSize();
        style.minHeight = border.getMinSize();
        style.maxHeight = border.getMaxSize();
        horizontal = false;
    }

    style.display = show ? "flex":"none";

    const className = layout.getClassName(CLASSES.FLEXLAYOUT__BORDER_TAB_CONTENTS);

    if (border.getLocation() === DockLocation.LEFT || border.getLocation() === DockLocation.TOP) {
        return (
            <>
                <div ref={selfRef} style={style} className={className}>
                </div>
                {show && <Splitter layout={layout} node={border} index={0}  horizontal={horizontal} />}
            </>
        );
    } else {
        return (
            <>
                {show && <Splitter layout={layout} node={border} index={0}  horizontal={horizontal} />}
                <div ref={selfRef} style={style}  className={className}>
                </div>
            </>
        );

    }
}
```

## File: src/view/Tab.tsx

```tsx
import * as React from "react";
import { TabNode } from "../model/TabNode";
import { TabSetNode } from "../model/TabSetNode";
import { CLASSES } from "../Types";
import { LayoutInternal } from "./Layout";
import { BorderNode } from "../model/BorderNode";
import { Actions } from "../model/Actions";

/** @internal */
export interface ITabProps {
    layout: LayoutInternal;
    node: TabNode;
    selected: boolean;
    path: string;
}

/** @internal */
export const Tab = (props: ITabProps) => {
    const { layout, selected, node, path } = props;
    const selfRef = React.useRef<HTMLDivElement | null>(null);
    const firstSelect = React.useRef<boolean>(true);

    const parentNode = node.getParent() as TabSetNode | BorderNode;
    const rect = parentNode.getContentRect()!;

    React.useLayoutEffect(() => {
        const element = node.getMoveableElement()!;
        selfRef.current!.appendChild(element);
        node.setMoveableElement(element);

        const handleScroll = () => {
            node.saveScrollPosition();
        };

        // keep scroll position
        element.addEventListener('scroll', handleScroll);

        // listen for clicks to change active tabset
        selfRef.current!.addEventListener("pointerdown", onPointerDown);

        return () => {
            element.removeEventListener('scroll', handleScroll);
            if (selfRef.current) {
                selfRef.current.removeEventListener("pointerdown", onPointerDown);
            }
            node.setVisible(false);
        }
    }, []);

    React.useEffect(() => {
        if (node.isSelected()) {
            if (firstSelect.current) {
                node.restoreScrollPosition(); // if window docked back in
                firstSelect.current = false;
            }
        }
    });

    const onPointerDown = () => {
        const parent = node.getParent()!; // cannot use parentNode here since will be out of date
        if (parent instanceof TabSetNode) {
            if (!parent.isActive()) {
                layout.doAction(Actions.setActiveTabset(parent.getId(), layout.getWindowId()));
            }
        }
    };

    node.setRect(rect); // needed for resize event
    const cm = layout.getClassName;
    const style: Record<string, any> = {};

    rect.styleWithPosition(style);

    let overlay = null;

    if (selected) {
        node.setVisible(true);
        if (document.hidden && node.isEnablePopoutOverlay()) {
            const overlayStyle: Record<string, any> = {};
            rect.styleWithPosition(overlayStyle);
            overlay = (<div style={overlayStyle} className={cm(CLASSES.FLEXLAYOUT__TAB_OVERLAY)}></div>)
        }
    } else {
        style.display = "none";
        node.setVisible(false);
    }

    if (parentNode instanceof TabSetNode) {
        if (node.getModel().getMaximizedTabset(layout.getWindowId()) !== undefined) {
            if (parentNode.isMaximized()) {
                style.zIndex = 10;
            } else {
                style.display = "none";
            }
        }
    }

    if (parentNode instanceof BorderNode) {
        if (!parentNode.isShowing()) {
            style.display = "none";
        }
    }

    let className = cm(CLASSES.FLEXLAYOUT__TAB);
    if (parentNode instanceof BorderNode) {
        className += " " + cm(CLASSES.FLEXLAYOUT__TAB_BORDER);
        className += " " + cm(CLASSES.FLEXLAYOUT__TAB_BORDER_ + parentNode.getLocation().getName());
    }

    if (node.getContentClassName() !== undefined) {
        className += " " + node.getContentClassName();
    }

    return (
        <>
            {overlay}

            <div
                ref={selfRef}
                style={style}
                className={className}
                data-layout-path={path}
            />
        </>
    );
};



```

## File: src/view/PopoutWindow.tsx

```tsx
import * as React from "react";
import { createPortal } from "react-dom";
import { CLASSES } from "../Types";
import { LayoutInternal } from "./Layout";
import { LayoutWindow } from "../model/LayoutWindow";

/** @internal */
export interface IPopoutWindowProps {
    title: string;
    layout: LayoutInternal;
    layoutWindow: LayoutWindow;
    url: string;
    onCloseWindow: (layoutWindow: LayoutWindow) => void;
    onSetWindow: (layoutWindow: LayoutWindow, window: Window) => void;
}

/** @internal */
export const PopoutWindow = (props: React.PropsWithChildren<IPopoutWindowProps>) => {
    const { title, layout, layoutWindow, url, onCloseWindow, onSetWindow, children } = props; const popoutWindow = React.useRef<Window | null>(null);
    const [content, setContent] = React.useState<HTMLElement | undefined>(undefined);
    // map from main docs style -> this docs equivalent style
    const styleMap = new Map<HTMLElement, HTMLElement>();       

    React.useLayoutEffect(() => {
        if (!popoutWindow.current) { // only create window once, even in strict mode
            const windowId = layoutWindow.windowId;
            const rect = layoutWindow.rect;
            
            popoutWindow.current = window.open(url, windowId, `left=${rect.x},top=${rect.y},width=${rect.width},height=${rect.height}`);

            if (popoutWindow.current) {
                layoutWindow.window = popoutWindow.current;
                onSetWindow(layoutWindow, popoutWindow.current);

                // listen for parent unloading to remove all popouts
                window.addEventListener("beforeunload", () => {
                    if (popoutWindow.current) {
                        const closedWindow = popoutWindow.current;
                        popoutWindow.current = null; // need to set to null before close, since this will trigger popup window before unload...
                        closedWindow.close();
                    }
                });

                popoutWindow.current.addEventListener("load", () => {
                    if (popoutWindow.current) {
                        popoutWindow.current.focus();

                        // note: resizeto must be before moveto in chrome otherwise the window will end up at 0,0
                        popoutWindow.current.resizeTo(rect.width, rect.height);
                        popoutWindow.current.moveTo(rect.x, rect.y);

                        const popoutDocument = popoutWindow.current.document;
                        popoutDocument.title = title;
                        const popoutContent = popoutDocument.createElement("div");
                        popoutContent.className = CLASSES.FLEXLAYOUT__FLOATING_WINDOW_CONTENT;
                        popoutDocument.body.appendChild(popoutContent);
                        copyStyles(popoutDocument, styleMap).then(() => {
                            setContent(popoutContent); // re-render once link styles loaded
                        });

                        // listen for style mutations
                        const observer = new MutationObserver((mutationsList: any) => handleStyleMutations(mutationsList, popoutDocument, styleMap));
                        observer.observe(document.head, { childList: true });

                        // listen for popout unloading (needs to be after load for safari)
                        popoutWindow.current.addEventListener("beforeunload", () => {
                            if (popoutWindow.current) {
                                onCloseWindow(layoutWindow); // remove the layoutWindow in the model
                                popoutWindow.current = null;
                                observer.disconnect();
                            }
                        });
                    }
                });
            } else {
                console.warn(`Unable to open window ${url}`);
                onCloseWindow(layoutWindow); // remove the layoutWindow in the model
            }
        }
        return () => {
            // only close popoutWindow if windowId has been removed from the model (ie this was due to model change)
            if (!layout.getModel().getwindowsMap().has(layoutWindow.windowId)) {
                popoutWindow.current?.close();
                popoutWindow.current = null;
            }
        }
    }, []);

    if (content !== undefined) {
        return createPortal(children, content!);
    } else {
        return null;
    }
};

function handleStyleMutations(mutationsList: any, popoutDocument: Document, styleMap: Map<HTMLElement, HTMLElement>) {
    for (const mutation of mutationsList) {
        if (mutation.type === 'childList') {
            for (const addition of mutation.addedNodes) {
                if (addition instanceof HTMLLinkElement || addition instanceof HTMLStyleElement) {
                    copyStyle(popoutDocument, addition, styleMap);
                }
            }
            for (const removal of mutation.removedNodes) {
                if (removal instanceof HTMLLinkElement || removal instanceof HTMLStyleElement) {
                    const popoutStyle = styleMap.get(removal);
                    if (popoutStyle) {
                        popoutDocument.head.removeChild(popoutStyle);
                    }
                }
            }
        }
    }
};



/** @internal */
function copyStyles(popoutDoc: Document, styleMap: Map<HTMLElement, HTMLElement>): Promise<boolean[]> {
    const promises: Promise<boolean>[] = [];
    const styleElements = document.querySelectorAll('style, link[rel="stylesheet"]') as NodeListOf<HTMLElement>
    for (const element of styleElements) {
        copyStyle(popoutDoc, element, styleMap, promises);
    }
    return Promise.all(promises);
}

/** @internal */
function copyStyle(popoutDoc: Document, element: HTMLElement, styleMap: Map<HTMLElement, HTMLElement>, promises?: Promise<boolean>[]) {
    if (element instanceof HTMLLinkElement) {
        // prefer links since they will keep paths to images etc
        const linkElement = element.cloneNode(true) as HTMLLinkElement;
        popoutDoc.head.appendChild(linkElement);
        styleMap.set(element, linkElement);

        if (promises) {
            promises.push(new Promise((resolve) => {
                linkElement.onload = () => resolve(true);
            }));
        }
    } else if (element instanceof HTMLStyleElement) {
        try {
            const styleElement = element.cloneNode(true) as HTMLStyleElement;
            popoutDoc.head.appendChild(styleElement);
            styleMap.set(element, styleElement);
        } catch (e) {
            // can throw an exception
        }
    }
}



```

## File: src/view/PopupMenu.tsx

```tsx
import * as React from "react";
import { TabNode } from "../model/TabNode";
import { CLASSES } from "../Types";
import { LayoutInternal } from "./Layout";
import { TabButtonStamp } from "./TabButtonStamp";
import { TabSetNode } from "../model/TabSetNode";
import { BorderNode } from "../model/BorderNode";
import { useEffect, useRef } from "react";

/** @internal */
export function showPopup(
    triggerElement: Element,
    parentNode: TabSetNode | BorderNode,
    items: { index: number; node: TabNode }[],
    onSelect: (item: { index: number; node: TabNode }) => void,
    layout: LayoutInternal,
) {
    const layoutDiv = layout.getRootDiv();
    const classNameMapper = layout.getClassName;
    const currentDocument = triggerElement.ownerDocument;
    const triggerRect = triggerElement.getBoundingClientRect();
    const layoutRect = layoutDiv?.getBoundingClientRect() ?? new DOMRect(0, 0, 100, 100);

    const elm = currentDocument.createElement("div");
    elm.className = classNameMapper(CLASSES.FLEXLAYOUT__POPUP_MENU_CONTAINER);
    if (triggerRect.left < layoutRect.left + layoutRect.width / 2) {
        elm.style.left = triggerRect.left - layoutRect.left + "px";
    } else {
        elm.style.right = layoutRect.right - triggerRect.right + "px";
    }

    if (triggerRect.top < layoutRect.top + layoutRect.height / 2) {
        elm.style.top = triggerRect.top - layoutRect.top + "px";
    } else {
        elm.style.bottom = layoutRect.bottom - triggerRect.bottom + "px";
    }

    layout.showOverlay(true);

    if (layoutDiv) {
        layoutDiv.appendChild(elm);
    }

    const onHide = () => {
        layout.hideControlInPortal();
        layout.showOverlay(false);
        if (layoutDiv) {
            layoutDiv.removeChild(elm);
        }
        elm.removeEventListener("pointerdown", onElementPointerDown);
        currentDocument.removeEventListener("pointerdown", onDocPointerDown);
    };

    const onElementPointerDown = (event: Event) => {
        event.stopPropagation();
    };

    const onDocPointerDown = (_event: Event) => {
        onHide();
    };

    elm.addEventListener("pointerdown", onElementPointerDown);
    currentDocument.addEventListener("pointerdown", onDocPointerDown);

    layout.showControlInPortal(<PopupMenu
        currentDocument={currentDocument}
        parentNode={parentNode}
        onSelect={onSelect}
        onHide={onHide}
        items={items}
        classNameMapper={classNameMapper}
        layout={layout}
    />, elm);
}

/** @internal */
interface IPopupMenuProps {
    parentNode: TabSetNode | BorderNode;
    items: { index: number; node: TabNode }[];
    currentDocument: Document;
    onHide: () => void;
    onSelect: (item: { index: number; node: TabNode }) => void;
    classNameMapper: (defaultClassName: string) => string;
    layout: LayoutInternal;
}

/** @internal */
const PopupMenu = (props: IPopupMenuProps) => {
    const { parentNode, items, onHide, onSelect, classNameMapper, layout } = props;
    const divRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        // Set focus when the component mounts
        if (divRef.current) {
            divRef.current.focus();
        }
    }, []);

    const onItemClick = (item: { index: number; node: TabNode }, event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        onSelect(item);
        onHide();
        event.stopPropagation();
    };

    const onDragStart = (event: React.DragEvent<HTMLElement>, node: TabNode) => {
        event.stopPropagation(); // prevent starting a tabset drag as well
        layout.setDragNode(event.nativeEvent, node as TabNode);
        setTimeout(() => {
            onHide();
        }, 0);

    };

    const onDragEnd = (event: React.DragEvent<HTMLElement>) => {
        layout.clearDragMain();
    };

    const handleKeyDown = (event: React.KeyboardEvent) => {
        if (event.key === "Escape") {
            onHide();
        }
    };

    const itemElements = items.map((item, i) => {
        let classes = classNameMapper(CLASSES.FLEXLAYOUT__POPUP_MENU_ITEM);
        if (parentNode.getSelected() === item.index) {
            classes += " " + classNameMapper(CLASSES.FLEXLAYOUT__POPUP_MENU_ITEM__SELECTED);
        }
        return (
            <div key={item.index}
                className={classes}
                data-layout-path={"/popup-menu/tb" + i}
                onClick={(event) => onItemClick(item, event)}
                draggable={true}
                onDragStart={(e) => onDragStart(e, item.node)}
                onDragEnd={onDragEnd}
                title={item.node.getHelpText()} >
                <TabButtonStamp
                    node={item.node}
                    layout={layout}
                />
            </div>
        )
    }
    );

    return (
        <div className={classNameMapper(CLASSES.FLEXLAYOUT__POPUP_MENU)}
            ref={divRef}
            tabIndex={0}  // Make div focusable
            onKeyDown={handleKeyDown}
            data-layout-path="/popup-menu"
        >
            {itemElements}
        </div>);
};

```

## File: src/view/BorderTabSet.tsx

```tsx
import * as React from "react";
import { DockLocation } from "../DockLocation";
import { BorderNode } from "../model/BorderNode";
import { TabNode } from "../model/TabNode";
import { BorderButton } from "./BorderButton";
import { LayoutInternal, ITabSetRenderValues } from "./Layout";
import { showPopup } from "./PopupMenu";
import { Actions } from "../model/Actions";
import { I18nLabel } from "../I18nLabel";
import { useTabOverflow } from "./TabOverflowHook";
import { Orientation } from "../Orientation";
import { CLASSES } from "../Types";
import { isAuxMouseEvent } from "./Utils";

/** @internal */
export interface IBorderTabSetProps {
    border: BorderNode;
    layout: LayoutInternal;
    size: number;
}

/** @internal */
export const BorderTabSet = (props: IBorderTabSetProps) => {
    const { border, layout, size } = props;

    const toolbarRef = React.useRef<HTMLDivElement | null>(null);
    const miniScrollRef = React.useRef<HTMLDivElement | null>(null);
    const overflowbuttonRef = React.useRef<HTMLButtonElement | null>(null);
    const stickyButtonsRef = React.useRef<HTMLDivElement | null>(null);
    const tabStripInnerRef = React.useRef<HTMLDivElement | null>(null);

    const icons = layout.getIcons();

    React.useLayoutEffect(() => {
        border.setTabHeaderRect(layout.getBoundingClientRect(selfRef.current!));
    });

    const { selfRef, userControlledPositionRef, onScroll, onScrollPointerDown, hiddenTabs, onMouseWheel, isDockStickyButtons, isShowHiddenTabs } =
        useTabOverflow(layout, border, Orientation.flip(border.getOrientation()), tabStripInnerRef, miniScrollRef,
            layout.getClassName(CLASSES.FLEXLAYOUT__BORDER_BUTTON)
        );

    const onAuxMouseClick = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        if (isAuxMouseEvent(event)) {
            layout.auxMouseClick(border, event);
        }
    };

    const onContextMenu = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        layout.showContextMenu(border, event);
    };

    const onInterceptPointerDown = (event: React.PointerEvent) => {
        event.stopPropagation();
    };

    const onOverflowClick = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        const callback = layout.getShowOverflowMenu();
        const items = hiddenTabs.map(h => { return { index: h, node: (border.getChildren()[h] as TabNode) }; });
        if (callback !== undefined) {

            callback(border, event, items, onOverflowItemSelect);
        } else {
            const element = overflowbuttonRef.current!;
            showPopup(
                element,
                border,
                items,
                onOverflowItemSelect,
                layout);
        }
        event.stopPropagation();
    };

    const onOverflowItemSelect = (item: { node: TabNode; index: number }) => {
        layout.doAction(Actions.selectTab(item.node.getId()));
        userControlledPositionRef.current = false;
    };

    const onPopoutTab = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        const selectedTabNode = border.getChildren()[border.getSelected()] as TabNode;
        if (selectedTabNode !== undefined) {
            layout.doAction(Actions.popoutTab(selectedTabNode.getId()));
        }
        event.stopPropagation();
    };

    const cm = layout.getClassName;

    const tabButtons: any = [];

    const layoutTab = (i: number) => {
        let isSelected = border.getSelected() === i;
        let child = border.getChildren()[i] as TabNode;

        tabButtons.push(
            <BorderButton
                layout={layout}
                border={border.getLocation().getName()}
                node={child}
                path={border.getPath() + "/tb" + i}
                key={child.getId()}
                selected={isSelected}
                icons={icons}
            />
        );
        if (i < border.getChildren().length - 1) {
            tabButtons.push(
                <div key={"divider" + i} className={cm(CLASSES.FLEXLAYOUT__BORDER_TAB_DIVIDER)}></div>
            );
        }
    };

    for (let i = 0; i < border.getChildren().length; i++) {
        layoutTab(i);
    }

    let borderClasses = cm(CLASSES.FLEXLAYOUT__BORDER) + " " + cm(CLASSES.FLEXLAYOUT__BORDER_ + border.getLocation().getName());
    if (border.getClassName() !== undefined) {
        borderClasses += " " + border.getClassName();
    }

    // allow customization of tabset right/bottom buttons
    let buttons: any[] = [];
    let stickyButtons: any[] = [];
    const renderState: ITabSetRenderValues = { buttons, stickyButtons: stickyButtons, overflowPosition: undefined };
    layout.customizeTabSet(border, renderState);
    buttons = renderState.buttons;

    if (renderState.overflowPosition === undefined) {
        renderState.overflowPosition = stickyButtons.length;
    }

    if (stickyButtons.length > 0) {
        if (isDockStickyButtons) {
            buttons = [...stickyButtons, ...buttons];
        } else {
            tabButtons.push(<div
                ref={stickyButtonsRef}
                key="sticky_buttons_container"
                onPointerDown={onInterceptPointerDown}
                onDragStart={(e) => { e.preventDefault() }}
                className={cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_STICKY_BUTTONS_CONTAINER)}
            >
                {stickyButtons}
            </div>);
        }
    }

    if (isShowHiddenTabs) {
        const overflowTitle = layout.i18nName(I18nLabel.Overflow_Menu_Tooltip);
        let overflowContent;
        if (typeof icons.more === "function") {
            const items = hiddenTabs.map(h => { return { index: h, node: (border.getChildren()[h] as TabNode) }; });

            overflowContent = icons.more(border, items);
        } else {
            overflowContent = (<>
                {icons.more}
                <div className={cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_OVERFLOW_COUNT)}>{hiddenTabs.length>0?hiddenTabs.length: ""}</div>
            </>);
        }
        buttons.splice(Math.min(renderState.overflowPosition, buttons.length), 0,
            <button
                key="overflowbutton"
                ref={overflowbuttonRef}
                className={cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON) + " " + cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_OVERFLOW) + " " + cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_OVERFLOW_ + border.getLocation().getName())}
                title={overflowTitle}
                onClick={onOverflowClick}
                onPointerDown={onInterceptPointerDown}
            >
                {overflowContent}
            </button>
        );
    }

    const selectedIndex = border.getSelected();
    if (selectedIndex !== -1) {
        const selectedTabNode = border.getChildren()[selectedIndex] as TabNode;
        if (selectedTabNode !== undefined && layout.isSupportsPopout() && selectedTabNode.isEnablePopout()) {
            const popoutTitle = layout.i18nName(I18nLabel.Popout_Tab);
            buttons.push(
                <button
                    key="popout"
                    title={popoutTitle}
                    className={cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON) + " " + cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_BUTTON_FLOAT)}
                    onClick={onPopoutTab}
                    onPointerDown={onInterceptPointerDown}
                >
                    {(typeof icons.popout === "function") ? icons.popout(selectedTabNode) : icons.popout}
                </button>
            );
        }
    }
    const toolbar = (
        <div key="toolbar" ref={toolbarRef} className={cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR) + " " + cm(CLASSES.FLEXLAYOUT__BORDER_TOOLBAR_ + border.getLocation().getName())}>
            {buttons}
        </div>
    );

    let innerStyle = {};
    let outerStyle = {};
    const borderHeight = size - 1;
    if (border.getLocation() === DockLocation.LEFT) {
        innerStyle = { right: "100%", top: 0 };
        outerStyle = { width: borderHeight, overflowY: "auto" };
    } else if (border.getLocation() === DockLocation.RIGHT) {
        innerStyle = { left: "100%", top: 0 };
        outerStyle = { width: borderHeight, overflowY: "auto" };
    } else {
        innerStyle = { left: 0 };
        outerStyle = { height: borderHeight, overflowX: "auto" };
    }

    let miniScrollbar = undefined;
    if (border.isEnableTabScrollbar()) {
        miniScrollbar = (
            <div ref={miniScrollRef}
                className={cm(CLASSES.FLEXLAYOUT__MINI_SCROLLBAR)}
                onPointerDown={onScrollPointerDown}
            />
        );
    }

    return (
        <div
            ref={selfRef}
            style={{
                display: "flex",
                flexDirection: (border.getOrientation() === Orientation.VERT ? "row" : "column")
            }}
            className={borderClasses}
            data-layout-path={border.getPath()}
            onClick={onAuxMouseClick}
            onAuxClick={onAuxMouseClick}
            onContextMenu={onContextMenu}
            onWheel={onMouseWheel}
        >
            <div className={cm(CLASSES.FLEXLAYOUT__MINI_SCROLLBAR_CONTAINER)}>
                <div
                    ref={tabStripInnerRef}
                    className={cm(CLASSES.FLEXLAYOUT__BORDER_INNER) + " " + cm(CLASSES.FLEXLAYOUT__BORDER_INNER_ + border.getLocation().getName())}
                    style={outerStyle}
                    onScroll={onScroll}
                >
                    <div
                        style={innerStyle}
                        className={cm(CLASSES.FLEXLAYOUT__BORDER_INNER_TAB_CONTAINER) + " " + cm(CLASSES.FLEXLAYOUT__BORDER_INNER_TAB_CONTAINER_ + border.getLocation().getName())}
                    >
                        {tabButtons}
                    </div>
                </div>
                {miniScrollbar}
            </div>
            {toolbar}
        </div >
    );

};

```

## File: src/view/TabButtonStamp.tsx

```tsx
import * as React from "react";
import { TabNode } from "../model/TabNode";
import { LayoutInternal } from "./Layout";
import { CLASSES } from "../Types";
import { getRenderStateEx } from "./Utils";

/** @internal */
export interface ITabButtonStampProps {
    node: TabNode;
    layout: LayoutInternal;
}

/** @internal */
export const TabButtonStamp = (props: ITabButtonStampProps) => {
    const { layout, node } = props;

    const cm = layout.getClassName;

    let classNames = cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_STAMP);

    const renderState = getRenderStateEx(layout, node);

    let content = renderState.content ? (
        <div className={cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_CONTENT)}>
            {renderState.content}
        </div>)
        : node.getNameForOverflowMenu();

    const leading = renderState.leading ? (
        <div className={cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_LEADING)}>
            {renderState.leading}
        </div>) : null;

    return (
        <div
            className={classNames}
            title={node.getHelpText()}
        >
            {leading}
            {content}
        </div>
    );
};

```

## File: src/view/TabSet.tsx

```tsx
import * as React from "react";
import { I18nLabel } from "../I18nLabel";
import { Actions } from "../model/Actions";
import { TabNode } from "../model/TabNode";
import { TabSetNode } from "../model/TabSetNode";
import { showPopup } from "./PopupMenu";
import { LayoutInternal, ITabSetRenderValues } from "./Layout";
import { TabButton } from "./TabButton";
import { useTabOverflow } from "./TabOverflowHook";
import { Orientation } from "../Orientation";
import { CLASSES } from "../Types";
import { isAuxMouseEvent } from "./Utils";
import { createPortal } from "react-dom";
import { Rect } from "../Rect";

/** @internal */
export interface ITabSetProps {
    layout: LayoutInternal;
    node: TabSetNode;
}

/** @internal */
export const TabSet = (props: ITabSetProps) => {
    const { node, layout } = props;

    const tabStripRef = React.useRef<HTMLDivElement | null>(null);
    const miniScrollRef = React.useRef<HTMLDivElement | null>(null);
    const tabStripInnerRef = React.useRef<HTMLDivElement | null>(null);
    const contentRef = React.useRef<HTMLDivElement | null>(null);
    const buttonBarRef = React.useRef<HTMLDivElement | null>(null);
    const overflowbuttonRef = React.useRef<HTMLButtonElement | null>(null);
    const stickyButtonsRef = React.useRef<HTMLDivElement | null>(null);

    const icons = layout.getIcons();

    // must use useEffect (rather than useLayoutEffect) otherwise contentrect not set correctly (has height 0 when changing theme in demo)
    React.useEffect(() => {
        node.setRect(layout.getBoundingClientRect(selfRef.current!));

        if (tabStripRef.current) {
            node.setTabStripRect(layout.getBoundingClientRect(tabStripRef.current!));
        }

        const newContentRect = Rect.getContentRect(contentRef.current!).relativeTo(layout.getDomRect()!);
        if (!node.getContentRect().equals(newContentRect)) {
            node.setContentRect(newContentRect);
            setTimeout(() => { //prevent Maximum update depth exceeded error
                layout.redrawInternal("tabset content rect " + newContentRect);
            }, 0);
        }
    });

    // this must be after the useEffect, so the node rect is already set (else window popin will not position tabs correctly)
    const { selfRef, userControlledPositionRef, onScroll, onScrollPointerDown, hiddenTabs, onMouseWheel, isDockStickyButtons, isShowHiddenTabs } =
        useTabOverflow(layout, node, Orientation.HORZ, tabStripInnerRef, miniScrollRef,
            layout.getClassName(CLASSES.FLEXLAYOUT__TAB_BUTTON));

    const onOverflowClick = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        const callback = layout.getShowOverflowMenu();
        const items = hiddenTabs.map(h => { return { index: h, node: (node.getChildren()[h] as TabNode) }; });
        if (callback !== undefined) {
            callback(node, event, items, onOverflowItemSelect);
        } else {
            const element = overflowbuttonRef.current!;
            showPopup(
                element,
                node,
                items,
                onOverflowItemSelect,
                layout
            );
        }
        event.stopPropagation();
    };

    const onOverflowItemSelect = (item: { node: TabNode; index: number }) => {
        layout.doAction(Actions.selectTab(item.node.getId()));
        userControlledPositionRef.current = false;
    };

    const onDragStart = (event: React.DragEvent<HTMLElement>) => {
        if (!layout.getEditingTab()) {
            if (node.isEnableDrag()) {
                event.stopPropagation();
                layout.setDragNode(event.nativeEvent, node as TabSetNode);
            } else {
                event.preventDefault();
            }
        } else {
            event.preventDefault();
        }
    };

    const onPointerDown = (event: React.PointerEvent<HTMLElement>) => {
        if (!isAuxMouseEvent(event)) {
            layout.doAction(Actions.setActiveTabset(node.getId(), layout.getWindowId()));
        }
    };

    const onAuxMouseClick = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        if (isAuxMouseEvent(event)) {
            layout.auxMouseClick(node, event);
        }
    };

    const onContextMenu = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        layout.showContextMenu(node, event);
    };

    const onInterceptPointerDown = (event: React.PointerEvent) => {
        event.stopPropagation();
    };

    const onMaximizeToggle = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        if (node.canMaximize()) {
            layout.maximize(node);
        }
        event.stopPropagation();
    };

    const onClose = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        layout.doAction(Actions.deleteTabset(node.getId()));
        event.stopPropagation();
    };

    const onCloseTab = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        layout.doAction(Actions.deleteTab(node.getChildren()[0]!.getId()));
        event.stopPropagation();
    };

    const onPopoutTab = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        if (selectedTabNode !== undefined) {
            layout.doAction(Actions.popoutTab(selectedTabNode.getId()));
            // layout.doAction(Actions.popoutTabset(node.getId()));
        }
        event.stopPropagation();
    };

    const onDoubleClick = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        if (node.canMaximize()) {
            layout.maximize(node);
        }
    };

    // Start Render

    const cm = layout.getClassName;
    const selectedTabNode: TabNode = node.getSelectedNode() as TabNode;
    const path = node.getPath();

    const tabs = [];
    if (node.isEnableTabStrip()) {
        for (let i = 0; i < node.getChildren().length; i++) {
            const child = node.getChildren()[i] as TabNode;
            let isSelected = node.getSelected() === i;
            tabs.push(
                <TabButton
                    layout={layout}
                    node={child}
                    path={path + "/tb" + i}
                    key={child.getId()}
                    selected={isSelected}
                />);
            if (i < node.getChildren().length - 1) {
                tabs.push(
                    <div key={"divider" + i} className={cm(CLASSES.FLEXLAYOUT__TABSET_TAB_DIVIDER)}></div>
                );
            }
        }
    }

    let stickyButtons: React.ReactNode[] = [];
    let buttons: React.ReactNode[] = [];

    // allow customization of header contents and buttons
    const renderState: ITabSetRenderValues = { stickyButtons, buttons, overflowPosition: undefined };
    layout.customizeTabSet(node, renderState);
    stickyButtons = renderState.stickyButtons;
    buttons = renderState.buttons;

    const isTabStretch = node.isEnableSingleTabStretch() && node.getChildren().length === 1;
    const showClose = (isTabStretch && ((node.getChildren()[0] as TabNode).isEnableClose())) || node.isEnableClose();

    if (renderState.overflowPosition === undefined) {
        renderState.overflowPosition = stickyButtons.length;
    }

    if (stickyButtons.length > 0) {
        if (!node.isEnableTabWrap() && (isDockStickyButtons || isTabStretch)) {
            buttons = [...stickyButtons, ...buttons];
        } else {
            tabs.push(<div
                ref={stickyButtonsRef}
                key="sticky_buttons_container"
                onPointerDown={onInterceptPointerDown}
                onDragStart={(e) => { e.preventDefault() }}
                className={cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_STICKY_BUTTONS_CONTAINER)}
            >
                {stickyButtons}
            </div>);
        }
    }

    if (!node.isEnableTabWrap()) {
        if (isShowHiddenTabs) {
            const overflowTitle = layout.i18nName(I18nLabel.Overflow_Menu_Tooltip);
            let overflowContent;
            if (typeof icons.more === "function") {
                const items = hiddenTabs.map(h => { return { index: h, node: (node.getChildren()[h] as TabNode) }; });
                overflowContent = icons.more(node, items);
            } else {
                overflowContent = (<>
                    {icons.more}
                    <div className={cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_OVERFLOW_COUNT)}>{hiddenTabs.length>0?hiddenTabs.length: ""}</div>
                </>);
            }
            buttons.splice(Math.min(renderState.overflowPosition, buttons.length), 0,
                <button
                    key="overflowbutton"
                    data-layout-path={path + "/button/overflow"}

                    ref={overflowbuttonRef}
                    className={cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON) + " " + cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_OVERFLOW)}
                    title={overflowTitle}
                    onClick={onOverflowClick}
                    onPointerDown={onInterceptPointerDown}
                >
                    {overflowContent}
                </button>
            );
        }
    }

    if (selectedTabNode !== undefined &&
        layout.isSupportsPopout() &&
        selectedTabNode.isEnablePopout() &&
        selectedTabNode.isEnablePopoutIcon()) {

        const popoutTitle = layout.i18nName(I18nLabel.Popout_Tab);
        buttons.push(
            <button
                key="popout"
                data-layout-path={path + "/button/popout"}
                title={popoutTitle}
                className={cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON) + " " + cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON_FLOAT)}
                onClick={onPopoutTab}
                onPointerDown={onInterceptPointerDown}
            >
                {(typeof icons.popout === "function") ? icons.popout(selectedTabNode) : icons.popout}
            </button>
        );
    }

    if (node.canMaximize()) {
        const minTitle = layout.i18nName(I18nLabel.Restore);
        const maxTitle = layout.i18nName(I18nLabel.Maximize);
        buttons.push(
            <button
                key="max"
                data-layout-path={path + "/button/max"}
                title={node.isMaximized() ? minTitle : maxTitle}
                className={cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON) + " " + cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON_ + (node.isMaximized() ? "max" : "min"))}
                onClick={onMaximizeToggle}
                onPointerDown={onInterceptPointerDown}
            >
                {node.isMaximized() ?
                    (typeof icons.restore === "function") ? icons.restore(node) : icons.restore :
                    (typeof icons.maximize === "function") ? icons.maximize(node) : icons.maximize}
            </button>
        );
    }

    if (!node.isMaximized() && showClose) {
        const title = isTabStretch ? layout.i18nName(I18nLabel.Close_Tab) : layout.i18nName(I18nLabel.Close_Tabset);
        buttons.push(
            <button
                key="close"
                data-layout-path={path + "/button/close"}
                title={title}
                className={cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON) + " " + cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_BUTTON_CLOSE)}
                onClick={isTabStretch ? onCloseTab : onClose}
                onPointerDown={onInterceptPointerDown}
            >
                {(typeof icons.closeTabset === "function") ? icons.closeTabset(node) : icons.closeTabset}
            </button>
        );
    }

    if (node.isActive() && node.isEnableActiveIcon()) {
        const title = layout.i18nName(I18nLabel.Active_Tabset);
        buttons.push(
            <div
                key="active"
                data-layout-path={path + "/button/active"}
                title={title}
                className={cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR_ICON)}
            >
                {(typeof icons.activeTabset === "function") ? icons.activeTabset(node) : icons.activeTabset}
            </div>
        );
    }

    const buttonbar = (
        <div key="buttonbar" ref={buttonBarRef}
            className={cm(CLASSES.FLEXLAYOUT__TAB_TOOLBAR)}
            onPointerDown={onInterceptPointerDown}
            onDragStart={(e) => { e.preventDefault() }}
        >
            {buttons}
        </div>
    );

    let tabStrip;

    let tabStripClasses = cm(CLASSES.FLEXLAYOUT__TABSET_TABBAR_OUTER);
    if (node.getClassNameTabStrip() !== undefined) {
        tabStripClasses += " " + node.getClassNameTabStrip();
    }
    tabStripClasses += " " + CLASSES.FLEXLAYOUT__TABSET_TABBAR_OUTER_ + node.getTabLocation();

    if (node.isActive()) {
        tabStripClasses += " " + cm(CLASSES.FLEXLAYOUT__TABSET_SELECTED);
    }

    if (node.isMaximized()) {
        tabStripClasses += " " + cm(CLASSES.FLEXLAYOUT__TABSET_MAXIMIZED);
    }

    if (isTabStretch) {
        const tabNode = node.getChildren()[0] as TabNode;
        if (tabNode.getTabSetClassName() !== undefined) {
            tabStripClasses += " " + tabNode.getTabSetClassName();
        }
    }

    if (node.isEnableTabWrap()) {
        if (node.isEnableTabStrip()) {
            tabStrip = (
                <div className={tabStripClasses}
                    style={{ flexWrap: "wrap", gap: "1px", marginTop: "2px" }}
                    ref={tabStripRef}
                    data-layout-path={path + "/tabstrip"}
                    onPointerDown={onPointerDown}
                    onDoubleClick={onDoubleClick}
                    onContextMenu={onContextMenu}
                    onClick={onAuxMouseClick}
                    onAuxClick={onAuxMouseClick}
                    draggable={true}
                    onDragStart={onDragStart}
                >
                    {tabs}
                    <div style={{ flexGrow: 1 }} />
                    {buttonbar}
                </div>
            );
        }
    } else {
        if (node.isEnableTabStrip()) {
            let miniScrollbar = undefined;
            if (node.isEnableTabScrollbar()) {
                miniScrollbar = (
                    <div ref={miniScrollRef}
                        className={cm(CLASSES.FLEXLAYOUT__MINI_SCROLLBAR)}
                        onPointerDown={onScrollPointerDown}
                    />
                );
            }
            tabStrip = (
                <div className={tabStripClasses}
                    ref={tabStripRef}
                    data-layout-path={path + "/tabstrip"}
                    onPointerDown={onPointerDown}
                    onDoubleClick={onDoubleClick}
                    onContextMenu={onContextMenu}
                    onClick={onAuxMouseClick}
                    onAuxClick={onAuxMouseClick}
                    draggable={true}
                    onWheel={onMouseWheel}
                    onDragStart={onDragStart}
                >
                    <div className={cm(CLASSES.FLEXLAYOUT__MINI_SCROLLBAR_CONTAINER)}>
                        <div ref={tabStripInnerRef}
                            className={cm(CLASSES.FLEXLAYOUT__TABSET_TABBAR_INNER) + " " + cm(CLASSES.FLEXLAYOUT__TABSET_TABBAR_INNER_ + node.getTabLocation())}
                            style={{ overflowX: 'auto', overflowY: "hidden" }}
                            onScroll={onScroll}
                        >
                            <div
                                style={{ width: (isTabStretch ? "100%" : "none") }}
                                className={cm(CLASSES.FLEXLAYOUT__TABSET_TABBAR_INNER_TAB_CONTAINER) + " " + cm(CLASSES.FLEXLAYOUT__TABSET_TABBAR_INNER_TAB_CONTAINER_ + node.getTabLocation())}
                            >
                                {tabs}
                            </div>
                        </div>
                        {miniScrollbar}
                    </div>
                    {buttonbar}
                </div>
            );
        }
    }

    var emptyTabset: React.ReactNode;
    if (node.getChildren().length === 0) {
        const placeHolderCallback = layout.getTabSetPlaceHolderCallback();
        if (placeHolderCallback) {
            emptyTabset = placeHolderCallback(node);
        }
    }

    let content = <div ref={contentRef} className={cm(CLASSES.FLEXLAYOUT__TABSET_CONTENT)}>
        {emptyTabset}
    </div>

    if (node.getTabLocation() === "top") {
        content = <>{tabStrip}{content}</>;
    } else {
        content = <>{content}{tabStrip}</>;
    }

    let style: Record<string, any> = {
        flexGrow: Math.max(1, node.getWeight() * 1000),
        minWidth: node.getMinWidth(),
        minHeight: node.getMinHeight(),
        maxWidth: node.getMaxWidth(),
        maxHeight: node.getMaxHeight()
    };

    if (node.getModel().getMaximizedTabset(layout.getWindowId()) !== undefined && !node.isMaximized()) {
        style.display = "none";
    }

    // note: tabset container is needed to allow flexbox to size without border/padding/margin
    // then inner tabset can have border/padding/margin for styling
    const tabset = (
        <div ref={selfRef}
            className={cm(CLASSES.FLEXLAYOUT__TABSET_CONTAINER)}
            style={style}
        >
            <div className={cm(CLASSES.FLEXLAYOUT__TABSET)}
                data-layout-path={path}
            >
                {content}
            </div>
        </div>
    );

    if (node.isMaximized()) {
        if (layout.getMainElement()) {
            return createPortal(
                <div style={{
                    position: "absolute",
                    display: "flex",
                    top: 0, left: 0, bottom: 0, right: 0
                }}>
                    {tabset}
                </div>, layout.getMainElement()!);
        } else {
            return tabset;
        }
    } else {
        return tabset;
    }

};



```

## File: src/view/TabOverflowHook.tsx

```tsx
import * as React from "react";
import { TabSetNode } from "../model/TabSetNode";
import { BorderNode } from "../model/BorderNode";
import { Orientation } from "../Orientation";
import { LayoutInternal } from "./Layout";
import { TabNode } from "../model/TabNode";
import { startDrag } from "./Utils";
import { Rect } from "../Rect";

/** @internal */
export const useTabOverflow = (
    layout: LayoutInternal,
    node: TabSetNode | BorderNode,
    orientation: Orientation,
    tabStripRef: React.RefObject<HTMLElement | null>,
    miniScrollRef: React.RefObject<HTMLElement | null>,
    tabClassName: string
) => {
    const [hiddenTabs, setHiddenTabs] = React.useState<number[]>([]);
    const [isShowHiddenTabs, setShowHiddenTabs] = React.useState<boolean>(false);
    const [isDockStickyButtons, setDockStickyButtons] = React.useState<boolean>(false);

    const selfRef = React.useRef<HTMLDivElement | null>(null);
    const userControlledPositionRef = React.useRef<boolean>(false);
    const updateHiddenTabsTimerRef = React.useRef<NodeJS.Timeout | undefined>(undefined);
    const hiddenTabsRef = React.useRef<number[]>([]);
    const thumbInternalPos = React.useRef<number>(0);
    const repositioningRef = React.useRef<boolean>(false);
    hiddenTabsRef.current = hiddenTabs;

    // if node changes (new model) then reset scroll to 0
    React.useLayoutEffect(() => {
        if (tabStripRef.current) {
            setScrollPosition(0);
        }
    }, [node]);

    // if selected node or tabset/border rectangle change then unset usercontrolled (so selected tab will be kept in view)
    React.useLayoutEffect(() => {
        userControlledPositionRef.current = false;
    }, [node.getSelectedNode(), node.getRect().width, node.getRect().height]);

    React.useLayoutEffect(() => {
        checkForOverflow(); // if tabs + sticky buttons length > scroll area => move sticky buttons to right buttons

        if (userControlledPositionRef.current === false) {
            scrollIntoView();
        }

        updateScrollMetrics();
        updateHiddenTabs();
    });

    function scrollIntoView() {
        const selectedTabNode = node.getSelectedNode() as TabNode;
        if (selectedTabNode && tabStripRef.current) {
            const stripRect = layout.getBoundingClientRect(tabStripRef.current);
            const selectedRect = selectedTabNode.getTabRect()!;

            let shift = getNear(stripRect) - getNear(selectedRect);
            if (shift > 0 || getSize(selectedRect) > getSize(stripRect)) { 
                setScrollPosition(getScrollPosition(tabStripRef.current) - shift);
                repositioningRef.current = true; // prevent onScroll setting userControlledPosition
            } else {
                shift = getFar(selectedRect) - getFar(stripRect);
                if (shift > 0) {
                    setScrollPosition(getScrollPosition(tabStripRef.current) + shift);
                    repositioningRef.current = true;
                }
            }
        }
    }

    const updateScrollMetrics = () => {
        if (tabStripRef.current && miniScrollRef.current) {
            const t = tabStripRef.current;
            const s = miniScrollRef.current;

            const size = getElementSize(t);
            const scrollSize = getScrollSize(t);
            const position = getScrollPosition(t);

            if (scrollSize > size && scrollSize > 0) {
                let thumbSize = size * size / scrollSize;
                let adjust = 0;
                if (thumbSize < 20) {
                    adjust = 20 - thumbSize;
                    thumbSize = 20;
                }
                const thumbPos = position * (size - adjust) / scrollSize;
                if (orientation === Orientation.HORZ) {
                    s.style.width = thumbSize + "px";
                    s.style.left = thumbPos + "px";
                } else {
                    s.style.height = thumbSize + "px";
                    s.style.top = thumbPos + "px";
                }
                s.style.display = "block";
            } else {
                s.style.display = "none";
            }

            if (orientation === Orientation.HORZ) {
                s.style.bottom = "0px";
            } else {
                s.style.right = "0px";
            }
        }
    }

    const updateHiddenTabs = () => {
        const newHiddenTabs = findHiddenTabs();
        const showHidden = newHiddenTabs.length > 0;

        if (showHidden !== isShowHiddenTabs) {
            setShowHiddenTabs(showHidden);
        }

        if (updateHiddenTabsTimerRef.current === undefined) {
            // throttle updates to prevent Maximum update depth exceeded error
            updateHiddenTabsTimerRef.current = setTimeout(() => {
                const newHiddenTabs = findHiddenTabs();
                if (!arraysEqual(newHiddenTabs, hiddenTabsRef.current)) {
                    setHiddenTabs(newHiddenTabs);
                }

                updateHiddenTabsTimerRef.current = undefined;
            }, 100);
        }
    }

    const onScroll = () => {
        if (!repositioningRef.current){
            userControlledPositionRef.current=true;
        }
        repositioningRef.current = false;
        updateScrollMetrics()
        updateHiddenTabs();
    };

    const onScrollPointerDown = (event: React.PointerEvent<HTMLElement>) => {
        event.stopPropagation();
        miniScrollRef.current!.setPointerCapture(event.pointerId)
        const r = miniScrollRef.current?.getBoundingClientRect()!;
        if (orientation === Orientation.HORZ) {
            thumbInternalPos.current = event.clientX - r.x;
        } else {
            thumbInternalPos.current = event.clientY - r.y;
        }
        startDrag(event.currentTarget.ownerDocument, event, onDragMove, onDragEnd, onDragCancel);
    }

    const onDragMove = (x: number, y: number) => {
        if (tabStripRef.current && miniScrollRef.current) {
            const t = tabStripRef.current;
            const s = miniScrollRef.current;
            const size = getElementSize(t);
            const scrollSize = getScrollSize(t);
            const thumbSize = getElementSize(s);

            const r = t.getBoundingClientRect()!;
            let thumb = 0;
            if (orientation === Orientation.HORZ) {
                thumb = x - r.x - thumbInternalPos.current;
            } else {
                thumb = y - r.y - thumbInternalPos.current
            }

            thumb = Math.max(0, Math.min(scrollSize - thumbSize, thumb));
            if (size > 0) {
                const scrollPos = thumb * scrollSize / size;
                setScrollPosition(scrollPos);
            }
        }
    }

    const onDragEnd = () => {
    }

    const onDragCancel = () => {
    }

    const checkForOverflow = () => {
        if (tabStripRef.current) {
            const strip = tabStripRef.current;
            const tabContainer = strip.firstElementChild!;

            const offset = isDockStickyButtons ? 10 : 0; // prevents flashing, after sticky buttons docked set, must be 10 pixels smaller before unsetting
            const dock = (getElementSize(tabContainer) + offset) > getElementSize(tabStripRef.current);
            if (dock !== isDockStickyButtons) {
                setDockStickyButtons(dock);
            }
        }
    }

    const findHiddenTabs: () => number[] = () => {
        const hidden: number[] = [];
        if (tabStripRef.current) {
            const strip = tabStripRef.current;
            const stripRect = strip.getBoundingClientRect();
            const visibleNear = getNear(stripRect) - 1;
            const visibleFar = getFar(stripRect) + 1;

            const tabContainer = strip.firstElementChild!;

            let i = 0;
            Array.from(tabContainer.children).forEach((child) => {
                const tabRect = child.getBoundingClientRect();

                if (child.classList.contains(tabClassName)) {
                    if (getNear(tabRect) < visibleNear || getFar(tabRect) > visibleFar) {
                        hidden.push(i);
                    }
                    i++;
                }
            });
        }

        return hidden;
    };

    const onMouseWheel = (event: React.WheelEvent<HTMLElement>) => {
        if (tabStripRef.current) {
            if (node.getChildren().length === 0) return;

            let delta = 0;
            if (Math.abs(event.deltaY) > 0) {
                delta = -event.deltaY;
                if (event.deltaMode === 1) {
                    // DOM_DELTA_LINE	0x01	The delta values are specified in lines.
                    delta *= 40;
                }
                const newPos = getScrollPosition(tabStripRef.current) - delta;
                const maxScroll = getScrollSize(tabStripRef.current) - getElementSize(tabStripRef.current);
                const p = Math.max(0, Math.min(maxScroll, newPos));
                setScrollPosition(p);
                event.stopPropagation();
            }
        }
    };

    // orientation helpers:

    const getNear = (rect: DOMRect | Rect) => {
        if (orientation === Orientation.HORZ) {
            return rect.x;
        } else {
            return rect.y;
        }
    };

    const getFar = (rect: DOMRect | Rect) => {
        if (orientation === Orientation.HORZ) {
            return rect.right;
        } else {
            return rect.bottom;
        }
    };

    const getElementSize = (elm: Element) => {
        if (orientation === Orientation.HORZ) {
            return elm.clientWidth;
        } else {
            return elm.clientHeight;
        }
    }

    const getSize = (rect: DOMRect | Rect) => {
        if (orientation === Orientation.HORZ) {
            return rect.width;
        } else {
            return rect.height;
        }
    }

    const getScrollSize = (elm: Element) => {
        if (orientation === Orientation.HORZ) {
            return elm.scrollWidth;
        } else {
            return elm.scrollHeight;
        }
    }

    const setScrollPosition = (p: number) => {
        if (orientation === Orientation.HORZ) {
            tabStripRef.current!.scrollLeft = p;
        } else {
            tabStripRef.current!.scrollTop = p;
        }
    }

    const getScrollPosition = (elm: Element) => {
        if (orientation === Orientation.HORZ) {
            return elm.scrollLeft;
        } else {
            return elm.scrollTop;
        }
    }

    return { selfRef, userControlledPositionRef, onScroll, onScrollPointerDown, hiddenTabs, onMouseWheel, isDockStickyButtons, isShowHiddenTabs };
};

function arraysEqual(arr1: number[], arr2: number[]) {
    return arr1.length === arr2.length && arr1.every((val, index) => val === arr2[index]);
}

```

## File: src/view/Layout.tsx

```tsx
import * as React from "react";
import { createPortal } from "react-dom";
import { createRoot } from "react-dom/client";
import { DockLocation } from "../DockLocation";
import { DropInfo } from "../DropInfo";
import { I18nLabel } from "../I18nLabel";
import { Orientation } from "../Orientation";
import { Rect } from "../Rect";
import { CLASSES } from "../Types";
import { Action } from "../model/Action";
import { Actions } from "../model/Actions";
import { BorderNode } from "../model/BorderNode";
import { IDraggable } from "../model/IDraggable";
import { IJsonTabNode } from "../model/IJsonModel";
import { Model } from "../model/Model";
import { Node } from "../model/Node";
import { TabNode } from "../model/TabNode";
import { TabSetNode } from "../model/TabSetNode";
import { BorderTab } from "./BorderTab";
import { BorderTabSet } from "./BorderTabSet";
import { DragContainer } from "./DragContainer";
import { ErrorBoundary } from "./ErrorBoundary";
import { PopoutWindow } from "./PopoutWindow";
import { AsterickIcon, CloseIcon, EdgeIcon, MaximizeIcon, OverflowIcon, PopoutIcon, RestoreIcon } from "./Icons";
import { Overlay } from "./Overlay";
import { Row } from "./Row";
import { Tab } from "./Tab";
import { copyInlineStyles, enablePointerOnIFrames, isDesktop, isSafari } from "./Utils";
import { LayoutWindow } from "../model/LayoutWindow";
import { TabButtonStamp } from "./TabButtonStamp";
import { SizeTracker } from "./SizeTracker";

export interface ILayoutProps {
    /** the model for this layout */
    model: Model;
    /** factory function for creating the tab components */
    factory: (node: TabNode) => React.ReactNode;
    /** sets a top level class name on popout windows */
    popoutClassName?: string;
    /** object mapping keys among close, maximize, restore, more, popout to React nodes to use in place of the default icons, can alternatively return functions for creating the React nodes */
    icons?: IIcons;
    /** function called whenever the layout generates an action to update the model (allows for intercepting actions before they are dispatched to the model, for example, asking the user to confirm a tab close.) Returning undefined from the function will halt the action, otherwise return the action to continue */
    onAction?: (action: Action) => Action | undefined;
    /** function called when rendering a tab, allows leading (icon), content section, buttons and name used in overflow menu to be customized */
    onRenderTab?: (
        node: TabNode,
        renderValues: ITabRenderValues, // change the values in this object as required
    ) => void;
    /** function called when rendering a tabset, allows header and buttons to be customized */
    onRenderTabSet?: (
        tabSetNode: TabSetNode | BorderNode,
        renderValues: ITabSetRenderValues, // change the values in this object as required
    ) => void;
    /** function called when model has changed */
    onModelChange?: (model: Model, action: Action) => void;
    /** function called when an external object (not a tab) gets dragged onto the layout, with a single dragenter argument. Should return either undefined to reject the drag/drop or an object with keys dragText, jsonDrop, to create a tab via drag (similar to a call to addTabToTabSet). Function onDropis passed the added tabNodeand thedrop DragEvent`, unless the drag was canceled. */
    onExternalDrag?: (event: React.DragEvent<HTMLElement>) => undefined | {
        json: any,
        onDrop?: (node?: Node, event?: React.DragEvent<HTMLElement>) => void
    };
    /** function called with default css class name, return value is class name that will be used. Mainly for use with css modules. */
    classNameMapper?: (defaultClassName: string) => string;
    /** function called for each I18nLabel to allow user translation, currently used for tab and tabset move messages, return undefined to use default values */
    i18nMapper?: (id: I18nLabel, param?: string) => string | undefined;
    /** if left undefined will do simple check based on userAgent */
    supportsPopout?: boolean | undefined;
    /** URL of popout window relative to origin, defaults to popout.html */
    popoutURL?: string | undefined;
    /** boolean value, defaults to false, resize tabs as splitters are dragged. Warning: this can cause resizing to become choppy when tabs are slow to draw */
    realtimeResize?: boolean | undefined;
    /** callback for rendering the drag rectangles */
    onRenderDragRect?: DragRectRenderCallback;
    /** callback for handling context actions on tabs and tabsets */
    onContextMenu?: NodeMouseEvent;
    /** callback for handling mouse clicks on tabs and tabsets with alt, meta, shift keys, also handles center mouse clicks */
    onAuxMouseClick?: NodeMouseEvent;
    /** callback for handling the display of the tab overflow menu */
    onShowOverflowMenu?: ShowOverflowMenuCallback;
    /** callback for rendering a placeholder when a tabset is empty */
    onTabSetPlaceHolder?: TabSetPlaceHolderCallback;
    /** Name given to popout windows, defaults to 'Popout Window' */
    popoutWindowName?: string;
}

/**
 * A React component that hosts a multi-tabbed layout
 */
export class Layout extends React.Component<ILayoutProps> {
    /** @internal */
    private selfRef: React.RefObject<LayoutInternal | null>;
    /** @internal */
    private revision: number; // so LayoutInternal knows this is a parent render (used for optimization)

    /** @internal */
    constructor(props: ILayoutProps) {
        super(props);
        this.selfRef = React.createRef<LayoutInternal>();
        this.revision = 0;
    }

    /** re-render the layout */
    redraw() {
        this.selfRef.current!.redraw("parent " + this.revision);
    }

    /**
     * Adds a new tab to the given tabset
     * @param tabsetId the id of the tabset where the new tab will be added
     * @param json the json for the new tab node
     * @returns the added tab node or undefined
     */
    addTabToTabSet(tabsetId: string, json: IJsonTabNode): TabNode | undefined {
        return this.selfRef.current!.addTabToTabSet(tabsetId, json);
    }

    /**
     * Adds a new tab by dragging an item to the drop location, must be called from within an HTML
     * drag start handler. You can use the setDragComponent() method to set the drag image before calling this 
     * method.
     * @param event the drag start event
     * @param json the json for the new tab node
     * @param onDrop a callback to call when the drag is complete
     */
    addTabWithDragAndDrop(event: DragEvent, json: IJsonTabNode, onDrop?: (node?: Node, event?: React.DragEvent<HTMLElement>) => void) {
        this.selfRef.current!.addTabWithDragAndDrop(event, json, onDrop);
    }

    /**
     * Move a tab/tabset using drag and drop, must be called from within an HTML
     * drag start handler
     * @param event the drag start event
     * @param node the tab or tabset to drag
     */
    moveTabWithDragAndDrop(event: DragEvent, node: (TabNode | TabSetNode)) {
        this.selfRef.current!.moveTabWithDragAndDrop(event, node);
    }

    /**
     * Adds a new tab to the active tabset (if there is one)
     * @param json the json for the new tab node
     * @returns the added tab node or undefined
     */
    addTabToActiveTabSet(json: IJsonTabNode): TabNode | undefined {
        return this.selfRef.current!.addTabToActiveTabSet(json);
    }

    /**
     * Sets the drag image from a react component for a drag event
     * @param event the drag event
     * @param component the react component to be used for the drag image
     * @param x the x position of the drag cursor on the image
     * @param y the x position of the drag cursor on the image
     */
    setDragComponent(event: DragEvent, component: React.ReactNode, x: number, y: number) {
        this.selfRef.current!.setDragComponent(event, component, x, y);
    }

    /** Get the root div element of the layout */
    getRootDiv() {
        return this.selfRef.current!.getRootDiv();
    }

    /** @internal */
    render() {
        return (<LayoutInternal ref={this.selfRef} {...this.props} renderRevision={this.revision++} />)
    }
}

/** @internal */
interface ILayoutInternalProps extends ILayoutProps {
    renderRevision: number;

    // used only for popout windows:
    windowId?: string;
    mainLayout?: LayoutInternal;
}

/** @internal */
interface ILayoutInternalState {
    rect: Rect;
    editingTab?: TabNode;
    portal?: React.ReactPortal;
    showEdges: boolean;
    showOverlay: boolean;
    calculatedBorderBarSize: number;
    layoutRevision: number;
    forceRevision: number;
    showHiddenBorder: DockLocation;
}

/** @internal */
export class LayoutInternal extends React.Component<ILayoutInternalProps, ILayoutInternalState> {
    public static dragState: DragState | undefined = undefined;

    private selfRef: React.RefObject<HTMLDivElement | null>;
    private moveablesRef: React.RefObject<HTMLDivElement | null>;
    private findBorderBarSizeRef: React.RefObject<HTMLDivElement | null>;
    private mainRef: React.RefObject<HTMLDivElement | null>;
    private previousModel?: Model;
    private orderedIds: string[];
    private moveableElementMap = new Map<string, HTMLElement>();
    private dropInfo: DropInfo | undefined;
    private outlineDiv?: HTMLElement;
    private currentDocument?: Document;
    private currentWindow?: Window;
    private supportsPopout: boolean;
    private popoutURL: string;
    private icons: IIcons;
    private resizeObserver?: ResizeObserver;

    private dragEnterCount: number = 0;
    private dragging: boolean = false;
    private windowId: string;
    private layoutWindow: LayoutWindow;
    private mainLayout: LayoutInternal;
    private isMainWindow: boolean;
    private isDraggingOverWindow: boolean;
    private styleObserver: MutationObserver | undefined;
    private popoutWindowName: string;
    // private renderCount: any;

    constructor(props: ILayoutInternalProps) {
        super(props);

        this.orderedIds = [];
        this.selfRef = React.createRef<HTMLDivElement>();
        this.moveablesRef = React.createRef<HTMLDivElement>();
        this.mainRef = React.createRef<HTMLDivElement>();
        this.findBorderBarSizeRef = React.createRef<HTMLDivElement>();

        this.supportsPopout = props.supportsPopout !== undefined ? props.supportsPopout : defaultSupportsPopout;
        this.popoutURL = props.popoutURL ? props.popoutURL : "popout.html";
        this.icons = { ...defaultIcons, ...props.icons };
        this.windowId = props.windowId ? props.windowId : Model.MAIN_WINDOW_ID;
        this.mainLayout = this.props.mainLayout ? this.props.mainLayout : this;
        this.isDraggingOverWindow = false;
        this.layoutWindow = this.props.model.getwindowsMap().get(this.windowId)!;
        this.layoutWindow.layout = this;
        this.popoutWindowName = this.props.popoutWindowName || "Popout Window";
        // this.renderCount = 0;

        this.state = {
            rect: Rect.empty(),
            editingTab: undefined,
            showEdges: false,
            showOverlay: false,
            calculatedBorderBarSize: 29,
            layoutRevision: 0,
            forceRevision: 0,
            showHiddenBorder: DockLocation.CENTER
        };

        this.isMainWindow = this.windowId === Model.MAIN_WINDOW_ID;
    }

    componentDidMount() {
        this.updateRect();

        this.currentDocument = (this.selfRef.current as HTMLElement).ownerDocument;
        this.currentWindow = this.currentDocument.defaultView!;

        this.layoutWindow.window = this.currentWindow;
        this.layoutWindow.toScreenRectFunction = (r) => this.getScreenRect(r);

        this.resizeObserver = new ResizeObserver(entries => {
            requestAnimationFrame(() => {
                this.updateRect();
            });
        });
        if (this.selfRef.current) {
            this.resizeObserver.observe(this.selfRef.current);
        }

        if (this.isMainWindow) {
            this.props.model.addChangeListener(this.onModelChange);
            this.updateLayoutMetrics();
        } else {
            // since resizeObserver doesn't always work as expected when observing element in another document
            this.currentWindow.addEventListener("resize", () => {
                this.updateRect();
            });

            const sourceElement = this.props.mainLayout!.getRootDiv()!;
            const targetElement = this.selfRef.current!;

            copyInlineStyles(sourceElement, targetElement);

            this.styleObserver = new MutationObserver(() => {
                const changed = copyInlineStyles(sourceElement, targetElement);
                if (changed) {
                    this.redraw("mutation observer");
                }
            });

            // Observe changes to the source element's style attribute
            this.styleObserver.observe(sourceElement, { attributeFilter: ['style'] });
        }

        // allow tabs to overlay when hidden
        document.addEventListener('visibilitychange', () => {
            for (const [_, layoutWindow] of this.props.model.getwindowsMap()) {
                const layout = layoutWindow.layout;
                if (layout) {
                    this.redraw("visibility change");
                }
            }
        });
    }

    componentDidUpdate() {
        this.currentDocument = (this.selfRef.current as HTMLElement).ownerDocument;
        this.currentWindow = this.currentDocument.defaultView!;
        if (this.isMainWindow) {
            if (this.props.model !== this.previousModel) {
                if (this.previousModel !== undefined) {
                    this.previousModel.removeChangeListener(this.onModelChange); // stop listening to old model
                }
                this.props.model.getwindowsMap().get(this.windowId)!.layout = this;
                this.props.model.addChangeListener(this.onModelChange);
                this.layoutWindow = this.props.model.getwindowsMap().get(this.windowId)!;
                this.layoutWindow.layout = this;
                this.layoutWindow.toScreenRectFunction = (r) => this.getScreenRect(r);
                this.previousModel = this.props.model;
                this.tidyMoveablesMap();
            }

            this.updateLayoutMetrics();
        }
    }

    componentWillUnmount() {
        if (this.selfRef.current) {
            this.resizeObserver?.unobserve(this.selfRef.current);
        }
        this.styleObserver?.disconnect();
    }

    render() {
        // console.log("render", this.windowId, this.state.revision, this.renderCount++);
        // first render will be used to find the size (via selfRef)
        if (!this.selfRef.current) {
            return (
                <div ref={this.selfRef} className={this.getClassName(CLASSES.FLEXLAYOUT__LAYOUT)}>
                    <div ref={this.moveablesRef} key="__moveables__" className={this.getClassName(CLASSES.FLEXLAYOUT__LAYOUT_MOVEABLES)}></div>
                    {this.renderMetricsElements()}
                </div>
            );
        }

        const model = this.props.model;
        model.getRoot(this.windowId).calcMinMaxSize();
        model.getRoot(this.windowId).setPaths("");
        model.getBorderSet().setPaths();

        const inner = this.renderLayout();
        const outer = this.renderBorders(inner);

        const tabs = this.renderTabs();
        const reorderedTabs = this.reorderComponents(tabs, this.orderedIds);

        let floatingWindows = null;
        let tabMoveables = null;
        let tabStamps = null;
        let metricElements = null;

        if (this.isMainWindow) {
            floatingWindows = this.renderWindows();
            metricElements = this.renderMetricsElements();
            tabMoveables = this.renderTabMoveables();
            tabStamps = <div key="__tabStamps__" className={this.getClassName(CLASSES.FLEXLAYOUT__LAYOUT_TAB_STAMPS)}>
                {this.renderTabStamps()}
            </div>;
        }

        return (
            <div
                ref={this.selfRef}
                className={this.getClassName(CLASSES.FLEXLAYOUT__LAYOUT)}
                onDragEnter={this.onDragEnterRaw}
                onDragLeave={this.onDragLeaveRaw}
                onDragOver={this.onDragOver}
                onDrop={this.onDrop}
            >
                <div ref={this.moveablesRef} key="__moveables__" className={this.getClassName(CLASSES.FLEXLAYOUT__LAYOUT_MOVEABLES)}></div>
                {metricElements}
                <Overlay key="__overlay__" layout={this} show={this.state.showOverlay} />
                {outer}
                {reorderedTabs}
                {tabMoveables}
                {tabStamps}
                {this.state.portal}
                {floatingWindows}
            </div>
        );
    }

    renderBorders(
        inner: React.ReactNode
    ) {
        const classMain = this.getClassName(CLASSES.FLEXLAYOUT__LAYOUT_MAIN);
        const borders = this.props.model.getBorderSet().getBorderMap()
        if (this.isMainWindow && borders.size > 0) {
            inner = (
                <div className={classMain} ref={this.mainRef}>
                    {inner}
                </div>);
            const borderSetComponents = new Map<DockLocation, React.ReactNode>();
            const borderSetContentComponents = new Map<DockLocation, React.ReactNode>();
            for (const [_, location] of DockLocation.values) {
                const border = borders.get(location);
                const showBorder = border && border.isShowing() && (
                    !border.isAutoHide() ||
                    (border.isAutoHide() && (border.getChildren().length > 0 || this.state.showHiddenBorder === location)));
                if (showBorder) {
                    borderSetComponents.set(location, <BorderTabSet layout={this} border={border} size={this.state.calculatedBorderBarSize} />);
                    borderSetContentComponents.set(location, <BorderTab layout={this} border={border} show={border.getSelected() !== -1} />);
                }
            }

            const classBorderOuter = this.getClassName(CLASSES.FLEXLAYOUT__LAYOUT_BORDER_CONTAINER);
            const classBorderInner = this.getClassName(CLASSES.FLEXLAYOUT__LAYOUT_BORDER_CONTAINER_INNER);

            if (this.props.model.getBorderSet().getLayoutHorizontal()) {
                const innerWithBorderTabs = (
                    <div className={classBorderInner} style={{ flexDirection: "column" }}>
                        {borderSetContentComponents.get(DockLocation.TOP)}
                        <div className={classBorderInner} style={{ flexDirection: "row" }}>
                            {borderSetContentComponents.get(DockLocation.LEFT)}
                            {inner}
                            {borderSetContentComponents.get(DockLocation.RIGHT)}
                        </div>
                        {borderSetContentComponents.get(DockLocation.BOTTOM)}
                    </div>
                );
                return (
                    <div className={classBorderOuter} style={{ flexDirection: "column" }}>
                        {borderSetComponents.get(DockLocation.TOP)}
                        <div className={classBorderInner} style={{ flexDirection: "row" }}>
                            {borderSetComponents.get(DockLocation.LEFT)}
                            {innerWithBorderTabs}
                            {borderSetComponents.get(DockLocation.RIGHT)}
                        </div>
                        {borderSetComponents.get(DockLocation.BOTTOM)}
                    </div>
                );
            } else {
                const innerWithBorderTabs = (
                    <div className={classBorderInner} style={{ flexDirection: "row" }}>
                        {borderSetContentComponents.get(DockLocation.LEFT)}
                        <div className={classBorderInner} style={{ flexDirection: "column" }}>
                            {borderSetContentComponents.get(DockLocation.TOP)}
                            {inner}
                            {borderSetContentComponents.get(DockLocation.BOTTOM)}
                        </div>
                        {borderSetContentComponents.get(DockLocation.RIGHT)}
                    </div>
                );

                return (
                    <div className={classBorderOuter} style={{ flexDirection: "row" }}>
                        {borderSetComponents.get(DockLocation.LEFT)}
                        <div className={classBorderInner} style={{ flexDirection: "column" }}>
                            {borderSetComponents.get(DockLocation.TOP)}
                            {innerWithBorderTabs}
                            {borderSetComponents.get(DockLocation.BOTTOM)}
                        </div>
                        {borderSetComponents.get(DockLocation.RIGHT)}
                    </div>
                );
            }

        } else { // no borders
            return (
                <div className={classMain} ref={this.mainRef} style={{ position: "absolute", top: 0, left: 0, bottom: 0, right: 0, display: "flex" }}>
                    {inner}
                </div>
            );
        }
    }

    renderLayout() {
        return (
            <>
                <Row key="__row__" layout={this} node={this.props.model.getRoot(this.windowId)} />
            </>
        );
    }

    renderWindows() {
        const floatingWindows: React.ReactNode[] = [];
        if (this.supportsPopout) {
            const windows = this.props.model.getwindowsMap();
            let i = 1;
            for (const [windowId, layoutWindow] of windows) {

                if (windowId !== Model.MAIN_WINDOW_ID) {
                    floatingWindows.push(
                        <PopoutWindow
                            key={windowId}
                            layout={this}
                            title={this.popoutWindowName + " " + i}
                            layoutWindow={layoutWindow}
                            url={this.popoutURL + "?id=" + windowId}
                            onSetWindow={this.onSetWindow}
                            onCloseWindow={this.onCloseWindow}
                        >
                            <div className={this.props.popoutClassName}>
                                <LayoutInternal {...this.props} windowId={windowId} mainLayout={this} />
                            </div>
                        </PopoutWindow>
                    );
                    i++;
                }
            }
        }
        return floatingWindows;
    }

    renderTabMoveables() {
        const tabMoveables: React.ReactNode[] = [];

        this.props.model.visitNodes((node) => {
            if (node instanceof TabNode) {
                const child = node as TabNode;
                const element = this.getMoveableElement(child.getId());
                child.setMoveableElement(element);
                const selected = child.isSelected();
                const rect = (child.getParent() as BorderNode | TabSetNode).getContentRect();

                // only render first time if size >0
                const renderTab = child.isRendered() ||
                    ((selected || !child.isEnableRenderOnDemand()) && (rect.width > 0 && rect.height > 0));

                if (renderTab) {
                    //  console.log("rendertab", child.getName(), this.props.renderRevision);
                    const key = child.getId() + (child.isEnableWindowReMount() ? child.getWindowId() : "");
                    tabMoveables.push(createPortal(
                        <SizeTracker rect={rect} selected={child.isSelected()} forceRevision={this.state.forceRevision} tabsRevision={this.props.renderRevision} key={key}>
                            <ErrorBoundary message={this.i18nName(I18nLabel.Error_rendering_component)}>
                                {this.props.factory(child)}
                            </ErrorBoundary>
                        </SizeTracker>
                        , element, key));

                    child.setRendered(renderTab);
                }
            }
        });

        return tabMoveables;
    }

    renderTabStamps() {
        const tabStamps: React.ReactNode[] = [];

        this.props.model.visitNodes((node) => {
            if (node instanceof TabNode) {
                const child = node as TabNode;

                // what the tab should look like when dragged (since images need to have been loaded before drag image can be taken)
                tabStamps.push(<DragContainer key={child.getId()} layout={this} node={child} />)
            }
        });

        return tabStamps;
    }

    renderTabs() {
        const tabs = new Map<string, React.ReactNode>();
        this.props.model.visitWindowNodes(this.windowId, (node) => {
            if (node instanceof TabNode) {
                const child = node as TabNode;
                const selected = child.isSelected();
                const path = child.getPath();

                const renderTab = child.isRendered() || selected || !child.isEnableRenderOnDemand();

                if (renderTab) {
                    // const rect = (child.getParent() as BorderNode | TabSetNode).getContentRect();
                    // const key = child.getId();

                    tabs.set(child.getId(), (
                        // <SizeTracker rect={rect} forceRevision={this.state.forceRevision} key={key}>
                        <Tab
                            key={child.getId()}
                            layout={this}
                            path={path}
                            node={child}
                            selected={selected} />
                        // </SizeTracker>
                    ));
                }
            }
        });
        return tabs;
    }

    renderMetricsElements() {
        return (
            <div key="findBorderBarSize" ref={this.findBorderBarSizeRef} className={this.getClassName(CLASSES.FLEXLAYOUT__BORDER_SIZER)}>
                FindBorderBarSize
            </div>
        );
    }

    checkForBorderToShow(x: number, y: number) {
        const r = this.getBoundingClientRect(this.mainRef.current!);
        const c = r.getCenter();
        const margin = edgeRectWidth;
        const offset = edgeRectLength / 2;

        let overEdge = false;
        if (this.props.model.isEnableEdgeDock() && this.state.showHiddenBorder === DockLocation.CENTER) {
            if ((y > c.y - offset && y < c.y + offset) ||
                (x > c.x - offset && x < c.x + offset)) {
                overEdge = true;
            }
        }

        let location = DockLocation.CENTER;
        if (!overEdge) {
            if (x <= r.x + margin) {
                location = DockLocation.LEFT;
            } else if (x >= r.getRight() - margin) {
                location = DockLocation.RIGHT;
            } else if (y <= r.y + margin) {
                location = DockLocation.TOP;
            } else if (y >= r.getBottom() - margin) {
                location = DockLocation.BOTTOM;
            }
        }

        if (location !== this.state.showHiddenBorder) {
            this.setState({ showHiddenBorder: location });
        }
    }

    updateLayoutMetrics = () => {
        if (this.findBorderBarSizeRef.current) {
            const borderBarSize = this.findBorderBarSizeRef.current.getBoundingClientRect().height;
            if (borderBarSize !== this.state.calculatedBorderBarSize) {
                this.setState({ calculatedBorderBarSize: borderBarSize });
            }
        }
    };

    tidyMoveablesMap() {
        // console.log("tidyMoveablesMap");
        const tabs = new Map<string, TabNode>();
        this.props.model.visitNodes((node, _) => {
            if (node instanceof TabNode) {
                tabs.set(node.getId(), node);
            }
        });

        for (const [nodeId, element] of this.moveableElementMap) {
            if (!tabs.has(nodeId)) {
                // console.log("delete", nodeId);
                element.remove(); // remove from dom
                this.moveableElementMap.delete(nodeId); // remove map entry 
            }
        }
    }

    reorderComponents(components: Map<string, React.ReactNode>, ids: string[]) {
        const nextIds: string[] = [];
        const nextIdsSet = new Set<string>();

        let reordered: React.ReactNode[] = [];
        // Keep any previous tabs in the same DOM order as before, removing any that have been deleted
        for (const id of ids) {
            if (components.get(id)) {
                nextIds.push(id);
                nextIdsSet.add(id);
            }
        }
        ids.splice(0, ids.length, ...nextIds);

        // Add tabs that have been added to the DOM
        for (const [id, _] of components) {
            if (!nextIdsSet.has(id)) {
                ids.push(id);
            }
        }

        reordered = ids.map((id) => {
            return components.get(id);
        });

        return reordered;
    }

    onModelChange = (action: Action) => {
        this.redrawInternal("model change");
        if (this.props.onModelChange) {
            this.props.onModelChange(this.props.model, action);
        }
    };

    redraw(type?: string) {
        // console.log("redraw", this.windowId, type);
        this.mainLayout.setState((state, props) => { return { forceRevision: state.forceRevision + 1 } });
    }

    redrawInternal(type: string) {
        // console.log("redrawInternal", this.windowId, type);
        this.mainLayout.setState((state, props) => { return { layoutRevision: state.layoutRevision + 1 } });
    }

    doAction(action: Action): Node | undefined {
        if (this.props.onAction !== undefined) {
            const outcome = this.props.onAction(action);
            if (outcome !== undefined) {
                return this.props.model.doAction(outcome);
            }
            return undefined;
        } else {
            return this.props.model.doAction(action);
        }
    }

    updateRect = () => {
        const rect = this.getDomRect()
        if (!rect.equals(this.state.rect) && rect.width !== 0 && rect.height !== 0) {
            // console.log("updateRect", rect.floor());
            this.setState({ rect });
            if (this.windowId !== Model.MAIN_WINDOW_ID) {
                this.redrawInternal("rect updated");
            }
        }
    };

    getBoundingClientRect(div: HTMLElement): Rect {
        const layoutRect = this.getDomRect();
        if (layoutRect) {
            return Rect.getBoundingClientRect(div).relativeTo(layoutRect);
        }
        return Rect.empty();
    }

    getMoveableContainer() {
        return this.moveablesRef.current;
    }

    getMoveableElement(id: string) {
        let moveableElement = this.moveableElementMap.get(id);
        if (moveableElement === undefined) {
            moveableElement = document.createElement("div");
            this.moveablesRef.current!.appendChild(moveableElement);
            moveableElement.className = CLASSES.FLEXLAYOUT__TAB_MOVEABLE;
            this.moveableElementMap.set(id, moveableElement);
        }
        return moveableElement;
    }

    getMainLayout() {
        return this.mainLayout;
    }

    getClassName = (defaultClassName: string) => {
        if (this.props.classNameMapper === undefined) {
            return defaultClassName;
        } else {
            return this.props.classNameMapper(defaultClassName);
        }
    };

    getCurrentDocument() {
        return this.currentDocument;
    }

    getDomRect() {
        if (this.selfRef.current) {
            return Rect.fromDomRect(this.selfRef.current.getBoundingClientRect());
        } else {
            return Rect.empty();
        }
    }

    getWindowId() {
        return this.windowId;
    }

    getRootDiv() {
        return this.selfRef.current;
    }

    getMainElement() {
        return this.mainRef.current;
    }

    getFactory() {
        return this.props.factory;
    }

    isSupportsPopout() {
        return this.supportsPopout;
    }

    isRealtimeResize() {
        return this.props.realtimeResize ?? false;
    }

    getPopoutURL() {
        return this.popoutURL;
    }

    setEditingTab(tabNode?: TabNode) {
        this.setState({ editingTab: tabNode });
    }

    getEditingTab() {
        return this.state.editingTab;
    }

    getModel() {
        return this.props.model;
    }

    onCloseWindow = (windowLayout: LayoutWindow) => {
        this.doAction(Actions.closeWindow(windowLayout.windowId));
    };

    onSetWindow = (windowLayout: LayoutWindow, window: Window) => {
    };

    getScreenRect(inRect: Rect) {
        const rect = inRect.clone();
        const layoutRect = this.getDomRect();
        // Note: outerHeight can be less than innerHeight when window is zoomed, so cannot use
        // const navHeight = Math.min(65, this.currentWindow!.outerHeight - this.currentWindow!.innerHeight);
        // const navWidth = Math.min(65, this.currentWindow!.outerWidth - this.currentWindow!.innerWidth);
        const navHeight = 60;
        const navWidth = 2;
        // console.log(rect.y, this.currentWindow!.screenX,layoutRect.y);
        rect.x = this.currentWindow!.screenX + this.currentWindow!.scrollX + navWidth / 2 + layoutRect.x + rect.x;
        rect.y = this.currentWindow!.screenY + this.currentWindow!.scrollY + (navHeight - navWidth / 2) + layoutRect.y + rect.y;
        rect.height += navHeight;
        rect.width += navWidth;
        return rect;
    }

    addTabToTabSet(tabsetId: string, json: IJsonTabNode): TabNode | undefined {
        const tabsetNode = this.props.model.getNodeById(tabsetId);
        if (tabsetNode !== undefined) {
            const node = this.doAction(Actions.addNode(json, tabsetId, DockLocation.CENTER, -1));
            return node as TabNode;
        }
        return undefined;
    }

    addTabToActiveTabSet(json: IJsonTabNode): TabNode | undefined {
        const tabsetNode = this.props.model.getActiveTabset(this.windowId);
        if (tabsetNode !== undefined) {
            const node = this.doAction(Actions.addNode(json, tabsetNode.getId(), DockLocation.CENTER, -1));
            return node as TabNode;
        }
        return undefined;
    }

    showControlInPortal = (control: React.ReactNode, element: HTMLElement) => {
        const portal = createPortal(control, element) as React.ReactPortal;
        this.setState({ portal });
    };

    hideControlInPortal = () => {
        this.setState({ portal: undefined });
    };

    getIcons = () => {
        return this.icons;
    };

    maximize(tabsetNode: TabSetNode) {
        this.doAction(Actions.maximizeToggle(tabsetNode.getId(), this.getWindowId()));
    }

    customizeTab(
        tabNode: TabNode,
        renderValues: ITabRenderValues,
    ) {
        if (this.props.onRenderTab) {
            this.props.onRenderTab(tabNode, renderValues);
        }
    }

    customizeTabSet(
        tabSetNode: TabSetNode | BorderNode,
        renderValues: ITabSetRenderValues,
    ) {
        if (this.props.onRenderTabSet) {
            this.props.onRenderTabSet(tabSetNode, renderValues);
        }
    }

    i18nName(id: I18nLabel, param?: string) {
        let message;
        if (this.props.i18nMapper) {
            message = this.props.i18nMapper(id, param);
        }
        if (message === undefined) {
            message = id + (param === undefined ? "" : param);
        }
        return message;
    }

    getShowOverflowMenu() {
        return this.props.onShowOverflowMenu;
    }

    getTabSetPlaceHolderCallback() {
        return this.props.onTabSetPlaceHolder;
    }

    showContextMenu(node: TabNode | TabSetNode | BorderNode, event: React.MouseEvent<HTMLElement, MouseEvent>) {
        if (this.props.onContextMenu) {
            this.props.onContextMenu(node, event);
        }
    }

    auxMouseClick(node: TabNode | TabSetNode | BorderNode, event: React.MouseEvent<HTMLElement, MouseEvent>) {
        if (this.props.onAuxMouseClick) {
            this.props.onAuxMouseClick(node, event);
        }
    }

    public showOverlay(show: boolean) {
        this.setState({ showOverlay: show });
        enablePointerOnIFrames(!show, this.currentDocument!);
    }



    // *************************** Start Drag Drop *************************************

    addTabWithDragAndDrop(event: DragEvent, json: IJsonTabNode, onDrop?: (node?: Node, event?: React.DragEvent<HTMLElement>) => void) {
        const tempNode = TabNode.fromJson(json, this.props.model, false);
        LayoutInternal.dragState = new DragState(this.mainLayout, DragSource.Add, tempNode, json, onDrop);
    }

    moveTabWithDragAndDrop(event: DragEvent, node: (TabNode | TabSetNode)) {
        this.setDragNode(event, node);
    }

    public setDragNode = (event: DragEvent, node: Node & IDraggable) => {
        LayoutInternal.dragState = new DragState(this.mainLayout, DragSource.Internal, node, undefined, undefined);
        // Note: can only set (very) limited types on android! so cannot set json
        // Note: must set text/plain for android to allow drag, 
        //  so just set a simple message indicating its a flexlayout drag (this is not used anywhere else)
        event.dataTransfer!.setData('text/plain', "--flexlayout--");
        event.dataTransfer!.effectAllowed = "copyMove";
        event.dataTransfer!.dropEffect = "move";

        this.dragEnterCount = 0;

        if (node instanceof TabSetNode) {
            let rendered = false;
            let content = this.i18nName(I18nLabel.Move_Tabset);
            if (node.getChildren().length > 0) {
                content = this.i18nName(I18nLabel.Move_Tabs).replace("?", String(node.getChildren().length));
            }
            if (this.props.onRenderDragRect) {
                const dragComponent = this.props.onRenderDragRect(content, node, undefined);
                if (dragComponent) {
                    this.setDragComponent(event, dragComponent, 10, 10);
                    rendered = true;
                }
            }
            if (!rendered) {
                this.setDragComponent(event, content, 10, 10);
            }
        } else {
            const element = event.target as HTMLElement;
            const rect = element.getBoundingClientRect();
            const offsetX = event.clientX - rect.left;
            const offsetY = event.clientY - rect.top;
            const parentNode = node?.getParent();
            const isInVerticalBorder = parentNode instanceof BorderNode && (parentNode as BorderNode).getOrientation() === Orientation.HORZ;
            const x = isInVerticalBorder ? 10 : offsetX;
            const y = isInVerticalBorder ? 10 : offsetY;

            let rendered = false;
            if (this.props.onRenderDragRect) {
                const content = <TabButtonStamp key={node.getId()} layout={this} node={node as TabNode} />;
                const dragComponent = this.props.onRenderDragRect(content, node, undefined);
                if (dragComponent) {
                    this.setDragComponent(event, dragComponent, x, y);
                    rendered = true;
                }
            }
            if (!rendered) {
                if (isSafari()) { // safari doesnt render the offscreen tabstamps
                    this.setDragComponent(event, <TabButtonStamp node={node as TabNode} layout={this} />, x, y);
                } else {
                    event.dataTransfer!.setDragImage((node as TabNode).getTabStamp()!, x, y);
                }
            }
        }
    };



    public setDragComponent(event: DragEvent, component: React.ReactNode, x: number, y: number) {
        let dragElement = (
            <div style={{ position: "unset" }}
                className={this.getClassName(CLASSES.FLEXLAYOUT__LAYOUT) + " " + this.getClassName(CLASSES.FLEXLAYOUT__DRAG_RECT)}>
                {component}
            </div>
        );

        const tempDiv = this.currentDocument!.createElement('div');
        tempDiv.setAttribute("data-layout-path", "/drag-rectangle");
        tempDiv.style.position = "absolute";
        tempDiv.style.left = "-10000px";
        tempDiv.style.top = "-10000px";
        this.currentDocument!.body.appendChild(tempDiv);
        createRoot(tempDiv).render(dragElement);

        event.dataTransfer!.setDragImage(tempDiv, x, y);
        setTimeout(() => {
            this.currentDocument!.body.removeChild(tempDiv!);
        }, 0);
    }

    setDraggingOverWindow(overWindow: boolean) {
        // console.log("setDraggingOverWindow", overWindow);
        if (this.isDraggingOverWindow !== overWindow) {
            if (this.outlineDiv) {
                this.outlineDiv!.style.visibility = overWindow ? "hidden" : "visible";
            }

            if (overWindow) {
                this.setState({ showEdges: false });
            } else {
                // add edge indicators
                if (this.props.model.getMaximizedTabset(this.windowId) === undefined) {
                    this.setState({ showEdges: this.props.model.isEnableEdgeDock() });
                }
            }

            this.isDraggingOverWindow = overWindow;
        }
    }

    onDragEnterRaw = (event: React.DragEvent<HTMLElement>) => {
        this.dragEnterCount++;
        if (this.dragEnterCount === 1) {
            this.onDragEnter(event);
        }
    }

    onDragLeaveRaw = (event: React.DragEvent<HTMLElement>) => {
        this.dragEnterCount--;
        if (this.dragEnterCount === 0) {
            this.onDragLeave(event);
        }
    }

    clearDragMain() {
        // console.log("clear drag main");
        LayoutInternal.dragState = undefined;
        if (this.windowId === Model.MAIN_WINDOW_ID) {
            this.isDraggingOverWindow = false;
        }
        for (const [, layoutWindow] of this.props.model.getwindowsMap()) {
            // console.log(layoutWindow);
            layoutWindow.layout!.clearDragLocal();
        }
    }

    clearDragLocal() {
        // console.log("clear drag local", this.windowId);
        this.setState({ showEdges: false });
        this.showOverlay(false);
        this.dragEnterCount = 0;
        this.dragging = false;
        if (this.outlineDiv) {
            this.selfRef.current!.removeChild(this.outlineDiv);
            this.outlineDiv = undefined;
        }
    }

    onDragEnter = (event: React.DragEvent<HTMLElement>) => {
        // console.log("onDragEnter", this.windowId, this.dragEnterCount);

        if (!LayoutInternal.dragState && this.props.onExternalDrag) { // not internal dragging
            const externalDrag = this.props.onExternalDrag!(event);
            if (externalDrag) {
                const tempNode = TabNode.fromJson(externalDrag.json, this.props.model, false);
                LayoutInternal.dragState = new DragState(this.mainLayout, DragSource.External, tempNode, externalDrag.json, externalDrag.onDrop);
            }
        }

        if (LayoutInternal.dragState) {
            if (this.windowId !== Model.MAIN_WINDOW_ID && LayoutInternal.dragState.mainLayout === this.mainLayout) {
                LayoutInternal.dragState.mainLayout.setDraggingOverWindow(true);
            }

            if (LayoutInternal.dragState.mainLayout !== this.mainLayout) {
                return; // drag not by this layout or its popouts
            }

            event.preventDefault();

            this.dropInfo = undefined;
            const rootdiv = this.selfRef.current;
            this.outlineDiv = this.currentDocument!.createElement("div");
            this.outlineDiv.className = this.getClassName(CLASSES.FLEXLAYOUT__OUTLINE_RECT);
            this.outlineDiv.style.visibility = "hidden";
            const speed = this.props.model.getAttribute("tabDragSpeed") as number;
            this.outlineDiv.style.transition = `top ${speed}s, left ${speed}s, width ${speed}s, height ${speed}s`;

            rootdiv!.appendChild(this.outlineDiv);

            this.dragging = true;
            this.showOverlay(true);
            // add edge indicators
            if (!this.isDraggingOverWindow && this.props.model.getMaximizedTabset(this.windowId) === undefined) {
                this.setState({ showEdges: this.props.model.isEnableEdgeDock() });
            }

            const clientRect = this.selfRef.current?.getBoundingClientRect()!;
            const r = new Rect(
                event.clientX - (clientRect.left),
                event.clientY - (clientRect.top),
                1, 1
            );
            r.positionElement(this.outlineDiv);
        }
    }

    onDragOver = (event: React.DragEvent<HTMLElement>) => {
        if (this.dragging && !this.isDraggingOverWindow) {
            // console.log("onDragOver");

            event.preventDefault();
            const clientRect = this.selfRef.current?.getBoundingClientRect();
            const pos = {
                x: event.clientX - (clientRect?.left ?? 0),
                y: event.clientY - (clientRect?.top ?? 0),
            };

            this.checkForBorderToShow(pos.x, pos.y);

            let dropInfo = this.props.model.findDropTargetNode(this.windowId, LayoutInternal.dragState!.dragNode!, pos.x, pos.y);
            if (dropInfo) {
                this.dropInfo = dropInfo;
                if (this.outlineDiv) {
                    this.outlineDiv.className = this.getClassName(dropInfo.className);
                    dropInfo.rect.positionElement(this.outlineDiv);
                    this.outlineDiv.style.visibility = "visible";
                }
            }
        }
    }

    onDragLeave = (event: React.DragEvent<HTMLElement>) => {
        // console.log("onDragLeave", this.windowId, this.dragging);
        if (this.dragging) {
            if (this.windowId !== Model.MAIN_WINDOW_ID) {
                LayoutInternal.dragState!.mainLayout.setDraggingOverWindow(false);
            }

            this.clearDragLocal();
        }
    }

    onDrop = (event: React.DragEvent<HTMLElement>) => {
        // console.log("ondrop", this.windowId, this.dragging, Layout.dragState);

        if (this.dragging) {
            event.preventDefault();

            const dragState = LayoutInternal.dragState!;
            if (this.dropInfo) {
                if (dragState.dragJson !== undefined) {
                    const newNode = this.doAction(Actions.addNode(dragState.dragJson, this.dropInfo.node.getId(), this.dropInfo.location, this.dropInfo.index));

                    if (dragState.fnNewNodeDropped !== undefined) {
                        dragState.fnNewNodeDropped(newNode, event);
                    }
                } else if (dragState.dragNode !== undefined) {
                    this.doAction(Actions.moveNode(dragState.dragNode.getId(), this.dropInfo.node.getId(), this.dropInfo.location, this.dropInfo.index));
                }
            }

            this.mainLayout.clearDragMain();
        }
        this.dragEnterCount = 0; // must set to zero here ref sublayouts
    }

    // *************************** End Drag Drop *************************************
}

export const FlexLayoutVersion = "0.8.8";

export type DragRectRenderCallback = (
    content: React.ReactNode | undefined,
    node?: Node,
    json?: IJsonTabNode
) => React.ReactNode | undefined;

export type NodeMouseEvent = (
    node: TabNode | TabSetNode | BorderNode,
    event: React.MouseEvent<HTMLElement, MouseEvent>
) => void;

export type ShowOverflowMenuCallback = (
    node: TabSetNode | BorderNode,
    mouseEvent: React.MouseEvent<HTMLElement, MouseEvent>,
    items: { index: number; node: TabNode }[],
    onSelect: (item: { index: number; node: TabNode }) => void,
) => void;

export type TabSetPlaceHolderCallback = (node: TabSetNode) => React.ReactNode;

export interface ITabSetRenderValues {
    /** components that will be added after the tabs */
    stickyButtons: React.ReactNode[];
    /** components that will be added at the end of the tabset */
    buttons: React.ReactNode[];
    /** position to insert overflow button within [...stickyButtons, ...buttons]
     * if left undefined position will be after the sticky buttons (if any) 
     */
    overflowPosition: number | undefined;
}

export interface ITabRenderValues {
    /** the icon or other leading component */
    leading: React.ReactNode;
    /** the main tab text/component */
    content: React.ReactNode;
    /** a set of react components to add to the tab after the content */
    buttons: React.ReactNode[];
}

export interface IIcons {
    close?: (React.ReactNode | ((tabNode: TabNode) => React.ReactNode));
    closeTabset?: (React.ReactNode | ((tabSetNode: TabSetNode) => React.ReactNode));
    popout?: (React.ReactNode | ((tabNode: TabNode) => React.ReactNode));
    maximize?: (React.ReactNode | ((tabSetNode: TabSetNode) => React.ReactNode));
    restore?: (React.ReactNode | ((tabSetNode: TabSetNode) => React.ReactNode));
    more?: (React.ReactNode | ((tabSetNode: (TabSetNode | BorderNode), hiddenTabs: { node: TabNode; index: number }[]) => React.ReactNode));
    edgeArrow?: React.ReactNode;
    activeTabset?: (React.ReactNode | ((tabSetNode: TabSetNode) => React.ReactNode));
}

const defaultIcons = {
    close: <CloseIcon />,
    closeTabset: <CloseIcon />,
    popout: <PopoutIcon />,
    maximize: <MaximizeIcon />,
    restore: <RestoreIcon />,
    more: <OverflowIcon />,
    edgeArrow: <EdgeIcon />,
    activeTabset: <AsterickIcon />
};

enum DragSource {
    Internal = "internal",
    External = "external",
    Add = "add"
}

/** @internal */
const defaultSupportsPopout: boolean = isDesktop();

/** @internal */
const edgeRectLength = 100;
/** @internal */
const edgeRectWidth = 10;

// global layout drag state
class DragState {
    public readonly mainLayout: LayoutInternal;
    public readonly dragSource: DragSource;
    public readonly dragNode: Node & IDraggable | undefined;
    public readonly dragJson: IJsonTabNode | undefined;
    public readonly fnNewNodeDropped: ((node?: Node, event?: React.DragEvent<HTMLElement>) => void) | undefined;

    public constructor(
        mainLayout: LayoutInternal,
        dragSource: DragSource,
        dragNode: Node & IDraggable | undefined,
        dragJson: IJsonTabNode | undefined,
        fnNewNodeDropped: ((node?: Node, event?: React.DragEvent<HTMLElement>) => void) | undefined
    ) {
        this.mainLayout = mainLayout;
        this.dragSource = dragSource;
        this.dragNode = dragNode;
        this.dragJson = dragJson;
        this.fnNewNodeDropped = fnNewNodeDropped;
    }
}
```

## File: src/view/Row.tsx

```tsx
import * as React from "react";
import { RowNode } from "../model/RowNode";
import { TabSetNode } from "../model/TabSetNode";
import { CLASSES } from "../Types";
import { LayoutInternal } from "./Layout";
import { TabSet } from "./TabSet";
import { Splitter } from "./Splitter";
import { Orientation } from "../Orientation";

/** @internal */
export interface IRowProps {
    layout: LayoutInternal;
    node: RowNode;
}

/** @internal */
export const Row = (props: IRowProps) => {
    const { layout, node } = props;
    const selfRef = React.useRef<HTMLDivElement | null>(null);

    const horizontal = node.getOrientation() === Orientation.HORZ;

    React.useLayoutEffect(() => {
        node.setRect(layout.getBoundingClientRect(selfRef.current!));
    });

    const items: React.ReactNode[] = [];

    let i = 0;

    for (const child of node.getChildren()) {
        if (i > 0) {
            items.push(<Splitter key={"splitter" + i} layout={layout} node={node} index={i} horizontal={horizontal} />)
        }
        if (child instanceof RowNode) {
            items.push(<Row key={child.getId()} layout={layout} node={child} />);
        } else if (child instanceof TabSetNode) {
            items.push(<TabSet key={child.getId()} layout={layout} node={child} />);
        }
        i++;
    }

    const style: Record<string, any> = {
        flexGrow: Math.max(1, node.getWeight()*1000), // NOTE:  flex-grow cannot have values < 1 otherwise will not fill parent, need to normalize 
        minWidth: node.getMinWidth(),
        minHeight: node.getMinHeight(),
        maxWidth: node.getMaxWidth(),
        maxHeight: node.getMaxHeight(),
    };

    if (horizontal) {
        style.flexDirection = "row";
    } else {
        style.flexDirection = "column";
    }

     return (
        <div
            ref={selfRef}
            className={layout.getClassName(CLASSES.FLEXLAYOUT__ROW)}
            style={style}
            >
            {items}
        </div>
    );
};



```

## File: src/view/TabButton.tsx

```tsx
import * as React from "react";
import { I18nLabel } from "../I18nLabel";
import { Actions } from "../model/Actions";
import { TabNode } from "../model/TabNode";
import { TabSetNode } from "../model/TabSetNode";
import { LayoutInternal } from "./Layout";
import { ICloseType } from "../model/ICloseType";
import { CLASSES } from "../Types";
import { getRenderStateEx, isAuxMouseEvent } from "./Utils";

/** @internal */
export interface ITabButtonProps {
    layout: LayoutInternal;
    node: TabNode;
    selected: boolean;
    path: string;
}

/** @internal */
export const TabButton = (props: ITabButtonProps) => {
    const { layout, node, selected, path } = props;
    const selfRef = React.useRef<HTMLDivElement | null>(null);
    const contentRef = React.useRef<HTMLInputElement | null>(null);
    const icons = layout.getIcons();

    React.useLayoutEffect(() => {
        node.setTabRect(layout.getBoundingClientRect(selfRef.current!));
        if (layout.getEditingTab() === node) {
            (contentRef.current! as HTMLInputElement).select();
        }
    });

    const onDragStart = (event: React.DragEvent<HTMLElement>) => {
        if (node.isEnableDrag()) {
            event.stopPropagation(); // prevent starting a tabset drag as well
            layout.setDragNode(event.nativeEvent, node as TabNode);
        } else {
            event.preventDefault();
        }
    };

    const onDragEnd = (event: React.DragEvent<HTMLElement>) => {
        layout.clearDragMain();
    };

    const onAuxMouseClick = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        if (isAuxMouseEvent(event)) {
            layout.auxMouseClick(node, event);
        } 
    };

    const onContextMenu = (event: React.MouseEvent<HTMLElement, MouseEvent>) => {
        layout.showContextMenu(node, event);
    };

    const onClick = () => {
        layout.doAction(Actions.selectTab(node.getId()));
    };

    const onDoubleClick = (event: React.MouseEvent<HTMLElement>) => {
        if (node.isEnableRename()) {
            onRename();
            event.stopPropagation();
        }
    };

    const onRename = () => {
        layout.setEditingTab(node);
        layout.getCurrentDocument()!.body.addEventListener("pointerdown", onEndEdit);
    };

    const onEndEdit = (event: Event) => {
        if (event.target !== contentRef.current!) {
            layout.getCurrentDocument()!.body.removeEventListener("pointerdown", onEndEdit);
            layout.setEditingTab(undefined);
        }
    };

    const isClosable = () => {
        const closeType = node.getCloseType();
        if (selected || closeType === ICloseType.Always) {
            return true;
        }
        if (closeType === ICloseType.Visible) {
            // not selected but x should be visible due to hover
            if (window.matchMedia && window.matchMedia("(hover: hover) and (pointer: fine)").matches) {
                return true;
            }
        }
        return false;
    };

    const onClose = (event: React.MouseEvent<HTMLElement>) => {
        if (isClosable()) {
            layout.doAction(Actions.deleteTab(node.getId()));
        } else {
            onClick();
        }
    };

    const onClosePointerDown = (event: React.PointerEvent<HTMLElement>) => {
        event.stopPropagation();
    };

    const onTextBoxPointerDown = (event: React.PointerEvent<HTMLInputElement>) => {
        event.stopPropagation();
    };

    const onTextBoxKeyPress = (event: React.KeyboardEvent<HTMLInputElement>) => {
        if (event.code === 'Escape') {
            // esc
            layout.setEditingTab(undefined);
        } else if (event.code === 'Enter') {
            // enter
            layout.setEditingTab(undefined);
            layout.doAction(Actions.renameTab(node.getId(), (event.target as HTMLInputElement).value));
        }
    };

    const cm = layout.getClassName;
    const parentNode = node.getParent() as TabSetNode;

    const isStretch = parentNode.isEnableSingleTabStretch() && parentNode.getChildren().length === 1;
    let baseClassName = isStretch ? CLASSES.FLEXLAYOUT__TAB_BUTTON_STRETCH : CLASSES.FLEXLAYOUT__TAB_BUTTON;
    let classNames = cm(baseClassName);
    classNames += " " + cm(baseClassName + "_" + parentNode.getTabLocation());

    if (!isStretch) {
        if (selected) {
            classNames += " " + cm(baseClassName + "--selected");
        } else {
            classNames += " " + cm(baseClassName + "--unselected");
        }
    }

    if (node.getClassName() !== undefined) {
        classNames += " " + node.getClassName();
    }

    const renderState = getRenderStateEx(layout, node);

    let content = renderState.content ? (
        <div className={cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_CONTENT)}>
            {renderState.content}
        </div>) : null;

    const leading = renderState.leading ? (
        <div className={cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_LEADING)}>
            {renderState.leading}
        </div>) : null;

    if (layout.getEditingTab() === node) {
        content = (
            <input
                ref={contentRef}
                className={cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_TEXTBOX)}
                data-layout-path={path + "/textbox"}
                type="text"
                autoFocus={true}
                defaultValue={node.getName()}
                onKeyDown={onTextBoxKeyPress}
                onPointerDown={onTextBoxPointerDown}
            />
        );
    }

    if (node.isEnableClose() && !isStretch) {
        const closeTitle = layout.i18nName(I18nLabel.Close_Tab);
        renderState.buttons.push(
            <div
                key="close"
                data-layout-path={path + "/button/close"}
                title={closeTitle}
                className={cm(CLASSES.FLEXLAYOUT__TAB_BUTTON_TRAILING)}
                onPointerDown={onClosePointerDown}
                onClick={onClose}>
                {(typeof icons.close === "function") ? icons.close(node) : icons.close}
            </div>
        );
    }

    return (
        <div
            ref={selfRef}
            data-layout-path={path}
            className={classNames}
            onClick={onClick}
            onAuxClick={onAuxMouseClick}
            onContextMenu={onContextMenu}
            title={node.getHelpText()}
            draggable={true}
            onDragStart={onDragStart}
            onDragEnd={onDragEnd}
            onDoubleClick={onDoubleClick}
        >
            {leading}
            {content}
            {renderState.buttons}
        </div>
    );
};

```

## File: src/view/Icons.tsx

```tsx
import * as React from "react";

const style = { width: "1em", height: "1em", display: "flex", alignItems: "center" };

export const CloseIcon = () => {
    return (
        <svg xmlns="http://www.w3.org/2000/svg" style={style} viewBox="0 0 24 24" >
            <path fill="none" d="M0 0h24v24H0z" />
            <path stroke="var(--color-icon)" fill="var(--color-icon)" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" />
        </svg>
    );
}

export const MaximizeIcon = () => {
    return (
        <svg xmlns="http://www.w3.org/2000/svg" style={style} viewBox="0 0 24 24" fill="var(--color-icon)"><path d="M0 0h24v24H0z" fill="none" /><path stroke="var(--color-icon)" d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z" /></svg>
    );
}

export const OverflowIcon = () => {
    return (
        <svg xmlns="http://www.w3.org/2000/svg" style={style} viewBox="0 0 24 24" fill="var(--color-icon)"><path d="M0 0h24v24H0z" fill="none" /><path stroke="var(--color-icon)" d="M7 10l5 5 5-5z" /></svg>
    );
}

export const EdgeIcon = () => {
    return (
        <svg xmlns="http://www.w3.org/2000/svg" style={{display:"block",  width:10, height:10}} preserveAspectRatio="none" viewBox="0 0 100 100"><path  fill="var(--color-edge-icon)" stroke="var(--color-edge-icon)" 
            d="M10 30 L90 30 l-40 40 Z" /></svg>
    );
}

export const PopoutIcon = () => {
    return (
        // <svg xmlns="http://www.w3.org/2000/svg"  style={style}  viewBox="0 0 24 24" fill="var(--color-icon)"><path d="M0 0h24v24H0z" fill="none"/><path stroke="var(--color-icon)" d="M9 5v2h6.59L4 18.59 5.41 20 17 8.41V15h2V5z"/></svg>
        
        // <svg xmlns="http://www.w3.org/2000/svg" style={style} fill="none" viewBox="0 0 24 24" stroke="var(--color-icon)" stroke-width="2">
        //     <path stroke-linecap="round" stroke-linejoin="round" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
        // </svg>

        <svg xmlns="http://www.w3.org/2000/svg" style={style} viewBox="0 0 20 20" fill="var(--color-icon)">
            <path d="M11 3a1 1 0 100 2h2.586l-6.293 6.293a1 1 0 101.414 1.414L15 6.414V9a1 1 0 102 0V4a1 1 0 00-1-1h-5z" />
            <path d="M5 5a2 2 0 00-2 2v8a2 2 0 002 2h8a2 2 0 002-2v-3a1 1 0 10-2 0v3H5V7h3a1 1 0 000-2H5z" />
        </svg>

    );
}

export const RestoreIcon = () => {
    return (
        <svg xmlns="http://www.w3.org/2000/svg" style={style} viewBox="0 0 24 24" fill="var(--color-icon)"><path d="M0 0h24v24H0z" fill="none" /><path stroke="var(--color-icon)" d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z" /></svg>
    );
}

export const AsterickIcon = () => {
    return (
        <svg xmlns="http://www.w3.org/2000/svg" style={style} height="24px" viewBox="0 -960 960 960" width="24px" ><path fill="var(--color-icon)" stroke="var(--color-icon)" d="M440-120v-264L254-197l-57-57 187-186H120v-80h264L197-706l57-57 186 187v-264h80v264l186-187 57 57-187 186h264v80H576l187 186-57 57-186-187v264h-80Z"/></svg>
    );
}
```

## File: src/view/Utils.tsx

```tsx
import * as React from "react";
import { Node } from "../model/Node";
import { TabNode } from "../model/TabNode";
import { LayoutInternal } from "./Layout";
import { TabSetNode } from "../model/TabSetNode";

/** @internal */
export function isDesktop() {
    const desktop = typeof window !== "undefined" && window.matchMedia && window.matchMedia("(hover: hover) and (pointer: fine)").matches;
    return desktop;
}
/** @internal */
export function getRenderStateEx(
    layout: LayoutInternal,
    node: TabNode,
    iconAngle?: number
) {
    let leadingContent = undefined;
    let titleContent: React.ReactNode = node.getName();
    let name = node.getName();
    if (iconAngle === undefined) {
        iconAngle = 0;
    }

    if (leadingContent === undefined && node.getIcon() !== undefined) {
        if (iconAngle !== 0) {
            leadingContent = <img style={{ width: "1em", height: "1em", transform: "rotate(" + iconAngle + "deg)" }} src={node.getIcon()} alt="leadingContent" />;
        } else {
            leadingContent = <img style={{ width: "1em", height: "1em" }} src={node.getIcon()} alt="leadingContent" />;
        }
    }

    let buttons: any[] = [];

    // allow customization of leading contents (icon) and contents
    const renderState = { leading: leadingContent, content: titleContent, name, buttons };
    layout.customizeTab(node, renderState);

    node.setRenderedName(renderState.name);

    return renderState;
}

/** @internal */
export function isAuxMouseEvent(event: React.MouseEvent<HTMLElement, MouseEvent> | React.TouchEvent<HTMLElement>) {
    let auxEvent = false;
    if (event.nativeEvent instanceof MouseEvent) {
        if (event.nativeEvent.button !== 0 || event.ctrlKey || event.altKey || event.metaKey || event.shiftKey) {
            auxEvent = true;
        }
    }
    return auxEvent;
}

export function enablePointerOnIFrames(enable: boolean, currentDocument: Document) {
    const iframes = [
        ...getElementsByTagName('iframe', currentDocument),
        ...getElementsByTagName('webview', currentDocument),
    ];

    for (const iframe of iframes) {
        (iframe as HTMLElement).style.pointerEvents = enable ? 'auto' : 'none';
    }
};

export function getElementsByTagName(tag: string, currentDocument: Document): Element[] {
    return [...currentDocument.getElementsByTagName(tag)];
}

export function startDrag(
    doc: Document,
    event: React.PointerEvent<HTMLElement>,
    drag: (x: number, y: number) => void,
    dragEnd: () => void,
    dragCancel: () => void) {

    event.preventDefault();

    const pointerMove = (ev: PointerEvent) => {
        ev.preventDefault();
        drag(ev.clientX, ev.clientY);
    };

    const pointerCancel = (ev: PointerEvent) => {
        ev.preventDefault();
        dragCancel();
    };
    const pointerUp = () => {
        doc.removeEventListener("pointermove", pointerMove);
        doc.removeEventListener("pointerup", pointerUp);
        doc.removeEventListener("pointercancel", pointerCancel);
        dragEnd();
    };

    doc.addEventListener("pointermove", pointerMove);
    doc.addEventListener("pointerup", pointerUp);
    doc.addEventListener('pointercancel', pointerCancel);
}

export function canDockToWindow(node: Node) {
    if (node instanceof TabNode) {
        return node.isEnablePopout();
    } else if (node instanceof TabSetNode) {
        for (const child of node.getChildren()) {
            if ((child as TabNode).isEnablePopout() === false) {
                return false;
            }
        }
        return true;
    }
    return false;
}

export function copyInlineStyles(source: HTMLElement, target: HTMLElement): boolean {
    // Get the inline style attribute from the source element
    const sourceStyle = source.getAttribute('style');
    const targetStyle = target.getAttribute('style');
    if (sourceStyle === targetStyle) return false;

    // console.log("copyInlineStyles", sourceStyle);
    
    if (sourceStyle) {
        // Set the style attribute on the target element
        target.setAttribute('style', sourceStyle);
    } else {
        // If the source has no inline style, clear the target's style attribute
        target.removeAttribute('style');
    }
    return true;
}

export function isSafari() {
    const userAgent = navigator.userAgent;
    return userAgent.includes("Safari") && !userAgent.includes("Chrome") && !userAgent.includes("Chromium");
  }

```

## File: src/view/Overlay.tsx

```tsx
import * as React from "react";
import { LayoutInternal } from "./Layout";
import { CLASSES } from "../Types";

/** @internal */
export interface IOverlayProps {
    layout: LayoutInternal;
    show: boolean;
}

/** @internal */
export const Overlay = (props: IOverlayProps) => {
    const {layout, show} = props;

    return (
        <div 
            className={layout.getClassName(CLASSES.FLEXLAYOUT__LAYOUT_OVERLAY)}
            style={{display: (show ? "flex" : "none")
        }}
        />
    );
}
```

## File: src/view/SizeTracker.tsx

```tsx
import * as React from "react";
import { Rect } from "../Rect";

export interface ISizeTrackerProps {
    rect: Rect;
    selected: boolean;
    forceRevision: number;
    tabsRevision: number;
    children: React.ReactNode;
}
// only render if size changed or forceRevision changed or tabsRevision changed
export const SizeTracker = React.memo(({ children }: ISizeTrackerProps) => {
    return <>{children}</>
}, (prevProps, nextProps) => {
    return prevProps.rect.equalSize(nextProps.rect) && 
    prevProps.selected === nextProps.selected &&
    prevProps.forceRevision === nextProps.forceRevision &&
    prevProps.tabsRevision === nextProps.tabsRevision
});


```

## File: src/view/DragContainer.tsx

```tsx
import * as React from "react";
import { TabNode } from "../model/TabNode";
import { LayoutInternal } from "./Layout";
import { CLASSES } from "../Types";
import { TabButtonStamp } from "./TabButtonStamp";

/** @internal */
export interface IDragContainerProps {
    node: TabNode;
    layout: LayoutInternal;
}

/** @internal */
export const DragContainer = (props: IDragContainerProps) => {
    const { layout, node} = props;
    const selfRef = React.useRef<HTMLDivElement | null>(null);

    React.useEffect(()=> {
        node.setTabStamp(selfRef.current);
    }, [node, selfRef.current]);

    const cm = layout.getClassName;

    let classNames = cm(CLASSES.FLEXLAYOUT__DRAG_RECT);

    return (<div
            ref={selfRef}
            className={classNames}>
            <TabButtonStamp key={node.getId()} layout={layout} node={node} />
        </div>
    );
};

```

## File: src/view/ErrorBoundary.tsx

```tsx
import * as React from "react";
import { ErrorInfo } from "react";
import { CLASSES } from "../Types";

/** @internal */
export interface IErrorBoundaryProps {
    message: string;
    children: React.ReactNode;
}
/** @internal */
export interface IErrorBoundaryState {
    hasError: boolean;
}

/** @internal */
export class ErrorBoundary extends React.Component<IErrorBoundaryProps, IErrorBoundaryState> {
    constructor(props: IErrorBoundaryProps) {
        super(props);
        this.state = { hasError: false };
    }

    static getDerivedStateFromError(error: Error) {
        return { hasError: true };
    }

    componentDidCatch(error: Error, errorInfo: ErrorInfo) {
        console.debug(error);
        console.debug(errorInfo);
    }

    render() {
        if (this.state.hasError) {
            return (
                <div className={CLASSES.FLEXLAYOUT__ERROR_BOUNDARY_CONTAINER}>
                    <div className={CLASSES.FLEXLAYOUT__ERROR_BOUNDARY_CONTENT}>{this.props.message}</div>
                </div>
            );
        }

        return this.props.children;
    }
}

```

